/**
 * This module provides a library of commonly used Regular Expressions.
 *
 * For more sophisticated use cases,
 * consider using Regex+ (https://www.npmjs.com/package/regex)
 */

const constants = require( "./Constants.cjs" );
const typeUtils = require( "./TypeUtils.cjs" );
const stringUtils = require( "./StringUtils.cjs" );
const arrayUtils = require( "./ArrayUtils.cjs" );

/**
 * Defines a string to represent the type, undefined
 */
const { _ud = "undefined" } = constants;

/**
 * This function returns the host environment scope (Browser window, Node.js global, or Worker self)
 */
const $scope = constants?.$scope || function()
{
    return (_ud === typeof self ? ((_ud === typeof global) ? {} : (global || {})) : (self || {}));
};

/**
 * This immediately invoked function expression (IIFE)
 * defines and returns the Regular Expressions Utilities module
 */
(function exposeModule()
{
    /**
     * Define a string key which is unlikely to collide with other libraries or properties.
     * We use this to store the module generated by this function in global scope.
     * We can avoid re-executing the rest of this function if the module is already defined.
     */
    const INTERNAL_NAME = "__BOCK__REGEX_UTILS__";

    /**
     * Checks to see if this module is already defines and available in the global scope
     * Returns the existing module instead of recreating it, if it is already present.
     */
    if ( $scope() && (null != $scope()[INTERNAL_NAME]) )
    {
        return $scope()[INTERNAL_NAME];
    }

    /**
     * An array of this module's dependencies
     * which are re-exported with this module,
     * so if you want to, you can just import the leaf module
     * and then use the other utilities as properties of that module
     */
    const dependencies =
        {
            constants,
            typeUtils,
            stringUtils,
            arrayUtils
        };

    /**
     * The following variable declarations are used
     */
    const { _mt_str, _mt_chr, _slash, _str, _obj, _fun, lock, classes, IllegalArgumentError } = constants;

    const { isString, isRegExp, isObject, isFunction } = typeUtils;

    const { asString, asInt, isBlank, lcase, ucase } = stringUtils;

    const { asArray, varargs, unique } = arrayUtils;

    const modName = "RegularExpressionUtils";

    const { ModulePrototype } = classes;

    const modulePrototype = new ModulePrototype( modName, INTERNAL_NAME );

    /**
     * Constants for regular expression flags
     */
    const FLAGS = lock(
        {
            GLOBAL: "g",
            INSENSITIVE: "i",
            WITH_INDICES: "d",
            DOTALL: "s",
            MULTILINE: "m",
            STICKY: "y",
            UNICODE: "u"
        } );

    /**
     * An array of the valid Regular Expression flags
     * @type {(string)[]}
     */
    const VALID_FLAGS = lock( [FLAGS.GLOBAL, FLAGS.INSENSITIVE, FLAGS.WITH_INDICES, FLAGS.DOTALL, FLAGS.MULTILINE, FLAGS.STICKY, FLAGS.UNICODE] );

    /**
     * Returns an array of only those strings which are valid RegExp flags
     * @param pFlags one or more strings that may or may not be valid RegExp flags
     * @returns {*[]} an array of only those strings which are valid RegExp flags
     */
    const getValidFlags = function( ...pFlags )
    {
        let flags = [].concat( varargs( ...pFlags ) );

        flags = flags.filter( e => isString( e ) );
        flags = unique( flags.map( e => lcase( e.trim() ).split( _mt_chr ) ).flat() );
        flags = unique( flags.filter( e => e.length === 1 && VALID_FLAGS.includes( e ) ) );

        return flags;
    };

    /**
     * This function compares two RegExp flags and orders them according to their position in the VALID_FLAGS array
     * @param pFlagA the first value
     * @param pFlagB the second value
     * @returns {number} a value < 0 if the first value should appear before the second,
     *                   a value > 0 if the first flag should appear after the second,
     *                   or 0 if the flags are the same value
     */
    const flagComparator = function( pFlagA, pFlagB )
    {
        const a = asString( pFlagA );
        const b = asString( pFlagB );

        let idxA = VALID_FLAGS.indexOf( a );
        let idxB = VALID_FLAGS.indexOf( b );

        let comp = idxA < idxB ? -1 : idxA > idxB ? 1 : 0;

        if ( 0 === comp )
        {
            comp = a < b ? -1 : a > b ? 1 : 0;
        }

        return comp;
    };

    /**
     * Returns an array of flags ordered according to their position in the VALID_FLAGS array
     * @param pFlags one or more flags to filter and sort according to the values in VALID_FLAGS
     * @returns {*[]} an array of flags ordered according to their position in the VALID_FLAGS array
     */
    const sortFlags = function( ...pFlags )
    {
        let flags = getValidFlags( ...pFlags );

        if ( flags && flags.length > 0 )
        {
            flags = [...(new Set( flags ))];

            flags = flags.sort( flagComparator );
        }

        return flags;
    };

    /**
     * This object is a map of commonly useful regular expressions.
     *
     * Because regular expressions can sometimes be used in stateful contexts,
     * the recommended practice is to use the 'get' method of this map
     * to receive a fresh and mutable instance of the RegExp.
     *
     */
    const REGULAR_EXPRESSIONS = lock(
        {
            /**
             * Matches a regular expression literal
             */
            REGEX: lock( /^\/.+\/[gidsmyu]*$/ ),

            /**
             * Matches a Globally Unique Identifier (GUID)
             */
            GUID: lock( /^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/i ),

            /**
             * Matches a single literal 'dot'
             */
            DOT: lock( /\./ ),

            /**
             * Matches two repeated slash characters.
             * Useful for replacing duplicated slashes in a path for example.
             */
            DOUBLE_SLASH: lock( /\/\// ),

            /**
             * Matches one or more newline characters at the start of a character string
             */
            LEADING_NEWLINE: lock( /^(\r\n)+|^\n+|^\r+/ ),

            /**
             * Matches one or more newline characters at the end of a character string
             */
            TRAILING_NEWLINE: lock( /(\r\n)+$|\n+$|\r+$/ ),

            /**
             * Matches one or more semicolons ';' at the end of a character string
             */
            TRAILING_SEMICOLON: lock( /;+$|(;((\r\n)+|\n+)+)$/ ),

            /**
             * Matches all whitespace characters at the start of a character string
             */
            LEADING_WHITESPACE: lock( /^\s+/ ),

            /**
             * Matches all whitespace characters at the end of a character string
             */
            TRAILING_WHITESPACE: lock( /\s+$/ ),

            /**
             * Matches the character string, '${', anywhere in a character string
             */
            VARIABLE_TOKEN_START: lock( /\$\{/ ),

            /**
             * Matches the character string, '}', anywhere in a character string
             */
            VARIABLE_TOKEN_END: lock( /}/ ),

            /**
             * Matches an interpolated variable such as ${myValue}
             */
            VARIABLE_TOKEN: lock( /\{[^}{]+}/ ),

            /**
             * Matches a single slash, '/', character anywhere is a string
             */
            SLASH: lock( /\// ),

            /**
             * Matches one or more slashes at the end of a character string.
             * Useful for trimming trailing slashes from paths or URLs
             */
            LEADING_OR_TRAILING_SLASH: lock( /^\/+|\/+$/ ),

            /**
             * Matches a single backslash, '\', character anywhere is a string
             */
            BACKSLASH: lock( /\\/ ),

            /**
             * Matches the literal dollar symbol, $, anywhere in a character string
             */
            DOLLAR_SYMBOL: lock( /\$/ ),

            /**
             * Matches the last sequence of characters starting with a dot, followed by alphanumeric characters.
             * Useful for extracting a file extension
             */
            EXTENSION: lock( /\.\w+$/ ),

            /**
             * Matches either a colon or an equals sign.
             * Useful when parsing source code or json text
             */
            ASSIGNMENT_OPERATOR: lock( /[=:]/ ),

            /**
             * Matches either a comma or a semicolon anywhere in a string.
             * Useful for splitting or joining values
             */
            SEPARATOR: lock( /[,;]/ ),

            /**
             * Matches the carriage return + newline sequence used as a newline in non-unix environments.
             */
            WINDOWS_NEWLINE: lock( /\r\n/ ),

            /**
             * Matches the '\n' character used as a newline in unix/linux environments
             */
            NEWLINE: lock( /\n/ ),

            /**
             * Matches two or more repeated newlines.
             * Useful for removing extraneous whitespace
             */
            REDUNDANT_NEWLINES: lock( /\n{2,}|(\r\n){2,}/ ),

            /**
             * Matches the source text corresponding to a function signature.
             * Useful for parsing source code
             */
            SIMPLE_FUNCTION_SIGNATURE: lock( /(function)\s*([^(]*)*\(([^)]*)\)/ ),

            /**
             * Matches the source text corresponding to an asynchronous function signature.
             * Useful for parsing source code
             */
            SIMPLE_ASYNC_FUNCTION_SIGNATURE: lock( /(async)\s*(function)\s*([^(]*)*\(([^)]*)\)/ ),

            /**
             * Matches the first integer portion of a string
             */
            INTEGER: lock( /(-?\d+)/ ),

            /**
             * Matches only strings that represent a whole number value
             */
            VALID_INTEGER: lock( /^(-?\d+)$/ ),

            /**
             * Matches the first floating point value portion of a string
             */
            FLOAT: lock( /(-?\d+(\.\d+)?)/ ),

            /**
             * Matches only strings that represent a valid number
             */
            VALID_FLOAT: lock( /^(-?\d+(\.\d+)?)$/ ),

            /**
             * Matches any character that is not in the set [0,1,2,3,4,5,6,7,8,9]
             */
            NON_INTEGER_DIGIT: lock( /\D/ ),

            /**
             * Matches any character that is not a numeric digit or decimal point
             */
            NON_DIGIT: lock( /[^\d.]/ ),

            /**
             * Matches a string that begins and ends with a double-quote character
             */
            DOUBLE_QUOTED_STRING: lock( /^"([^"]|[\\"])*"$/ ),

            /**
             * Matches a string that begins and ends with a single-quote character
             */
            SINGLE_QUOTED_STRING: lock( /^'([^']|[\\'])*'$/ ),

            /**
             * Matches a string that begins and ends with either a double-quote, single-quote, or back-tick character
             */
            QUOTED_STRING: lock( /^(?<quote>['"`])([^\1]|[\\\1])*\1$/ ),

            /**
             * Matches spaces at the start of a character sequence
             */
            LEFT_TRIM: lock( /^ +((\S+\s*)*)/ ),

            /**
             * Matches spaces at the end of a character sequence
             */
            RIGHT_TRIM: lock( /((\s*\S+)*) +$/ ),

            /**
             * Matches all whitespace at the start of a character sequence
             */
            LEFT_TRIM_WHITESPACE: lock( /^\s+((\S+\s*)*)/ ),

            /**
             * Matches all whitespace at the end of a character sequence
             */
            RIGHT_TRIM_WHITESPACE: lock( /((\s*\S+)*)\s+$/ ),

            /**
             * Matches repeated spaces anywhere in a character sequence
             */
            REDUNDANT_SPACE: lock( / {2,}/ ),

            /**
             * Matches repeated whitespace anywhere in a character sequence
             */
            REDUNDANT_WHITESPACE: lock( /[ \s]{2,}/ ),

            /**
             * Matches an opening parenthesis character anywhere in a string
             */
            OPEN_PAREN: lock( /\(/ ),

            /**
             * Matches a closing parenthesis character anywhere in a string
             */
            CLOSE_PAREN: lock( /\)/ ),

            /**
             * Matches an opening parenthesis character at the start of a string
             */
            START_OPEN_PAREN: lock( /^\(/ ),

            /**
             * Matches a closing parenthesis character at the end of a string
             */
            END_CLOSE_PAREN: lock( /\)$/ ),

            /**
             * Matches any of the characters that perform simple mathematics operations,
             * that is, addition, multiplication, division, or subtraction
             */
            MATHS_OPERATORS: lock( /[+*/-]/ ),

            /**
             * Matches a simple mathematics expression, such as '3 * 2' or ( 3 * 2 )
             */
            MATHS_EXPRESSION: lock( /(\(\s*(-?\d+(\.?\d+)?)\s*([+*/-])\s*(-?\d+(\.?\d+)?)\s*\))|(\s*(-?\d+(\.?\d+)?)\s*([+*/-])\s*(-?\d+(\.?\d+)?)\s*)|\s*(-?\d+(\.?\d+)?)\s*/ ),

            /**
             * Matches the literal question-mark character, '?' anywhere in a character string.
             * Useful for parsing URLs
             */
            QUERY_STRING_SEPARATOR: lock( /\?/ ),

            /**
             * Matches the literal question-mark character, '?' anywhere in a character string.
             * Useful when using a '?' character could be ambiguous in a regular expression
             */
            QUESTION_MARK: lock( /\?/ ),

            /**
             * Matches the literal hash, or pound, character, '#' anywhere in a character string.
             * Useful for parsing URLs
             */
            URL_LOCATION_HASH_SEPARATOR: lock( /#/ ),

            /**
             * Matches the literal hash, or pound, character, '#' anywhere in a character string.
             * A shorter alias for URL_LOCATION_HASH_SEPARATOR
             */
            HASH: lock( /#/ ),

            /**
             * Matches the literal hash, or pound, character, '#' at the start of a character string.
             * Useful for parsing hashtags
             */
            LEADING_HASH: lock( /^#/ ),

            /**
             * Matches a leading dot (extension separator)
             */
            LEADING_DOT: lock( /^\./ ),

            /**
             * Matches a trailing dot (an unexpected path suffix)
             */
            TRAILING_DOT: lock( /\.$/ ),

            /**
             * Matches a leading slash (path separator)
             */
            LEADING_SLASH: lock( /^\/+/ ),

            /**
             * Matches a trailing slash (path separator)
             */
            TRAILING_SLASH: lock( /\/+$/ ),

            /**
             * Matches text that may be produced from type coercion of undefined, null, or void types
             * Useful when parsing HTTP Requests in some environments
             */
            ARTIFACTS: lock( /null|undefined|void/i ),

            /**
             * Matches the file extension of a filename and captures it
             * More reliable than EXTENSION, but more complex to use
             */
            EXTENSION_MATCH: lock( /((((?<!\.)\.(?!\.))[^.]+)+$)/ ),

            /**
             * Matches a comment that appears to be the source file copyright statement.
             */
            COPYRIGHT_COMMENT: lock( /[^"'`]?(\/\s*[\s\S.]*?(@license)?[\s\S.]*(Copyright)+?[\s\S.]*(\d{4})+[\s\S.]*?(@ignore)?[\s\S.]*?\*\/)+[^"'`]?/s ),

            /**
             * Matches a function signature by
             * matching any text that starts with or without an open parenthesis,
             * followed by one or more whitespace characters
             * followed by either 'async function' or 'function'
             * followed by one or more whitespace characters,
             * followed by a legal function name (or not for anonymous functions),
             * followed by one or more whitespace characters
             * followed by an open parenthesis, which begins the parameter list
             * followed by one or more whitespaces,
             * followed by zero or more valid parameter names, which is a bit complicated, however...
             * a valid parameter list is a sequence of zero or more 'words' that start with either dollar sign, underscore, or an alphabetic character,
             * followed by zero or more characters that are either part of that set or a digit or a parameter separator, which is a comma
             * optionally followed by one last parameter that can begin with the spread operator which is 3 dots (and otherwise follows the same rules as previous parameters)
             * followed by one or more whitespaces,
             * followed by a closing parenthesis that is not immediately preceded by a comma
             *
             * Executing this regular expression with a valid string yields the following matches:
             * 0: the entire matched string
             * 1: the function declaration, potentially including the initial parenthesis if the function is an IIFE
             * 2: the function declaration, minus any opening parenthesis, regardless of whether the function is an IIFE
             * 3: the text, 'async' potentially preceded and/or followed by whitespace (useful for testing for asynchronous by trimming the match and comparing to the text, 'async')
             * 4:
             * 5: the name of the function or undefined (if the function is anonymous)
             * 6: the parameters list
             * 7 - n: artifacts of the necessary groupings used to perform negative look-behind or otherwise enforce that only the last parameter can use the spread operator
             *
             */
            FUNCTION_SIGNATURE: lock( /^(\(?\s*((async(\s+))?\s*function))\s*?([$_\w]+[$_\w]*)?\s*\((\s*(([$_\w]+[$_\w]*\s*,?)\s*)*(\.{3}([$_\w]+[$_\w]*\s*,?)*\s*)*)(?<!,\s*)\)/ ),

            /**
             * Matches specifically an asynchronous function signature, using the same rules as FUNCTION_SIGNATURE.
             * @see FUNCTION_SIGNATURE
             */
            ASYNC_FUNCTION_SIGNATURE: lock( /^(\(?\s*((async(\s+))\s*function))\s*?([$_\w]+[$_\w]*)?\s*\((\s*(([$_\w]+[$_\w]*\s*,?)\s*)*(\.{3}([$_\w]+[$_\w]*\s*,?)*\s*)*)(?<!,\s*)\)/ ),

            /**
             * Matches the start of a function signature, capturing the name of the function in the first group.
             */
            FUNCTION_NAME: lock( /function\s*([^( ]*\s*)\(/ ),

            /**
             * Matches the start of a function signature, capturing the named parameters in the first group.
             */
            FUNCTION_PARAMETERS: lock( /\(?\s*(async\s+)?\s*function\s*?([^(]*)\(([_ ),\w$]*)\)/ ),

            /**
             * Matches a special annotation indicating the start of a function body.
             * Useful if parsing source code
             */
            FUNCTION_BODY_START_HINT: lock( /(\/\*\+\s*function_body\s*:\s*start\s*\*\/)+/ ),

            /**
             * Matches a special annotation indicating the end of a function body.
             * Useful if parsing source code
             */
            FUNCTION_BODY_END_HINT: lock( /(\/\*\+\s*function_body\s*:\s*end\*\/)/ ),

            /**
             * Matches all text between the special annotations indicating the start and end of a function body.
             * Useful if parsing source code
             */
            ANNOTATED_FUNCTION_BODY: lock( /\/\*\+\s*function_body\s*:\s*start\s*\*\/(.*?)\/\*\+\s*function_body\s*:\s*end\s*\*\//is ),

            /**
             * Matches a special annotation indicating the start of a statement
             * that can be converted to an asynchronous function call.
             * Useful if parsing source code
             */
            AWAIT_HINT: lock( /\/\*+\+ *await *\*+\// ),

            /**
             * Matches a special annotation indicating the start of a function
             * that can be converted to an asynchronous function.
             * Useful if parsing source code
             */
            ASYNC_HINT: lock( /\/\*+\+ *async *\*+\// ),

            // /*+removable:start */
            REMOVABLE_BLOCK_START: lock( /\/\*+\+ *removable *: *start *\*+\//dgi ),

            // /*+removable:end */
            REMOVABLE_BLOCK_END: lock( /\/\*+\+ *removable *: *end *\*+\//dgi ),

            REMOVABLE_BLOCK: lock( /\/\*+\+ *removable *: *start *\*+\/(.*)\/\*+\+ *removable *: *end *\*+\//dgis ),

            /**
             * Matches a statement defining a module's dependencies.
             * Useful if parsing source code
             */
            DEPENDENCIES_DECLARATION: lock( /(const|let|var)\s+(dependencies)\s*=\s*([{\[])?\s*(((["'`])?\s*([\w_$]+)\s*?(["'`,:])?(["'`])?\s*([\w_$]+)\s*?(["'`,])?)*)\s*([}\]])/ ),

            /**
             * Matches the start of a function or async function declaration.
             * Useful if parsing source code
             */
            FUNCTION_DECLARATION: lock( /^\(*\s*(async\s+)?\s*function([^(]*)\(/ ),

            /**
             * Matches text corresponding to a variable declaration and assignment.
             * Useful if parsing source code, and injecting new variables
             */
            VARIABLE_DECLARATION: lock( /((const|let|var) +)([a-zA-Z_$]+[a-zA-Z0-9_$]*)+([ \s\n]*=[ \s\n]*)([^;\n]+)+?([;\n,])+?/ ),

            /**
             * Returns a string of flags ordered according to their position in the VALID_FLAGS array
             * @param pFlags one or more flags to filter and sort according to the values in VALID_FLAGS
             * @returns {string} an string of flags ordered according to their position in the VALID_FLAGS array
             */
            flags: function( ...pFlags )
            {
                return sortFlags( ...pFlags ).join( _mt_chr );
            },

            /**
             * Returns a new mutable instance of the RegExp (or RegExp pattern) specified
             * @param pRegExp {RegExp|string} a regular expression or the string key of a regular expression from this library
             * @param pFlags one or more flags to control the behavior of the RegExp returned
             * @returns {RegExp|*} a new mutable instance of the RegExp (or RegExp pattern) specified
             */
            clone: function( pRegExp, ...pFlags )
            {
                const signals = this.flags( ...pFlags );

                if ( isString( pRegExp ) )
                {
                    return this.get( pRegExp, ...(signals.split( _mt_chr )) );
                }

                if ( pRegExp instanceof RegExp )
                {
                    return signals ? new RegExp( pRegExp, signals ) : new RegExp( pRegExp );
                }

                throw new Error( "This method requires a regular expression or a string matching the name of a property of this object or that represents a regular expression pattern\nThe specified value, " + pRegExp + ", is not a valid argument." );
            },

            /**
             * Returns the string of flags used by the specified RegExp
             * @param pRegEx {RegExp|string} a RegExp object or a string defining a regular expression
             * @returns {string} the string of flags used by the specified RegExp
             */
            extractFlags: function( pRegEx )
            {
                let rx = pRegEx;

                if ( isString( pRegEx ) )
                {
                    const s = asString( pRegEx );
                    const index = s.lastIndexOf( _slash );
                    const arr = index >= 0 ? [].concat( asArray( s.slice( index + 1 ) || _mt_str ).map( e => asString( e ).split( _mt_chr ) ).flat() ).flat() : [];
                    return this.flags( ...arr );
                }

                if ( !isObject( rx ) || !(rx instanceof RegExp) )
                {
                    return _mt_str;
                }

                return asString( rx.flags );
            },

            /**
             * Returns a mutable RegExp object corresponding to the name specified.
             * Used when you need a mutable instance of the RegExp.
             * @param pName {string|RegExp} one of the property keys of this object or a regular expression literal
             * @param pFlags one or more flags to apply when using the return RegExp
             * @returns {RegExp} a mutable RegExp object corresponding to the name or expression specified.
             */
            get: function( pName, ...pFlags )
            {
                let signals = this.flags( ...pFlags );

                if ( isString( pName ) )
                {
                    if ( this.REGEX.test( pName ) || this.REGEX.test( _slash + pName + _slash ) )
                    {
                        let flags = this.extractFlags( pName );

                        if ( !isBlank( flags ) )
                        {
                            signals = this.flags( ...((signals + flags).split( _mt_chr )) );
                        }

                        let name = pName.replace( /\/+[gidsmyu]*$/, _mt_str );

                        const pattern = name.replace( this.LEADING_OR_TRAILING_SLASH, _mt_str ).replaceAll( this.get( this.BACKSLASH, FLAGS.GLOBAL ), "\\" );

                        return signals ? new RegExp( pattern, signals ) : new RegExp( pattern );
                    }

                    const rx = this[pName] || this[ucase( pName )];

                    if ( rx )
                    {
                        return this.clone( rx, signals );
                    }
                    else
                    {
                        throw new Error( "Regular Expression, " + pName + " is not defined" );
                    }
                }

                if ( isObject( pName ) && pName instanceof RegExp )
                {
                    return new RegExp( pName, signals );
                }

                throw new Error( "pName must be a string or regular expression" );
            },

            compose: function( ...pRegExp )
            {
                const flags = this.flags( ...(asArray( pRegExp ).map( e => this.get( e )?.flags )) );

                const arr = asArray( pRegExp ).map( e => asString( this.get( e ) ).replace( /^\//, _mt_str ).replace( /\/[gidsmyu]*$/, _mt_str ) );

                return new RegExp( arr.join( _mt_chr ), flags );
            },

            /**
             * Returns a RegExp after resetting its state (example, lastIndex = -1)
             * @param pRegExp {RegExp|string} the regular expression to reset
             * @param pResetFlags (optional) pass true to return a new RegExp with no flags
             * @returns {RegExp} a mutable RegExp with its state reset
             */
            reset: function( pRegExp, pResetFlags = false )
            {
                let rx = pRegExp;

                switch ( typeof pRegExp )
                {
                    case _str:
                        rx = this.get( pRegExp, (pResetFlags ? _mt_str : this.extractFlags( pRegExp )) );
                        break;

                    case _obj:
                        if ( pRegExp instanceof RegExp )
                        {
                            rx = pRegExp;

                            if ( Object.isFrozen( rx ) || pResetFlags )
                            {
                                rx = pResetFlags ? new RegExp( rx ) : this.get( rx, rx.flags );
                            }

                            break;
                        }
                        break;

                    case _fun:
                        try
                        {
                            rx = pRegExp();
                            if ( !isFunction( rx ) )
                            {
                                return this.reset( rx );
                            }
                        }
                        catch( ex )
                        {
                            throw new IllegalArgumentError( "Reset requires a valid string, regular expression, or a function that returns a string or regular expression\n" + ex.message );
                        }
                        break;

                    default:
                        throw new IllegalArgumentError( "Reset requires a valid string, regular expression, or a function that returns a string or regular expression" );
                }

                if ( rx instanceof RegExp )
                {
                    rx.lastIndex = -1;

                    if ( pResetFlags )
                    {
                        rx = this.clone( rx, _mt_str );
                    }
                }

                return rx;
            }
        } );

    const removeAll = function( pString, ...pSearch )
    {
        let s = asString( pString );

        const expressions = [].concat( varargs( ...pSearch ).filter( e => isString( e ) || isRegExp( e ) ) );

        for( let expression of expressions )
        {
            let rx = REGULAR_EXPRESSIONS.get( expression, FLAGS.GLOBAL );

            if ( rx instanceof RegExp )
            {
                s = s.replaceAll( rx, _mt_str );
            }
        }

        return s;
    };

    const isQuotedString = function( pString )
    {
        if ( !isString( pString ) )
        {
            return false;
        }

        let s = asString( pString );

        return REGULAR_EXPRESSIONS.QUOTED_STRING.test( s );
    };

    /**
     * Instances of this class make working with the exec method of RegExp more convenient.
     * RegExp exec returns 'matches', which is an Array-like object (or null, when there are no matches).
     * Extracting useful information from this object can be cumbersome.
     * This class aims to make it a little easier.
     */
    class MatchesHelper
    {
        #matches = [];

        constructor( pMatches )
        {
            this.#matches = pMatches || [];
        }

        get matches()
        {
            return this.#matches || [];
        }

        /**
         * Returns the string captured by the specified group
         * @param {number} pGroup
         * @returns {string}
         */
        getText( pGroup )
        {
            let matches = this.#matches || [];

            let idx = Math.max( 0, asInt( pGroup ) );

            if ( idx < matches.length )
            {
                return matches[idx];
            }

            return _mt_str;
        }

        /**
         * Returns the index of the start and end of the specified group,
         * if the RegExp used to call exec included the 'd' flag
         * @param {number} pGroup the capture group whose index you want to return
         * @returns {Array<number>} [startIndex, endIndex] of the specified group
         */
        getIndices( pGroup )
        {
            let matches = this.#matches || [];

            let indices = matches.indices || [matches.index];

            let grp = Math.max( 0, asInt( pGroup ) );

            if ( grp < indices.length )
            {
                return asArray( indices[grp] );
            }

            return [-1, 0];
        }
    }

    /**
     * Returns a new instance of MatchesHelper
     * populated with the return value of calling exec
     * on the specified RegExp with the specified string
     * @param pRegEx {RegExp|string} a Regular Expression object
     *                               or string corresponding to the property key of the REGULAR_EXPRESSIONS object
     *                               or a pattern that can be interpreted as a regular expression
     * @param pString {string} the string to pass to the RegExp exec method
     * @param pFlags one or more flags to include with the regular expression
     * @returns {MatchesHelper} a new instance of MatchesHelper populated with the return value of calling exec
     *                                                          on the specified RegExp with the specified string
     */
    MatchesHelper.execute = function( pRegEx, pString, ...pFlags )
    {
        const flags = [FLAGS.WITH_INDICES].concat( ...pFlags ).concat( isRegExp( pRegEx ) ? asString( pRegEx.flags, true ).split( _mt_chr ) : [] );

        const rx = REGULAR_EXPRESSIONS.get( pRegEx, ...flags );

        const s = asString( pString );

        const matches = rx.exec( s );

        return new MatchesHelper( matches );
    };

    let mod =
        {
            dependencies,
            FLAGS,
            VALID_FLAGS,
            cleanFlags: function( ...pFlags )
            {
                return sortFlags( ...pFlags ).join( _mt_chr );
            },
            REGULAR_EXPRESSIONS,
            removeAll,
            isQuotedString,
            classes:
                {
                    MatchesHelper
                },
            MatchesHelper
        };

    mod = modulePrototype.extend( mod );

    return mod.expose( mod, INTERNAL_NAME, (_ud !== typeof module ? module : mod) ) || mod;

}());
