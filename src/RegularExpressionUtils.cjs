const constants = require( "./Constants.cjs" );
const typeUtils = require( "./TypeUtils.cjs" );
const stringUtils = require( "./StringUtils.cjs" );
const arrayUtils = require( "./ArrayUtils.cjs" );

/**
 * Defines a string to represent the type, undefined
 */
const _ud = constants?._ud || "undefined";

/**
 * This function returns the host environment scope (Browser window, Node.js global, or Worker self)
 */
const $scope = constants?.$scope || function()
{
    return (_ud === typeof self ? ((_ud === typeof global) ? {} : (global || {})) : (self || {}));
};

/**
 * This immediately invoked function expression (IIFE)
 * defines and returns the Regular Expressions Utilities module
 */
(function exposeModule()
{
    const me = exposeModule;

    /**
     * Define a string key which is unlikely to collide with other libraries or properties.
     * We use this to store the module generated by this function in global scope.
     * We can avoid re-executing the rest of this function if the module is already defined.
     */
    const INTERNAL_NAME = "__BOCK__REGEX_UTILS__";

    /**
     * Checks to see if this module is already defines and available in the global scope
     * Returns the existing module instead of recreating it, if it is already present.
     */
    if ( $scope() && (null != $scope()[INTERNAL_NAME]) )
    {
        return $scope()[INTERNAL_NAME];
    }

    /**
     * An array of this module's dependencies
     * which are re-exported with this module,
     * so if you want to, you can just import the leaf module
     * and then use the other utilities as properties of that module
     */
    const dependencies =
        {
            constants,
            typeUtils,
            stringUtils,
            arrayUtils
        };

    /**
     * The following variable declarations are used
     * to help your IDE recognize shorthand usages of values imported into this scope
     */
    let _mt_str = constants._mt_str || "";
    let _mt_chr = constants._mt_chr || "";

    let _str = constants._str || "string";
    let _obj = constants._obj || "object";
    let _fun = constants._fun || "function";

    let _reg_ex_literal = constants._slash || "/";

    let isString = typeUtils.isString || function( s ) { return _str === typeof s; };
    let isObject = typeUtils.isObject || function( s ) { return _obj === typeof s; };

    let asString = stringUtils.asString;
    let asInt = stringUtils.asInt;

    let isBlank = stringUtils.isBlank;

    let lcase = stringUtils.lcase;
    let ucase = stringUtils.ucase;

    let asArray = arrayUtils.asArray;

    constants.importUtilities( me, ...dependencies );

    /**
     * Constants for regular expression flags
     */
    const FLAGS =
        {
            GLOBAL: "g",
            INSENSITIVE: "i",
            WITH_INDICES: "d",
            DOTALL: "s",
            MULTILINE: "m",
            STICKY: "y",
            UNICODE: "u"
        };

    const VALID_FLAGS = [FLAGS.GLOBAL, FLAGS.INSENSITIVE, FLAGS.WITH_INDICES, FLAGS.DOTALL, FLAGS.MULTILINE, FLAGS.STICKY, FLAGS.UNICODE];

    const getValidFlags = function( ...pFlags )
    {
        let flags = [].concat( asArray( pFlags ) );

        flags = flags.filter( e => isString( e ) );
        flags = flags.map( e => lcase( e.trim() ).split( _mt_chr ) ).flat();
        flags = flags.filter( e => e.length === 1 && VALID_FLAGS.includes( e ) );

        return flags;
    };

    const flagComparator = function( pFlagA, pFlagB )
    {
        const a = asString( pFlagA );
        const b = asString( pFlagB );

        let idxA = VALID_FLAGS.indexOf( a );
        let idxB = VALID_FLAGS.indexOf( b );

        let comp = idxA < idxB ? -1 : idxA > idxB ? 1 : 0;

        if ( 0 === comp )
        {
            comp = a < b ? -1 : a > b ? 1 : 0;
        }

        return comp;
    };

    const sortFlags = function( ...pFlags )
    {
        let flags = getValidFlags( ...pFlags );

        if ( flags && flags.length > 0 )
        {
            flags = [...(new Set( flags ))];

            flags = flags.sort( flagComparator );
        }

        return flags;
    };

    const REGULAR_EXPRESSIONS = Object.freeze(
        {
            // matches regular expression literal
            REGEX: Object.freeze( /^\/.+\/[gidsmyu]*$/ ),

            DOT: Object.freeze( /\./ ),
            DOUBLE_SLASH: Object.freeze( /\/\// ),
            LEADING_NEWLINE: Object.freeze( /^\n+/ ),
            TRAILING_NEWLINE: Object.freeze( /\n+$/ ),
            TRAILING_SEMICOLON: Object.freeze( /;+$|(;\n+)$/ ),
            LEADING_WHITESPACE: Object.freeze( /^\s+/ ),
            TRAILING_WHITESPACE: Object.freeze( /\s+$/ ),
            VARIABLE_TOKEN_START: Object.freeze( /^\$\{/ ),
            VARIABLE_TOKEN_END: Object.freeze( /}$/ ),
            SLASH: Object.freeze( /\// ),
            LEADING_OR_TRAILING_SLASH: Object.freeze( /^\/+|\/+$/ ),
            BACKSLASH: Object.freeze( /\\/ ),
            DOLLAR_SYMBOL: Object.freeze( /\$/ ),
            EXTENSION: Object.freeze( /\.\w+$/ ),
            ASSIGNMENT_OPERATOR: Object.freeze( /[=:]/ ),
            SEPARATOR: Object.freeze( /[,;]/ ),
            WINDOWS_NEWLINE: Object.freeze( /\r\n/ ),
            NEWLINE: Object.freeze( /\n/ ),
            REDUNDANT_NEWLINES: Object.freeze( /\n{2,}/ ),

            SIMPLE_FUNCTION_SIGNATURE: Object.freeze( /(function)\s*\(([^)]*)\)/ ),
            SIMPLE_ASYNC_FUNCTION_SIGNATURE: Object.freeze( /(async)\s*(function)\s*\(([^)]*)\)/ ),

            NON_INTEGER_DIGIT: Object.freeze( /\D/ ),
            NON_DIGIT: Object.freeze( /[^\d.]/ ),
            LEFT_TRIM: Object.freeze( /[ ]*((\S+\s*)*)/ ),
            RIGHT_TRIM: Object.freeze( /((\s*\S+)*)[ ]*/ ),
            LEFT_TRIM_WHITESPACE: Object.freeze( /\s*((\S+\s*)*)/ ),
            RIGHT_TRIM_WHITESPACE: Object.freeze( /((\s*\S+)*)\s*/ ),
            REDUNDANT_SPACES: Object.freeze( /[ ]{2,}/ ),

            QUERY_STRING_SEPARATOR: Object.freeze( /\?/ ),
            QUESTION_MARK: Object.freeze( /\?/ ),
            URL_LOCATION_HASH_SEPARATOR: Object.freeze( /#/ ),
            HASH: Object.freeze( /#/ ),
            LEADING_HASH: Object.freeze( /^#/ ),

            /**
             * This constant defines a regular expression that matches a leading dot (extension separator)
             */
            LEADING_DOT: Object.freeze( /^\./ ),

            /**
             * This constant defines a regular expression that matches a trailing dot (an unexpected path suffix)
             */
            TRAILING_DOT: Object.freeze( /\.$/ ),

            /**
             * This constant defines a regular expression that matches a leading slash (path separator)
             */
            LEADING_SLASH: Object.freeze( /^\/+/ ),

            /**
             * This constant defines a regular expression that matches a trailing slash (path separator)
             */
            TRAILING_SLASH: Object.freeze( /\/+$/ ),

            /**
             * This constant defines a regular expression that matches doubled slashes (path separators)
             */
            DOUBLE_SLASHES: Object.freeze( /\/\// ),

            /**
             * This constant defines a regular expression that matches linebreaks in files formatted on Windows (or DOS) operating systems
             */
            NON_UNIX_LINEBREAK: Object.freeze( /\r\n/ ),

            /**
             * This regular expression matches text that may be produced from type coercion of undefined, null, or void types
             */
            ARTIFACTS: Object.freeze( /null|undefined|void/i ),

            BACKSLASHES: Object.freeze( /\\/ ),

            EXTENSION_MATCH: Object.freeze( /((((?<!\.)\.(?!\.))[^.]+)+$)/ ),

            COPYRIGHT_COMMENT: Object.freeze( /[^"'`]?(\/\s*[\s\S.]*?(@license)+[\s\S.]*(Copyright)+?[\s\S.]*(\d{4})+[\s\S.]*?(@ignore)+?[\s\S.]*?\*\/)+[^"'`]?/s ),

            /**
             * matches any text that starts with or without an open parenthesis,
             * followed by one or more whitespace characters
             * followed by either 'async function' or 'function'
             * followed by one or more whitespace characters,
             * followed by a legal function name (or not),
             * followed by one or more whitespace characters
             * followed by an open parenthesis, which begins the parameter list
             * followed by one or more whitespaces,
             * followed by zero or more valid parameter names, which is a bit complicated, however...
             * a valid parameter list is a sequence of zero or more 'words' that start with either dollar sign, underscore, or an alphabetic character,
             * followed by zero or more characters that are either part of that set or a digit or a parameter separator, which is a comma
             * optionally followed by one last parameter that can begin with the spread operator which is 3 dots (and otherwise follows the same rules as previous parameters)
             * followed by one or more whitespaces,
             * followed by a closing parenthesis that is not immediately preceded by a comma
             *
             * executing this regular expression with a valid string yields the following matches:
             * 0: the entire matched string
             * 1: the function declaration, potentially including the initial parenthesis if the function is an IIFE
             * 2: the function declaration, minus any opening parenthesis, regardless of whether the function is an IIFE
             * 3: the text, 'async' potentially preceded and/or followed by whitespace (useful for testing for asynchronous by trimming the match and comparing to the text, 'async')
             * 4: the name of the function or undefined (if the function is anonymous)
             * 5: the parameters list
             * 6 - n: artifacts of the necessary groupings used to perform negative look-behind or otherwise enforce that only the last parameter can use the spread operator
             *
             */
            FUNCTION_SIGNATURE: Object.freeze( /^(\(?\s*((async\s+)?\s*function))\s*?([$_\w]+[$_\w\d]*)?\s*\((\s*(([$_\w]+[$_\w\d]*\s*,?)\s*)*(\.{3}([$_\w]+[$_\w\d]*\s*,?)*\s*)*)(?<!,\s*)\)/ ),

            ASYNC_FUNCTION_SIGNATURE: Object.freeze( /^(\(?\s*((async\s+)\s*function))\s*?([$_\w]+[$_\w\d]*)?\s*\((\s*(([$_\w]+[$_\w\d]*\s*,?)\s*)*(\.{3}([$_\w]+[$_\w\d]*\s*,?)*\s*)*)(?<!,\s*)\)/ ),

            FUNCTION_NAME: Object.freeze( /function([^(]*)\(/ ),

            FUNCTION_PARAMETERS: Object.freeze( /\(?\s*(async\s+)?\s*function\s*?([^(]*)\(([_ ),\w$]*)\)/ ),

            FUNCTION_BODY_START_HINT: Object.freeze( /\/\*\+\s*function_body\s*:\s*start\s*\*\// ),

            FUNCTION_BODY_END_HINT: Object.freeze( /\/\*\+\s*function_body\s*:\s*end\*\// ),

            ANNOTATED_FUNCTION_BODY: Object.freeze( /\/\*\+\s*function_body\s*:\s*start\s*\*\/(.*?)\/\*\+\s*function_body\s*:\s*end\s*\*\//is ),

            AWAIT_HINT: Object.freeze( /\/\*+\+[ ]*await[ ]*\*+\// ),

            ASYNC_HINT: Object.freeze( /\/\*+\+[ ]*async[ ]*\*+\// ),

            DEPENDENCIES_DECLARATION: Object.freeze( /const\s+dependencies\s*=\s*(([\[{])(["' ),\/_])*([\[{]))?/ ),

            FUNCTION_DECLARATION: Object.freeze( /^\(*\s*(async\s+)?\s*function([^(]*)\(/ ),

            VARIABLE_DECLARATION: Object.freeze( /((const|let|var) +)([a-zA-Z_$]+[a-zA-Z0-9_$]*)([ \s\n]*= [ \s\n]*)([^; \n]+)([ \s\n]* [; \n])([ \s\n]*(\/\/ *injected)*)*/ ),

            flags: function( ...pFlags )
            {
                return sortFlags( ...pFlags ).join( _mt_chr );
            },

            clone: function( pRegExp, ...pFlags )
            {
                const signals = this.flags( ...pFlags );

                if ( isString( pRegExp ) )
                {
                    return this.get( pRegExp, ...(signals.split( _mt_chr )) );
                }

                if ( pRegExp instanceof RegExp )
                {
                    return signals ? new RegExp( pRegExp, signals ) : new RegExp( pRegExp );
                }

                throw new Error( "This method requires a regular expression or a string matching the name of a property of this object or that represents a regular expression pattern\nThe specified value, " + pRegExp + ", is not a valid argument." );
            },

            extractFlags: function( pRegEx )
            {
                let rx = pRegEx;

                if ( isString( pRegEx ) )
                {
                    rx = new RegExp( pRegEx );
                }

                if ( !isObject( rx ) || !(rx instanceof RegExp) )
                {
                    return _mt_str;
                }

                return asString( rx.flags );
            },

            get: function( pName, ...pFlags )
            {
                let signals = this.flags( ...pFlags );

                if ( isString( pName ) )
                {
                    if ( this.REGEX.test( pName ) )
                    {
                        let flags = this.extractFlags( pName );

                        if ( !isBlank( flags ) )
                        {
                            signals = this.flags( ...((signals + flags).split( _mt_chr )) );
                        }

                        let name = pName.replace( /\/+[gidsmyu]*$/, _mt_str );

                        const pattern = name.replace( this.LEADING_OR_TRAILING_SLASH, _mt_str ).replace( this.BACKSLASH, "\\" );

                        return signals ? new RegExp( pattern, signals ) : new RegExp( pattern );
                    }

                    const rx = this[pName] || this[ucase( pName )];

                    if ( rx )
                    {
                        return this.clone( rx, signals );
                    }
                    else
                    {
                        throw new Error( "Regular Expression, " + pName + " is not defined" );
                    }
                }

                if ( isObject( pName ) && pName instanceof RegExp )
                {
                    return new RegExp( pName, signals );
                }

                throw new Error( "pName must be a string or regular expression" );
            },

            reset: function( pRegExp, pResetFlags )
            {
                let rx = pRegExp;

                switch ( typeof pRegExp )
                {
                    case _str:
                        rx = this.get( pRegExp );
                        break;

                    case _obj:
                        if ( pRegExp instanceof RegExp )
                        {
                            rx = pRegExp;
                            break;
                        }
                        break;

                    case _fun:
                        try
                        {
                            rx = pRegExp();
                            return this.reset( rx );
                        }
                        catch( ex )
                        {
                            throw new Error( "Reset requires a valid string, regular expression, or a function that returns a string or regular expression\n" + ex.message );
                        }

                    default:
                        throw new Error( "Reset requires a valid string, regular expression, or a function that returns a string or regular expression" );
                }

                if ( rx instanceof RegExp )
                {
                    rx.lastIndex = -1;

                    if ( pResetFlags )
                    {
                        rx = this.clone( rx, _mt_str );
                    }
                }

                return rx;
            }
        } );

    class MatchesHelper
    {
        #matches = [];

        constructor( pMatches )
        {
            this.#matches = pMatches || [];
        }

        get matches()
        {
            return this.#matches;
        }

        /**
         * Returns the string captured by the specified group
         * @param {number} pGroup
         * @returns {string}
         */
        getText( pGroup )
        {
            let matches = this.#matches || [];

            let idx = Math.max( 0, asInt( pGroup ) );

            if ( idx < matches.length )
            {
                return matches[idx];
            }

            return _mt_str;
        }

        /**
         *
         * @param {number} pGroup
         * @returns {(*|number)[]|*}
         */
        getIndex( pGroup )
        {
            let matches = this.#matches || [];

            let indices = matches.indices || [];

            let idx = Math.max( 0, asInt( pGroup ) );

            if ( idx < indices.length )
            {
                return indices[idx];
            }

            return -1;
        }
    }

    MatchesHelper.execute = function( pRegEx, pString, ...pFlags )
    {
        const rx = REGULAR_EXPRESSIONS.get( pRegEx, ...pFlags );

        const s = asString( pString );

        const matches = rx.exec( s );

        return new MatchesHelper( matches );
    };

    const mod =
        {
            dependencies,
            FLAGS,
            VALID_FLAGS,
            cleanFlags: function( ...pFlags )
            {
                return sortFlags( ...pFlags ).join( _mt_chr );
            },
            REGULAR_EXPRESSIONS,
            classes:
                {
                    MatchesHelper
                }
        };

    if ( _ud !== typeof module )
    {
        module.exports = Object.freeze( mod );
    }

    if ( $scope() )
    {
        $scope()[INTERNAL_NAME] = Object.freeze( mod );
    }

    return Object.freeze( mod );

}());
