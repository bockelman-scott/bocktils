// noinspection AssignmentToForLoopParameterJS

/**
 * @fileOverview
 * This module defines a number of useful functions for working with strings.
 * <br>
 * The primary motivation for this module is to provide null-safe versions
 * of functions that exist as methods of the JavaScript String class.
 * <br>
 * <br>
 * The most commonly used function is the asString function
 * that converts almost any value into a string,
 * so that it is then safe to call any existing String method on the result.
 * <br>
 * <br>
 * This module also exposes functions for converting numeric strings into numbers,
 * configuration values representing boolean options into boolean values,
 * and for preparing strings for use with C/C++ addons or WASM code.
 * <br>
 * <br>
 *
 * There are also functions to find duplicated substrings,<br>
 * interpolate strings that cannot be predefined as `template strings`,<br>
 * determine whether a string is valid JSON,<br>
 * and shorthand functions for performing multiple checks on the same string,<br>
 * such as includesAny, startsWithAny, endsWithAny, etc.<br>
 * which take a variable number of arguments for the search strings.
 * <br>
 *
 *
 * @module StringUtils
 *
 * @author Scott Bockelman
 * @license MIT
 *
 * */

/** import the base module we depend upon using require for maximum compatibility with Node versions */
const moduleUtils = require( "./_ToolBocksModule.cjs" );

/** import the Constants we depend upon using require for maximum compatibility with Node versions */
const constants = require( "./Constants.cjs" );

/** import the TypeUtils we depend upon using require for maximum compatibility with Node versions */
const typeUtils = require( "./TypeUtils.cjs" );

/**
 * Defines a string to represent the type, undefined
 */
const { _ud = "undefined", $scope } = constants;

// noinspection FunctionTooLongJS
/**
 * This immediately invoked function expression (IIFE)
 * defines and returns the StringUtils module
 */
(function exposeModule()
{
    /**
     * Define a string key which is unlikely to collide with other libraries or properties.
     * We use this to store the module generated by this function in global scope.
     * We can avoid re-executing the rest of this function if the module is already defined.
     */
    const INTERNAL_NAME = "__BOCK__STRING_UTILS__";

    /**
     * Checks to see if this module is already defines and available in the global scope
     * Returns the existing module instead of recreating it, if it is already present.
     */
    if ( $scope() && (null != $scope()[INTERNAL_NAME]) )
    {
        return $scope()[INTERNAL_NAME];
    }

    /**
     * An alias for the static String.fromCharCode method.
     *
     * @type {(...codes: number[]) => string}
     */
    const fromCode = String.fromCharCode;

    const {
        ModuleEvent,
        ToolBocksModule,
        IllegalArgumentError,
        ObjectEntry,
        objectEntries,
        functionToString,
        populateOptions,
        attempt,
        lock,
        runtimeLocaleString
    } = moduleUtils;

    const
        {
            _mt_str = "",
            _mt_chr = "",
            _mt = _mt_str,
            _dblqt,
            _sglqt,
            _spc,
            _dot,
            _comma,
            _hyphen,
            _apos,
            _underscore,
            _tilde = "~",
            _tab,
            _z,
            _unixPathSep,
            _unixPrevDir,
            _unixThisDir,
            _lf,
            _crlf,
            _colon,
            _slash,
            S_TRUE,
            S_FALSE,
            S_WARN = "warn",
            RESERVED_WORDS,
            _affirmatives,
            _str,
            _fun,
            _num,
            _big,
            _bool,
            _obj,
            _symbol,
            _zero,

            ENDIAN,

            BUILTIN_TYPES,
            ERROR_TYPES,

            _defaultLocaleString = "en-US",
            _defaultLocale,
            _defaultCurrency,
            DEFAULT_NUMBER_FORMATTING_SYMBOLS,

            _rxFunction = /^(async )*function/,
            _rxClass = /^class/,

        } = constants;

    /**
     * An array of this module's dependencies
     * which are re-exported with this module,
     * so if you want to, you can just import the leaf module
     * and then use the other utilities as properties of that module
     */
    const dependencies =
        {
            moduleUtils,
            constants,
            typeUtils
        };

    const
        {
            isUndefined,
            isNull,
            isPrimitiveWrapper,
            isDate,
            isString,
            isNumber,
            isNumeric,
            isScientificNotation,
            isBoolean,
            isObject,
            isNonNullObject,
            isPopulatedObject,
            isArray,
            isLikeArray,
            isTypedArray,
            isIterable,
            isMap,
            isSet,
            isFunction,
            isRegExp,
            isNanOrInfinite,
            isClass,
            getClass,
            getClassName,
            toDecimal,
            firstMatchingType,
            clamp,
            NVL,
            toTypedArray,
        } = typeUtils;

    const modName = "StringUtils";

    let toolBocksModule = new ToolBocksModule( modName, INTERNAL_NAME );

    const RX_NON_DIGITS = /\D/g;

    /**
     * These are the default values assumed for number formatting,
     * when calling methods such as asInt or asFloat
     * @type {Readonly<{decimal_point: string, currency_symbol: RegExp, grouping_separator: string}>}
     */
    const DEFAULT_NUMBER_SYMBOLS = DEFAULT_NUMBER_FORMATTING_SYMBOLS || lock(
        {
            decimal_point: ".",
            grouping_separator: ",",
            currency_symbol: /\$|USD/
        } );

    /**
     * This regular expression is used to determine if a string
     * is a valid JSON object or array
     */
    const _rxValidJson = /^([{\[])(.*)*([}\]])$/s;

    const AS_INT = "asInt";

    /**
     * When a function is added to a built-in object prototype,
     * the value does not need to be passed in, so we need to find it
     * @param pValue either a value or undefined when the value should be the value of 'this'
     * @returns {number | string} the value to use in the function
     * @private
     */
    function _resolveInput( pValue )
    {
        let input = pValue;

        if ( isUndefined( pValue ) )
        {
            if ( this instanceof Number || Number === this?.constructor || isNumber( this?.prototype ) )
            {
                input = (Number( this ).valueOf() || parseFloat( _mt_str + this )) || pValue;
            }
            else if ( this instanceof String || String === this?.constructor || isString( this?.prototype ) )
            {
                input = (String( this ).valueOf() || asString( _mt_str + this )) || pValue;
            }
            else if ( this instanceof Boolean || Boolean === this?.constructor || isBoolean( this?.prototype ) )
            {
                input = Boolean( this.valueOf() );
            }
            else if ( this[Symbol.toPrimitive] )
            {
                input = this[Symbol.toPrimitive]( "string" ) || pValue;
            }
        }

        return input || pValue;
    }

    /**
     * @typedef {Object} AsStringOptions
     *
     * @property {boolean} [omitFunctions=true]
     * @property {boolean} [executeFunctions=false]
     * @property {boolean} [returnFunctionSource=false]
     * @property {string} [joinOn=""]
     * @property {boolean} [removeLeadingZeroes=true]
     * @property {boolean} [assumeNumeric=false]
     * @property {boolean} [assumeAlphabetic=true]
     * @property {Object|function|null} [dateFormatter=null],
     * @property {Array.<function>} [transformations=[]]
     * @property {boolean} [checkForByteArray=false]
     * @property {object} [decoder]
     * @property {object} [encoder]
     *
     */

    /**
     * These are the default options for the {@link #asString} function.
     *
     * @type {AsStringOptions}
     * @constant DEFAULT_AS_STRING_OPTIONS
     *
     */
    const DEFAULT_AS_STRING_OPTIONS =
        lock( {
                  trim: false,
                  omitFunctions: true,
                  executeFunctions: false,
                  returnFunctionSource: false,
                  joinOn: _mt_chr,
                  removeLeadingZeroes: true,
                  assumeNumeric: false,
                  assumeAlphabetic: true,
                  dateFormatter: null,
                  transformations: [function( s ) { return s;}],
                  checkForByteArray: false,
                  decoder: null,
                  encoder: null,
              } );

    const _aso = ( pOptions ) => { return { ...DEFAULT_AS_STRING_OPTIONS, ...(pOptions || {}) }; };

    const isTransformer = ( e ) => (isFunction( e ) && e.length > 0) || (isNonNullObject( e ) && isFunction( e?.transform ));

    const resolveTransformer = ( e ) => isTransformer( e ) ? firstMatchingType( _fun, e.transform, e, ( s ) => s ) : ( s ) => s;

    /**
     * Invokes each function, or transformer's transform method,
     * on the specified string
     * and returns the resulting string.
     *
     * @param {string} pString the string to transform
     * @param {...(function|{transform:function(string)})} pTransformations one or more objects with a transform method
     *                                                                      or one or more functions
     *                                                                      that take a string
     *                                                                      and return a string
     * @returns {string} the transformed string
     */
    function applyTransformations( pString, ...pTransformations )
    {
        let s = (_mt_str + pString);

        let transformers = [...(pTransformations || [])];

        transformers = transformers.flat().filter( isTransformer );

        let prior = (_mt_str + s);

        for( let transformer of transformers )
        {
            if ( !transformer )
            {
                continue;
            }

            const transform = resolveTransformer( transformer );

            s = attempt( () => transform.call( transformer, s, prior ) ) || prior;

            prior = s || prior;
        }

        return s;
    }

    const _transform = ( pString, ...pTransformations ) => applyTransformations( pString, ...pTransformations );

    /**
     * Returns the source code that defined the specified function.
     * <br>
     * @param {function|string} pFunction - the function whose source is to be returned
     * @returns {string}  the source code that defined the specified function<br>
     *                    If the specified value is not a function,
     *                    returns that string or the empty string
     */
    function getFunctionSource( pFunction )
    {
        return isFunction( pFunction ) ? functionToString.call( pFunction, pFunction ) : isString( pFunction ) ? asString( pFunction, true ) : _mt_str;
    }

    /**
     * Converts the specified string into an array of bytes representing its characters.
     * <br>
     * Supports Unicode characters.
     *
     * @param {string} pStr - the string to convert into an array of bytes
     *
     * @returns {Array.<number>|TypedArray} an array of bytes representing the characters in the specified string
     */
    function asUtf8ByteArray( pStr )
    {
        const bytes = [];

        for( let i = 0, n = pStr.length; i < n; i++ )
        {
            let code = pStr.charCodeAt( i );

            if ( code < 0x80 )
            {
                bytes.push( code );
            }
            else if ( code < 0x800 )
            {
                bytes.push( (0xc0 | (code >> 6)), (0x80 | (code & 0x3f)) );
            }
            else if ( code < 0xd800 || code >= 0xe000 )
            {
                bytes.push( (0xe0 | (code >> 12)), (0x80 | ((code >> 6) & 0x3f)), (0x80 | (code & 0x3f)) );
            }
            else
            {
                i++;

                // UTF-16 encodes these using two code units.
                // The actual code point is calculated as follows:
                // ((charCode - 0xD800) << 10 | str.charCodeAt(i) - 0xDC00) + 0x10000
                code = 0x10000 + (((code & 0x3FF) << 10) | (pStr.charCodeAt( i ) & 0x3FF));
                bytes.push( (0xf0 | (code >> 18)), (0x80 | ((code >> 12) & 0x3f)), (0x80 | ((code >> 6) & 0x3f)), (0x80 | (code & 0x3f)) );
            }
        }

        return bytes;
    }

    /**
     * Returns the number of bytes expected in each element of the specified TypedArray
     * <br>
     * <br>
     *
     * @param {TypedArray} pByteArray An instance of a TypedArray or the TypedArray subclass itself
     *
     * @returns {number} the number of bytes expected in each element of the specified TypedArray
     */
    function bytesPerElement( pByteArray )
    {
        const byteArrayClass = getClass( pByteArray );
        return asInt( byteArrayClass?.BYTES_PER_ELEMENT, 0 ) || asInt( getClassName( byteArrayClass || pByteArray ).replaceAll( RX_NON_DIGITS, _mt_str ) ) / 8;
    }

    /**
     * Returns the specified encoder
     * or an instance of TextEncoder
     * if it is available and appropriate
     * for the TypedArray class specified
     * <br>
     * <br>
     * @param {TextEncoder|{encode:function(string)}} pTextEncoder the object to evaluate as a text encoder
     *
     * @param {function|object} pByteArrayClass the TypedArray class (or an instance of a TypedArray) for which the encoder is intended
     *
     * @returns {TextEncoder|*|{encode: (function(*): *)}|{encode: (function(string): *[])}} An object whose 'encode' method
     *                                                                                       can be used to convert text
     *                                                                                       to the bytes required by
     *                                                                                       the specified array
     */
    function resolveTextEncoder( pTextEncoder, pByteArrayClass )
    {
        const byteArrayClass = isClass( pByteArrayClass ) ? pByteArrayClass : getClass( pByteArrayClass );

        let encoder = isNonNullObject( pTextEncoder ) && isFunction( pTextEncoder.encode ) ? pTextEncoder : null;

        if ( isNull( encoder ) )
        {
            const bytes = bytesPerElement( byteArrayClass );

            switch ( bytes )
            {
                case 0:
                case 1:
                    return { encode: asUtf8ByteArray };

                default:
                    if ( _ud !== typeof TextEncoder )
                    {
                        return new TextEncoder();
                    }
                    return { encode: ( s ) => { return new byteArrayClass( asUtf8ByteArray( s ) ); } };
            }
        }

        return encoder;
    }

    /**
     * Returns an array of bytes representing the specified string,
     * or string representation of the specified value.
     * <br>
     * <br>
     * This method attempts to use the built-in TextEncoder if it is available,
     * but will fall back to an object that uses the asUtf8ByteArray function encode the string.
     * <br>
     * <br>
     *
     * @param {string|*} pString The string to convert to a byte array.<br>
     *                           If another type of value is specified,
     *                           it will be converted to a string, if possible,
     *                           and the resulting string will be converted
     *                           to a byte array and returned.
     *
     * @param {TextEncoder|{encode:function(string)}} pTextEncoder An object with an encode method to convert each character to one or more bytes
     *
     * @param {function|object} [pByteArrayClass=Uint8Array] The subclass of TypedArray to return
     *
     * @param {...(function|{transform:function(string)})} pTransformers one or more objects with a transform method
     *                                                                   or one or more functions
     *                                                                   that take a string
     *                                                                   and return a string
     *
     * @returns {TypedArray|Uint8Array}
     */
    const toByteArray = function( pString, pTextEncoder, pByteArrayClass = Uint8Array, ...pTransformers )
    {
        const byteArrayClass = isClass( pByteArrayClass ) ? pByteArrayClass || Uint8Array : Uint8Array;

        const encoder = resolveTextEncoder( pTextEncoder, byteArrayClass );

        const s = applyTransformations( asString( pString ), ...pTransformers );

        if ( byteArrayClass && encoder && isFunction( encoder?.encode ) )
        {
            return new byteArrayClass( encoder.encode( s ) );
        }

        return asUtf8ByteArray( s );
    };

    /**
     * Converts the specified array of bytes into a string, if possible
     * <br>
     *
     * @param {Array.<number>|TypedArray|Uint8Array} pBytes An array of bytes representing text characters.
     *                                                      May include Unicode characters.
     *
     * @returns {string} The string represented by the bytes provided
     */
    function fromUtf8ByteArray( pBytes )
    {
        let s = _mt_str;

        let bytes = isArray( pBytes ) || isTypedArray( pBytes ) || isIterable( pBytes ) ? [...(pBytes || [])] : [pBytes];
        bytes = bytes.flat();

        for( let i = 0, n = bytes.length; i < n; i++ )
        {
            let byte = bytes[i];

            if ( (byte & 0x80) === 0x00 )
            {
                // 1-byte character
                s += fromCode( byte );
            }
            else if ( (byte & 0xe0) === 0xc0 )
            {
                // 2-byte character
                s += fromCode( ((byte & 0x1f) << 6) | (pBytes[++i] & 0x3f) );
            }
            else if ( (byte & 0xf0) === 0xe0 )
            {
                // 3-byte character
                s += fromCode( ((byte & 0x0f) << 12) | ((pBytes[++i] & 0x3f) << 6) | (pBytes[++i] & 0x3f) );
            }
            else if ( (byte & 0xf8) === 0xf0 )
            {
                // 4-byte character (surrogate pair)
                let codePoint = ((byte & 0x07) << 18) | ((pBytes[++i] & 0x3f) << 12) | ((pBytes[++i] & 0x3f) << 6) | (pBytes[++i] & 0x3f);
                codePoint -= 0x10000;
                s += fromCode( 0xD800 + (codePoint >> 10) );
                s += fromCode( 0xDC00 + (codePoint & 0x3FF) );
            }
        }

        return s;
    }

    /**
     * Converts the specified TypedArray into a Uint8Array.
     *
     * @param {TypedArray||Array.<number>} pTypedArray The array to convert
     *
     * @param {string} pEndianness Indicates the endianness to use when writing the bytes; can be ENDIAN.BIG or ENDIAN.LITTLE
     *
     * @returns {Uint8Array} an instance of Uint8Array populated with the bytes found in the specified array,
     *                       splitting or truncating values that would otherwise overflow
     */
    function _toUint8Array( pTypedArray, pEndianness = ENDIAN.LITTLE )
    {
        if ( isNull( pTypedArray ) )
        {
            return new Uint8Array( 0 );
        }

        let typedArray = toTypedArray( pTypedArray );

        if ( typedArray instanceof Uint8Array )
        {
            return typedArray;
        }

        let uint8Array;

        const length = typedArray.length;

        const bytes = bytesPerElement( typedArray );

        uint8Array = new Uint8Array( length * bytes );

        if ( bytes <= 1 )
        {
            for( let i = 0; i < length; i++ )
            {
                uint8Array[i] = clamp( typedArray[i], 0, 255 );
            }
            return uint8Array;
        }

        if ( bytes >= 8 )
        {
            const isLittleEndian = isBlank( asString( pEndianness, true ) ) || "little" === lcase( asString( pEndianness, true ) );

            const view = new DataView( uint8Array.buffer );  // Use DataView for 64-bit

            for( let i = 0; i < length; i++ )
            {
                view.setFloat64( i * 8, typedArray[i], isLittleEndian ); // Little-endian (adjust if needed)
            }

            return uint8Array;
        }

        for( let i = 0; i < length; i++ )
        {
            for( let j = 0; j < bytes; j++ )
            {
                let rightShift = j * 8;
                uint8Array[i * 2 + j] = rightShift > 0 ? ((typedArray[i] >> rightShift) & 0xFF) : (typedArray[i] & 0xFF);
            }
        }

        return uint8Array;
    }

    /**
     * Returns the specified decoder
     * or an instance of TextDecoder
     * if it is available and appropriate
     * for the TypedArray class specified
     * <br>
     * <br>
     * @param {TextDecoder|{decode:function(string)}} pTextDecoder the object to evaluate as a text decoder
     *
     * @param {function|object} pByteArrayClass the TypedArray class (or an instance of a TypedArray)
     *                                          for which the decoder is intended
     *
     * @returns {TextEncoder|*|{decode: (function(*): *)}|{decode: (function(string): *[])}} An object whose 'decode' method
     *                                                                                       can be used to convert an array of bytes
     *                                                                                       to a string
     */
    function resolveTextDecoder( pTextDecoder, pByteArrayClass )
    {
        const byteArrayClass = isClass( pByteArrayClass ) ? pByteArrayClass : getClass( pByteArrayClass );

        let decoder = isNonNullObject( pTextDecoder ) && isFunction( pTextDecoder.decode ) ? pTextDecoder : null;

        if ( isNull( decoder ) )
        {
            const bytes = bytesPerElement( byteArrayClass );

            switch ( bytes )
            {
                case 0:
                case 1:
                    return { decode: fromUtf8ByteArray };

                default:
                    if ( _ud !== typeof TextDecoder )
                    {
                        return new TextDecoder();
                    }
                    return { decode: ( pArray ) => { return fromUtf8ByteArray( _toUint8Array( pArray ) ); } };
            }
        }
    }

    /**
     * Returns the string represented by the bytes in the specified array.
     * <br>
     * <br>
     *
     * @param {TypedArray|Array.<number>} pByteArray the array of bytes to convert into a string
     *
     * @param {TextDecoder|{decode:function}} pTextDecoder An object with a decode method to convert the bytes into characters
     *
     * @param {...(function|{transform:function(string)})} pTransformers one or more objects with a transform method
     *                                                     or one or more functions
     *                                                     that take a string and return a string
     *
     *
     * @returns {string} the string represented by the bytes in the specified array
     */
    const fromByteArray = function( pByteArray, pTextDecoder, ...pTransformers )
    {
        let array = isTypedArray( pByteArray ) || (isArray( pByteArray ) && pByteArray.every( e => isNumeric( e ) && toDecimal( e ) <= 255 ));

        let byteArrayClass = getClass( pByteArray ) || (array ? Uint8Array : pByteArray);

        const decoder = resolveTextDecoder( pTextDecoder, byteArrayClass );

        let s = decoder.decode( pByteArray );

        s = applyTransformations( s, ...pTransformers );

        return s;
    };


    //// AS STRING HELPERS ////

    function _handleFunctionInput( pValue, pTrim, pOptions )
    {
        const options = _aso( pOptions );

        if ( options.omitFunctions )
        {
            return _mt_str;
        }

        const input = _resolveInput.call( this, pValue ) || pValue;

        let result = options.executeFunctions ? _attemptInvocation( input, options ) || _mt_str : _mt_str;

        if ( isBlank( result ) )
        {
            result = (options.returnFunctionSource ? getFunctionSource( input ) : _mt_str) ||
                     input?.name ||
                     input?.constructor?.name ||
                     input?.prototype?.name ||
                     _mt_str;
        }

        result = asString( result, pTrim, options );

        if ( isBlank( result ) )
        {
            result = _getClassOrFunctionNameFromSource( result, options );
        }

        return result;
    }

    function _attemptInvocation( pFunction, pOptions )
    {
        const options = _aso( pOptions );

        if ( isFunction( pFunction ) )
        {
            return attempt( () => pFunction.call( options?.this || options, options ), options ) ||
                   getFunctionName( pFunction, options );
        }
    }

    /**
     * Returns the name of the function specified, if it is not anonymous
     *
     * @param {function|string} pFunction The function or source code of the function whose name is to be returned
     *
     * @param {object} pOptions An object with properties defining what to do if no name is available
     *
     * @returns {string}
     */
    function getFunctionName( pFunction, pOptions )
    {
        const options = _aso( pOptions );

        if ( isFunction( pFunction ) )
        {
            return pFunction?.name ||
                   pFunction?.constructor?.name ||
                   (options.returnFunctionSource ?
                    getFunctionSource( pFunction ) :
                    _getClassOrFunctionNameFromSource( getFunctionSource( pFunction ), options ));
        }

        if ( isString( pFunction ) )
        {
            return _getClassOrFunctionNameFromSource( pFunction, options );
        }

        return _mt_str;
    }

    function _getClassOrFunctionNameFromSource( pValue, pOptions )
    {
        const options = _aso( pOptions );

        if ( isFunction( pValue ) )
        {
            return getFunctionName( pValue, options );
        }

        const regExp = _rxClass.test( pValue ) ? _rxClass : _rxFunction;

        if ( regExp.test( pValue ) )
        {
            let value = asString( pValue.replace( regExp, _mt_str ), true, options );

            let indices = [value.indexOf( _spc ), value.indexOf( "{" )].filter( e => e > 1 );

            let results = indices.map( e => value.slice( 0, e ) );

            if ( results.length > 0 )
            {
                return results.shift();
            }
        }

        return pValue;
    }

    function _handlePrimitiveWrapperInput( pValue, pTrim, pOptions )
    {
        let input = _resolveInput.call( pValue, pValue ) || pValue;

        if ( input instanceof Boolean )
        {
            return input.valueOf() ? S_TRUE : S_FALSE;
        }

        const options = _aso( pOptions );
        const trim = pTrim || options.trim;

        if ( input instanceof Number || input instanceof BigInt )
        {
            return asString( toDecimal( input.valueOf() ), trim, options );
        }

        if ( input instanceof String )
        {
            return asString( input.valueOf(), trim, options );
        }

        return (isFunction( input?.valueOf ) ? asString( input.valueOf(), trim, options ) : (isFunction( input?.toString ) ? asString( input.toString(), trim, options ) : _mt_str));
    }

    function _handleDateInput( pValue, pTrim, pOptions )
    {
        const options = _aso( pOptions );

        let input = new Date( _resolveInput.call( pValue, pValue ) || pValue );

        let s = input.toISOString();

        const formatter = isFunction( options?.dateFormatter?.format ) ? options?.dateFormatter?.format : options?.dateFormatter;

        if ( isFunction( formatter ) )
        {
            const thiz = options?.dateFormatter || $scope();

            const date = input || pValue;

            s = attempt( () => formatter.call( thiz, date, options ), options ) || date.toISOString() || s;
        }

        return s;
    }

    function _handleToStringMethod( pValue, pTrim, pOptions )
    {
        const options = _aso( pOptions );
        const trim = pTrim || options.trim;

        const me = toolBocksModule || exposeModule || asString;

        const input = _resolveInput.call( pValue, pValue ) || pValue;

        if ( isNull( input ) )
        {
            return _mt_str;
        }

        let s = input.toString();

        function isGenericObjectString( pStr )
        {
            const value = pStr || s;

            return "[object object]" === lcase( value ) || "Object" === value || isBlank( value );
        }

        if ( isGenericObjectString( s ) )
        {
            s = input?.name || input?.constructor?.name || input?.prototype?.name || _mt_str;

            // noinspection JSUnresolvedReference
            if ( isGenericObjectString( s ) )
            {
                // this is a bit of a hack, but if the JsonUtils are also loaded,
                // we want to use the asJson function, which can handle circular references
                let stringify = firstMatchingType( _fun, me.asJson, me.stringify, ($scope()["__BOCK_JSON_UTILS__"] || $scope()["__BOCK_JSON_INTERPOLATION__"])?.asJson, $scope().asJson, JSON.stringify );

                // noinspection JSUnresolvedReference
                s = isFunction( input?.toJson ) ? input.toJson() : attempt( () => stringify.call( me, input, options ), input, options ) || input?.name || input?.constructor?.name || input?.prototype?.name || _mt_str;
            }
        }

        s = isGenericObjectString( s ) ? "{}" : s;

        return trim ? (_mt_str + (s || _mt_str)).trim() : s;
    }

    function _handleObjectMethods( pValue, pTrim, pOptions )
    {
        let s = _mt_str;

        let input = pValue || pOptions?.value || {};

        if ( isNonNullObject( input ) )
        {
            if ( isFunction( input?.asString ) )
            {
                s = attempt( () => input.asString() );
            }
            else if ( isFunction( input?.toJSON ) )
            {
                s = attempt( () => input.toJSON() );
            }
            else if ( isFunction( input?.toJson ) )
            {
                s = attempt( () => input.toJson() );
            }
        }

        if ( !!(pTrim || pOptions?.trim) )
        {
            s = (_mt_str + s).trim();
        }

        return s;
    }

    function _handleMapToString( pMap )
    {
        if ( isMap( pMap ) )
        {
            const entries = objectEntries( pMap );

            if ( isNonNullObject( entries ) && isFunction( entries.forEach ) )
            {
                let numKeys = 0;

                let s = "{";

                entries.forEach( entry =>
                                 {
                                     const key = ObjectEntry.getKey( entry );
                                     const value = ObjectEntry.getValue( entry );

                                     s += "\"" + asString( key, true ) + "\": \"" + asString( value, true ) + "\",\n";

                                     numKeys += 1;
                                 } );

                s = numKeys > 0 ? s.slice( -2 ) : s; // remove last comma + newline sequence

                s += "}";

                return s.trim();
            }
        }

        return _mt_str;
    }

    function _handleArrayInput( pInput, pOptions )
    {
        const arr = [...(pInput || [])];

        let s = _mt_str;

        if ( pOptions.checkForByteArray && arr.every( e => isNumeric( e ) && toDecimal( e ) ) <= 255 )
        {
            s = fromUtf8ByteArray( arr.map( e => toDecimal( e ) ) );
        }
        else
        {
            s = arr.map( e => asString( e, pOptions?.trim, pOptions ) ).join( (asString( pOptions.joinOn ) || _mt_chr) );
        }

        return pOptions?.trim ? (_mt_str + s).trim() : s;
    }

    function _handleObjectInput( pValue, pTrim, pOptions )
    {
        if ( isNull( pValue ) )
        {
            return _mt_str;
        }

        const options = _aso( pOptions ) || {};

        const trim = !!(pTrim || options.trim);

        const input = pValue || options?.value;

        if ( isTypedArray( input ) )
        {
            return fromByteArray( input, options?.decoder, options?.transformations );
        }

        let s = _mt_str;

        // if the argument is an array, recursively call this function on each element
        // and join the results on the joinOn option or the empty character
        if ( isArray( input ) )
        {
            return _handleArrayInput( input, options, s, trim );
        }

        // handle ObjectWrapper types
        if ( isPrimitiveWrapper( input ) )
        {
            return _handlePrimitiveWrapperInput( input, trim, options );
        }

        // handle Dates by converting to the normal local string representation
        // unless a date formatter has been supplied
        if ( input instanceof Date )
        {
            return _handleDateInput( input, trim, options );
        }

        // convert RegExp to their normal string representation
        if ( input instanceof RegExp )
        {
            return input.toString();
        }

        if ( isMap( input ) )
        {
            let s = attempt( () => _handleMapToString( input ) );
            if ( s !== _mt_str )
            {
                return s;
            }
        }

        // if the object defines a variation of the toString method, we try those
        if ( isFunction( input?.toString ) )
        {
            return attempt( () => _handleToStringMethod( input, trim, options ) );
        }
        else
        {
            return attempt( () => _handleObjectMethods( input, trim, options ) ) || Object.toString.call( input, input );
        }
    }

    function _handleNumericString( pInput, pOptions )
    {
        const options = _aso( pOptions );

        let value = String( isNumber( pInput ) || isNumeric( pInput ) ? String( _mt_str + pInput ) : pInput ).trim();

        if ( isScientificNotation( value ) )
        {
            return String( toDecimal( value, options ) );
        }

        value = value.replace( /\D+$/g, _mt_str ).trim();

        return String( toDecimal( value, options ) );
    }

    function _asStringFromType( pIn, pTrim, pOptions )
    {
        let s;

        // return a value based on the type pf the argument
        switch ( typeof pIn )
        {
            case _str:
                s = pTrim ? (_mt_str + pIn).trim() : pIn;

                if ( pOptions.assumeNumeric )
                {
                    if ( isNumeric( pIn ) )
                    {
                        s = (_mt_str + _handleNumericString( pIn, pOptions ));
                    }
                    s = pIn.replaceAll( /[^\d,.-]/g, _mt_str );
                    s = (_mt_str + _handleNumericString( s, pOptions ));
                }
                break;

            // numeric values are converted to the string representation of their float value
            case _num:
            case _big:
                s = _handleNumericString( pIn, pOptions ) || _zero;
                break;

            // booleans are converted to either the string "true" or the string "false"
            case _bool:
                s = pIn ? S_TRUE : S_FALSE;
                break;

            // objects are a special case...
            case _obj:
                s = _handleObjectInput( pIn, pTrim, pOptions );
                break;

            case _fun:
                s = _handleFunctionInput( pIn, pTrim, pOptions );
                break;

            default:
                s = _mt_str;
                break;
        }

        return s;
    }

    /**
     * Returns a string representation of the argument passed,<br>
     * optionally removing leading and trailing whitespace<br>
     * and performing other transformations as specified in the options.<br>
     *
     * @param {*} pStr - Any valid type for which a string representation is desired
     *
     * @param {boolean} [pTrim=false] - Pass true to return a string with leading and trailing whitespace removed.<br />
     *
     * @param {AsStringOptions} pOptions An object specifying how to handle special circumstances,<br>
     * such as functions, arrays, and objects, as well as additional transformations to perform (such as to lowercase, etc.)<br>
     *
     * @returns {string} a string representation of the argument<br>
     *                   if the argument is already a string, returns a new copy of the string
     *                   if the argument is a number or big integer,
     *                                      attempts to parse the number as a float
     *                                      and then return a string representation of the resulting value
     *                   if the argument is an object,
     *                                   if the object is an Array, joins the asString( value ) of each element
     *                                   if the object is one of the built-in JavaScript types,
     *                                      returns asString called on its canonical string representation
     *                                   if the object defines a toJson method, returns the result of calling that method on the object
     *                                   otherwise, attempts to call JSON.stringify passing the object as the argument
     *                  if the argument is a function, attempts to execute that function and return its result(s) as a string
     *                  in all other cases, returns an empty string
     *
     *                  if this function is called with 2 arguments and the second argument is truthy,
     *                  the returned value will be trimmed (leading and trailing whitespace is removed)
     */
    const asString = function( pStr, pTrim = false, pOptions = DEFAULT_AS_STRING_OPTIONS )
    {
        const options = _aso( pOptions );

        let trim = !!(pTrim || options.trim);
        options.trim = trim;

        let input = _resolveInput.call( this, pStr );

        if ( _ud === typeof input || null === input )
        {
            return _mt_str;
        }

        let s = _asStringFromType( input, trim, options, pTrim );

        // if the string is the null-terminator (perhaps the string came from a C-API)
        if ( _z === s )
        {
            return _mt_str;
        }

        s = s.replace( _z, _mt_str );

        const transformations = ([].concat( ...(options?.transformations || []) )).flat().filter( isTransformer );

        return _transform( _mt_str + ((true === trim) ? ((_mt_str + s).trim()) : s), ...transformations );
    };

    const _toStr = asString;

    // add the asString function as a method of String, Number, and Boolean primitive wrappers
    String.prototype.asString = asString;
    Number.prototype.asString = asString;
    Boolean.prototype.asString = asString;

    /**
     * Returns a C-language compatible string
     * by converting the JavaScript String to a C-style String (8 byte chunks, null-terminated)
     * This is necessary when interacting with some C/C++ addons.
     */
    const toCString = function( pString )
    {
        let s = asString( pString );

        if ( _ud !== typeof Buffer )
        {
            return Buffer.from( `${s}\0`, "ucs2" );
        }

        const bytes = new Uint8Array( (s.length * 2) + 1 ); // 2 bytes per code unit, plus one for the null terminator

        for( let i = 0; i < s.length; i++ )
        {
            const charCode = s.charCodeAt( i );
            bytes[i * 2] = charCode & 0xFF; // Low byte
            bytes[i * 2 + 1] = (charCode >> 8) & 0xFF; // High byte
        }

        // add the null terminator
        bytes[bytes.length - 1] = _z;

        return bytes;
    };

    /**
     *  Returns a Javascript-compatible string by converting a C-style string into a JavaScript String,
     *  removing null-terminators, for example
     *
     * @param pCString a string (or buffer) believed to be a string in a C-language compatible format
     * @param pLen the length of the string
     * @returns {string} a JavaScript string
     */
    const fromCString = function( pCString, pLen = -1 )
    {
        let buffer = null;

        if ( _ud !== typeof Buffer )
        {
            buffer = Buffer.from( pCString, "ucs2" );
        }

        // noinspection JSCheckFunctionSignatures
        let s = (buffer && isFunction( buffer.toString )) ? buffer.toString() : isArray( pCString ) || isTypedArray( pCString ) ? fromByteArray( pCString ) : asString( pCString );

        // remove the null terminators;
        // Unicode characters may occupy either one or 2 bytes,
        // ordinary ascii string will have _z between each character
        if ( s )
        {
            let chars = s.split( _mt_chr );
            chars = chars.filter( ( c, i ) => (s.charCodeAt( i ) > 0 ? c : _mt_chr) );
            s = chars.join( _mt_chr );
        }

        // if the desired length is known ahead of time, we can also slice the returned (and scrubbed) value
        if ( pLen > 0 )
        {
            s = s.slice( 0, pLen );
        }

        // double-check we have no dangling null-terminators
        while ( s.endsWith( _z ) )
        {
            s = s.replace( /\u0000+$/g, _mt_str );
        }

        // return our glorious JavaScript-compatible character sequence
        return s;
    };

    /**
     * Returns true if the string contains interpolatable variables
     *
     * @param pMsg
     * @returns {*|boolean}
     * @private
     */
    const _containsPlaceholders = ( pMsg ) => /\{\d+}/.test( pMsg );

    /**
     * Returns a string that contains typical java-like message format placeholders, such as {0}. {1}, etc.
     * with those placeholders replaced by the corresponding elements of the provided array of values
     * @param pMsg a string potentially containing indexed placeholders, such as {0}
     * @param pData an array of values to use when replacing the indexed placeholders
     * @returns {string} a string with placeholders replaced with corresponding elements of the pData array
     * @private
     */
    const _replaceIndexPlaceholders = function( pMsg, ...pData )
    {
        let msg = asString( pMsg, false );

        if ( _containsPlaceholders( msg ) )
        {
            const substitutions = isArray( pData ) ? pData : [pData];

            msg = msg.replace( /\{\d+}/g, match => substitutions[asInt( match.slice( 1, -1 ) )] );
        }

        return msg;
    };

    /**
     * Returns a string with placeholders populated from the second, third, fourth, ... nth arguments
     * @param pMsg a string potentially containing indexed placeholders, such as {0} or {1}
     * @param pData one or more values to use to replace placeholders, the first of these will replace {0}, the second of these will replace {1}, and so on
     * @returns {string} a string with placeholders replaced with the corresponding value specified
     */
    const formatMessage = function( pMsg, ...pData )
    {
        return _replaceIndexPlaceholders( asString( pMsg, false ), ...pData );
    };

    function hasUnresolvedVariables( pString )
    {
        return pString.includes( "${" ) && pString.includes( "}" ) && (/\$\{\w+}/.test( pString ));
    }

    /**
     * Returns a string with variables replaced with values found in the specified scope
     * @param pStr a string potentially containing variable tokens, such as ${myVariableName}
     * @param pVariablesMap an object (or scope) defining the variables contained in the string
     *
     * NOTE:  This is equivalent to using template strings `such as ${this}`,
     * but allows the scope to be specified
     *
     * @returns {string} a string with variable tokens replaced by values in the specified map or scope
     */
    const interpolate = function( pStr, pVariablesMap = { ...$scope() } )
    {
        let str = asString( pStr, false );

        if ( hasUnresolvedVariables( str ) )
        {
            let variables = {};

            Object.assign( variables, pVariablesMap || $scope() );

            let entries = (pVariablesMap instanceof Map) ? pVariablesMap.entries() : (_obj === typeof pVariablesMap) ? Object.entries( pVariablesMap ) : [["", ""]];

            for( let [key, value] of entries )
            {
                const k = asString( key, true );

                if ( !isBlank( k ) && !(_ud === typeof value || null === value || _fun === typeof value || _symbol === typeof value || ["global", "this", "self", "window"].includes( k )) )
                {
                    variables[key] = value;
                }
            }

            for( let entry of Object.entries( variables ) )
            {
                str = str.replaceAll( new RegExp( "\\$\\{" + entry[0] + "\\}", "g" ), asString( entry[1], false ) );

                if ( !hasUnresolvedVariables( str ) )
                {
                    break;
                }
            }
        }

        return asString( str, false );
    };

    const DEFAULT_VALID_IDENTIFIER_OPTIONS =
        {
            defaultIdentifier: _underscore
        };

    function _replaceInvalidIdentifier( pStr, pOptions )
    {
        if ( isBlank( pStr ) || RESERVED_WORDS.includes( pStr ) )
        {
            return pOptions?.defaultIdentifier || _underscore;
        }
        return pStr;
    }

    /**
     * Returns a string that is a valid JavaScript identifier.
     * @see https://developer.mozilla.org/en-US/docs/Glossary/Identifier
     *
     * @param {*} pStr a value to be used as a variable or property name
     * @param pOptions an object to specify how to handle unusual cases
     */
    const validIdentifier = function( pStr, pOptions = DEFAULT_VALID_IDENTIFIER_OPTIONS )
    {
        const options = { ...DEFAULT_VALID_IDENTIFIER_OPTIONS, ...(pOptions || {}) };

        let s = _replaceInvalidIdentifier( asString( pStr, true ).trim(), options );

        let chars = s.split( _mt_chr );

        while ( chars.length && !(/[A-Za-z$_]/.test( chars[0] )) )
        {
            chars.shift();
        }

        s = chars.join( _mt_chr );

        s = s.replaceAll( /[^A-Za-z$_]/g, _mt_str );

        return _replaceInvalidIdentifier( asString( s, true ), options );
    };

    const DEFAULT_AS_KEY_OPTIONS = { supportDotNotation: false, defaultIdentifier: _underscore };

    /**
     * Returns a string that can be used as a key in a map or map-like structure, such as an object literal
     * Note that just about any string can be a key and that integers can be used as keys (that is in fact, part of how Array is implemented)
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_Types#object_literals
     *
     * @param {*} pStr
     * @param {Object} pOptions
     */
    const asKey = function( pStr, pOptions = DEFAULT_AS_KEY_OPTIONS )
    {
        const options = { ...DEFAULT_AS_KEY_OPTIONS, ...(pOptions || {}) };

        let s = _replaceInvalidIdentifier( asString( pStr, true ), options );

        const validName = validIdentifier( s, options );

        if ( s === validName )
        {
            return s;
        }

        if ( s.includes( _dot ) && options.supportDotNotation )
        {
            let keys = s.split( _dot );

            keys = keys.map( e => (asKey( e )) );

            s = keys.join( _dot );

            return _dblqt + s + _dblqt;
        }

        const validIndex = isObject( pStr ) || /[^\d,.\sA-FXx]/.test( s ) ? "-1" : asInt( s, 0 );

        if ( asString( validIndex, true ) === s )
        {
            return parseInt( s );
        }

        return _dblqt + s.replaceAll( /[\W$_]/g, _mt_str ) + _dblqt;
    };


    /**
     * Returns true if the string representation of the argument is specifically the empty string
     * @param {any} pStr - a string or object to check for emptiness
     * @returns {boolean} true if the string representation of the argument is the empty string
     */
    const isEmpty = function( pStr )
    {
        return (_mt_str === asString( pStr, false )) || (_z === pStr) || (asString( pStr, false )?.length || 0) <= 0;
    };

    /**
     * Returns true if the string representation of the argument is the empty string or only whitespace characters
     * @param {any} pStr - a string or object to check for emptiness
     * @returns {boolean} true if the string representation of the argument is the empty string or only whitespace characters
     */
    const isBlank = function( pStr )
    {
        return (_mt_str === asString( pStr, true ).trim()) || (_z === pStr);
    };

    const DEFAULT_IS_CAPS_OPTIONS =
        {
            allowWhitespace: true,
            allowDigits: false
        };

    /**
     * Returns true if every character in the specified string is an UPPERCASE letter
     * @param pStr a string to test for all capital letters
     * @param pOptions an object defining how to treat whitespace and digits
     * @returns {boolean} true if the string specified consists solely of UPPERCASE letters
     */
    const isAllCaps = function( pStr, pOptions )
    {
        const options = { ...DEFAULT_IS_CAPS_OPTIONS, ...(pOptions || {}) };

        const str = asString( pStr, options.allowWhitespace );

        const hasLowerCase = options.allowDigits ? /[a-z]/.test( str ) : /[a-z0-9]/.test( str );

        return !hasLowerCase;
    };

    /**
     * Returns true if **NO** character in the specified string is an UPPERCASE letter
     * @param pStr a string to test for the presence of capital letters
     * @returns {boolean} true if the string specified consists solely of lowercase letters or numbers
     */
    const isNoCaps = function( pStr )
    {
        const str = asString( pStr, true );
        return !(/[A-Z]/.test( str ));
    };

    /**
     * Returns true if the specified string contains both UPPERCASE and lowercase letters
     * @param pStr a string to test for mixed case characters
     * @returns {boolean} true if the string specified contains both UPPERCASE and lowercase letters
     */
    const isMixedCase = function( pStr )
    {
        const str = asString( pStr, true );
        return /[A-Z]/.test( str ) && /[a-z/]/.test( str );
    };

    /**
     * Returns the number of times a specified substring appears in the specified string
     *
     * @param pStr {string} string possibly containing one or more occurrences of substring
     * @param pSubstring {string} the sequence of one or more characters  to count
     * @returns {number} the number of times the substring appears in the string
     */
    const occurrencesOf = function( pStr, pSubstring )
    {
        let s = asString( pStr );
        let s1 = asString( pSubstring );

        const arr = s.split( s1 );

        return arr.length - 1;
    };

    const findPosition = ( pStr, pOf ) => (_str === typeof pOf) ? pStr.indexOf( pOf ) : (isRegExp( pOf ) ? asInt( pStr.search( pOf ), -1 ) : asInt( pOf, pStr?.length ));

    /**
     * Returns the text to the left of the FIRST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the left
     * @param pOf a string or number specifying the position after which to discard the rest of the string

     * @returns the text to the left of the FIRST occurrence of pOf
     * (or if pOf is a number, the index specified by pOf)
     * If pOf is not included in the specified string, returns the original string
     */
    const leftOf = function( pString, pOf )
    {
        let s = asString( _resolveInput.call( this, pString ) );

        const pos = findPosition( s, pOf );

        return (0 <= pos) ? s.substring( 0, pos ) : s;
    };

    function sliceToPosition( pPosition, pString, pOf )
    {
        const pos = asInt( pPosition, -1 );

        if ( 0 <= pos )
        {
            return pString.slice( pos + ((_str === typeof pOf) ? pOf.length : 1), pString.length );
        }

        return pString;
    }

    /**
     * Returns the text to the right of the FIRST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the right
     * @param pOf a string or number specifying the position prior to which to discard a portion of the string
     * @returns the text to the right of the FIRST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     */
    const rightOf = function( pString, pOf )
    {
        let s = asString( _resolveInput.call( this, pString ) );

        const pos = findPosition( s, pOf );

        return sliceToPosition( pos, s, pOf );
    };

    const findLastPosition = ( pStr, pOf ) => (_str === typeof pOf) ? pStr.lastIndexOf( pOf ) : asInt( pOf, pStr?.length );

    /**
     * Returns the text to the left of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the left
     * @param pOf a string or number specifying the position after which to discard the rest of the string
     * @returns the text to the left of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     */
    const leftOfLast = function( pString, pOf )
    {
        let s = asString( _resolveInput.call( this, pString ) );

        const pos = findLastPosition( s, pOf );

        return (0 <= pos) ? s.substring( 0, pos ) : s;
    };

    /**
     * Returns the text to the right of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the right
     * @param pOf a string or number specifying the position prior to the string to return
     * @returns the text to the right of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     */
    const rightOfLast = function( pString, pOf )
    {
        let s = asString( _resolveInput.call( this, pString ) );

        const pos = findLastPosition( s, pOf );

        return sliceToPosition( pos, s, pOf );
    };

    String.prototype.leftOf = leftOf;
    String.prototype.rightOf = rightOf;
    String.prototype.leftOfLast = leftOfLast;
    String.prototype.rightOfLast = rightOfLast;

    function enclosedIn( pString, pLeft, pRight )
    {
        const left = asString( pLeft );
        const right = asString( pRight || left ) || left;
        const chars = asString( pString, true ).split( _mt_chr );

        return (left === chars[0]) && (right === chars[chars.length - 1]);
    }

    function enclosed( pString )
    {
        const str = asString( pString, true );

        let pairs = [["[", "]"], ["{", "}"], [_dblqt, _dblqt], [_sglqt, _sglqt], ["`", "`"]];

        pairs = pairs.map( e => (str.startsWith( e[0] ) && str.endsWith( e[1] )) ).filter( isTrue );

        return pairs.length > 0;
    }

    /**
     * Returns a string with all leading instances of the specified character removed
     * @param pStr a string from which to remove one or more leading instances of the specified character
     * @param pChar a single character to remove (recursively) from the start of the string,
     *              defaults to "0" to remove leading zeroes from would-be decimal numbers
     * @returns {string} a string with all leading instances of the specified character removed
     */
    const trimLeadingCharacters = function( pStr, pChar = "0" )
    {
        let char = asString( pChar ) || "0";

        let str = asString( pStr, true );

        while ( str.startsWith( char ) && str.length > 1 )
        {
            str = str.slice( 1 );
        }

        return str;
    };

    let DEFAULT_TRIM_MATCHING_OPTIONS = { leading: true, trailing: true, anywhere: false, case_sensitive: true };

    const trimMatchingChars = function( pStr, pRegExpOrChar = _spc, pOptions = DEFAULT_TRIM_MATCHING_OPTIONS )
    {
        const options = { ...DEFAULT_TRIM_MATCHING_OPTIONS, ...(pOptions || {}) };

        let s = asString( pStr );

        let flags = (options.anywhere ? "g" : _mt_str) + (options.case_sensitive ? _mt_chr : "i");

        let regExp = pRegExpOrChar instanceof RegExp ? new RegExp( pRegExpOrChar, flags ) : new RegExp( asString( pRegExpOrChar ), flags );

        if ( isString( pRegExpOrChar ) && /^\//.test( pRegExpOrChar ) && /\/$/.test( pRegExpOrChar ) )
        {
            regExp = new RegExp( pRegExpOrChar.replace( /\/$/, _mt_str ).replace( /^\//, _mt_str ).replace( /\/$/, _mt_str ), flags );
        }

        if ( regExp && regExp instanceof RegExp )
        {
            if ( options.anywhere )
            {
                s = s.replaceAll( regExp, _mt_str );
            }

            if ( options.leading )
            {
                s = s.replace( new RegExp( "^" + regExp.source, flags ), _mt_str );
            }

            if ( options.trailing )
            {
                s = s.replace( new RegExp( regExp.source + "$", flags ), _mt_str );
            }
        }

        return s;
    };

    const calculateDecimalSymbols = function( pLocale = _defaultLocale, pCurrency = _defaultCurrency )
    {
        let locale = NVL( pLocale, _defaultLocale );

        locale = (locale instanceof Intl.Locale) ? (locale?.baseName || _defaultLocaleString) : isNull( locale ) || isBlank( locale ) ? asString( runtimeLocaleString() ) || _defaultLocaleString : asString( locale );

        let currency = isNull( pCurrency ) || isBlank( pCurrency ) ? _defaultCurrency : asString( pCurrency || _defaultCurrency );

        const numberFormatter = new Intl.NumberFormat( (asString( locale ) || _defaultLocaleString),
                                                       {
                                                           style: "currency",
                                                           currency: currency
                                                       } );

        const parts = numberFormatter.formatToParts( 123_456.789 );

        const symbols = { ...DEFAULT_NUMBER_SYMBOLS };

        parts.forEach( part =>
                       {
                           const type = lcase( asString( part?.type, true ) );
                           const val = asString( part?.value );

                           switch ( type )
                           {
                               case "currency":
                                   symbols.currency_symbol = val || DEFAULT_NUMBER_SYMBOLS.currency_symbol;
                                   break;

                               case "decimal":
                                   symbols.decimal_point = val || DEFAULT_NUMBER_SYMBOLS.decimal_point;
                                   break;

                               case "group":
                                   symbols.grouping_separator = val || DEFAULT_NUMBER_SYMBOLS.grouping_separator;
                                   break;

                               default:
                                   break;
                           }

                       } );

        return lock( symbols ) || DEFAULT_NUMBER_SYMBOLS;
    };

    /**
     * Returns an array of the lengths of the segments of the value separating by the grouping separator
     *
     * @param pFormattedNumber {string|number} the number to use to derive the group sizes
     * @param pGroupingSeparator {string} the character(s) used to separate powers-of-ten groups
     * @returns {[number]} an array of the lengths of the segments of the value separating by the grouping separator
     *
     * Notably, this might return something like [2,2,3] for a value formatted according to the Indian Numbering System
     *
     * @private
     */
    function _deriveGroupingSize( pFormattedNumber, pGroupingSeparator )
    {
        const s = asString( pFormattedNumber );
        const parts = s.split( pGroupingSeparator || _comma );
        return parts.map( e => e?.length || 0 );
    }

    const deriveDecimalSymbols = function( pNumString, pOptions = calculateDecimalSymbols() )
    {
        const options = { ...DEFAULT_NUMBER_SYMBOLS, ...(pOptions || {}) };

        let s = asString( pNumString );

        let decimalPoint = options.decimal_point || _dot;
        let groupingSeparator = options.grouping_separator || _comma;

        let decimalCount = occurrencesOf( s, decimalPoint );
        let groupCount = occurrencesOf( s, groupingSeparator );

        let groupingSizes = [].concat( _deriveGroupingSize( s.trim(), groupingSeparator ) || [] );
        let lastGroupSize = groupingSizes?.length > 0 ? groupingSizes[groupingSizes.length - 1] : 0;

        if ( (decimalCount > 1 && groupCount <= 1) || (lastGroupSize > 0 && lastGroupSize < 3) )
        {
            const parts = s.split( decimalPoint );
            s = parts.join( _mt_chr ).replaceAll( groupingSeparator, _dot ).replaceAll( decimalPoint, _dot );

            options.grouping_separator = decimalPoint;
            options.decimal_point = groupingSeparator;
        }

        const obj =
            {
                corrected_value: s,
                decimal_point: options.decimal_point || _dot,
                grouping_separator: options.grouping_separator || _comma,
                currency_symbol: options.currency_symbol || "$",
                original_value: asString( pNumString )
            };

        return lock( obj );
    };

    /**
     * Returns a string representing a numeric value with the grouping separator(s) removed,
     * currency symbol removed,
     * the bigint literal 'n' removed
     * and the decimal symbol replaced with a dot (.)
     *
     * @param pInput {string|number} the string (or number) to clean
     * @param pOptions {Object} (optional) an object identifying the characters used for the grouping separator, decimal point, and currency
     * @returns {string} a string representing a numeric value with the grouping separator(s) removed,
     * currency symbol removed,
     * the bigint literal 'n' removed
     * and the decimal symbol replaced with a dot (.)
     */
    function toCanonicalNumericFormat( pInput, pOptions = calculateDecimalSymbols() )
    {
        const options = { ...DEFAULT_NUMBER_SYMBOLS, ...(pOptions || {}) };

        let s = asString( pInput );

        let {
            corrected_value,
            decimal_point,
            grouping_separator,
            currency_symbol
        } = deriveDecimalSymbols( s, options );

        s = asString( corrected_value );

        let groupingSeparator = grouping_separator || options.grouping_separator || _comma;

        if ( asString( groupingSeparator ) === asString( options.grouping_separator || groupingSeparator ) )
        {
            s = s.replaceAll( groupingSeparator, _mt_str );
        }

        let decimalPoint = decimal_point || options.decimal_point || _dot;

        if ( asString( decimalPoint ) === asString( options.decimal_point || decimalPoint ) )
        {
            s = s.replace( decimalPoint, _dot );
        }

        let currencySymbol = currency_symbol || options.currency_symbol || /\$|USD/;

        s = asString( s.replace( /n+$/, _mt_str ).replace( currencySymbol, _mt_str ), true );

        s = s.replaceAll( /\s*[^\dXxOoA-F.,+-]/gi, _mt_str );

        s = startsWithAny( s, _dot, _comma ) ? ("0" + s) : s;

        s = s.replace( /^0{2,}/, "0" );

        return asString( s, true );
    }

    function _warnIntegerOutOfRange( pInput, pSource = AS_INT )
    {
        const msg = ["asInt cannot return values greater than", Number.MAX_SAFE_INTEGER, "or less than", Number.MIN_SAFE_INTEGER, _dot, _spc, (pInput || "the specified value"), "cannot be converted to an Integer"].join( _spc );

        toolBocksModule.reportError( new IllegalArgumentError( msg ), msg, S_WARN, (modName + _colon + _colon + (pSource || AS_INT)) );
    }

    const _isIntegerOutOfRange = ( pValue ) => pValue > Number.MAX_SAFE_INTEGER || pValue < Number.MIN_SAFE_INTEGER;

    function _resolveAsArguments( pAsFloat, pValue, pDefault = 0, pOptions = calculateDecimalSymbols() )
    {
        const zero = pAsFloat ? 0.0 : 0;
        const one = pAsFloat ? 1.0 : 1;

        const dflt = isNumber( pDefault ) || isString( pDefault ) ? pDefault : zero;

        const options = populateOptions( pOptions, (isObject( pDefault ) ? pDefault : pOptions), DEFAULT_NUMBER_SYMBOLS );

        let input = _resolveInput.call( this, pValue );

        if ( isPrimitiveWrapper( input ) )
        {
            input = input.valueOf();
        }

        input = isNull( input ) ? pAsFloat ? asFloat( dflt, zero, options ) : asInt( dflt, zero, options ) : input;

        const type = typeof input;

        return { input, dflt, options, type, zero, one };
    }

    function _asIntFromObj( pIn, pDefault, pOptions )
    {
        let val = isPrimitiveWrapper( pIn ) || isFunction( pIn?.valueOf ) ? pIn.valueOf() : (Number( pIn || {} ));

        if ( isDate( pIn ) || isFunction( pIn?.getTime ) )
        {
            val = asInt( pIn.getTime() );
        }
        else if ( isFunction( pIn?.valueOf ) || isFunction( pIn?.deref ) )
        {
            let value = isFunction( pIn?.deref ) ? pIn.deref() : pIn.valueOf();

            val = (!isObject( value ) ? asInt( value, pDefault, pOptions ) : val);
        }

        return val;
    }

    function _asIntFromType( pIn, pDefault, pOptions )
    {
        let val = null;

        const type = typeof pIn;

        switch ( type )
        {
            case _num:
            case _big:
                val = !isNanOrInfinite( pIn ) ? parseInt( pIn.toFixed( 0 ) ) : asInt( pDefault, 0, pOptions );
                break;

            case _str:
                val = (isNumeric( pIn ) ? parseInt( toDecimal( pIn, (pOptions.decimal_point || _dot) ) ) : asInt( pDefault, 0, pOptions ));
                break;

            case _bool:
                val = pIn ? 1 : 0;
                break;

            case _obj:
                val = isNonNullObject( pIn ) ? _asIntFromObj( pIn, pDefault, pOptions ) : asInt( pDefault, 0, pOptions );
                break;

            default:
                break;
        }

        return val;
    }

    /**
     * Returns an integer value represented or implied by the value provided
     * @param {any} pValue a number or string representing a number
     * @param {number} pDefault a number to return if the value cannot be interpreted as a number
     *
     * @param pOptions
     * @returns {number} an integer value represented by or implied by the value provided
     */
    const asInt = function( pValue, pDefault = 0, pOptions = calculateDecimalSymbols() )
    {
        const {
            input,
            dflt,
            options,
            type
        } = _resolveAsArguments( false, _resolveInput.call( this, pValue ), pDefault, pOptions );

        if ( [_num, _big].includes( type ) && _isIntegerOutOfRange( input ) )
        {
            _warnIntegerOutOfRange( input );
            return asInt( dflt, 0, options );
        }

        let val = attempt( () => _asIntFromType( input, dflt, options ) );

        if ( isNull( val ) || isNanOrInfinite( val ) )
        {
            val = asInt( dflt, 0, options );
        }

        if ( _isIntegerOutOfRange( val ) )
        {
            _warnIntegerOutOfRange( val );
            val = asInt( dflt, 0, options );
        }

        return val || 0;
    };

    String.prototype.asInt = asInt;
    Number.prototype.asInt = asInt;
    Boolean.prototype.asInt = asInt;

    const _toInt = asInt;

    function _asFloatFromObj( pIn, pDefault, pOptions )
    {
        let val = isPrimitiveWrapper( pIn ) || isFunction( pIn?.valueOf ) ? pIn.valueOf() : (Number( pIn || {} ));

        if ( isDate( pIn ) || isFunction( pIn?.getTime ) )
        {
            val = asFloat( pIn.getTime() );
        }
        else if ( isFunction( pIn?.valueOf ) )
        {
            const value = pIn.valueOf();

            if ( isNumeric( value ) )
            {
                val = attempt( () => toDecimal( value ) );
            }

            if ( isNumber( val ) )
            {
                return val;
            }

            val = asFloat( pDefault, 0.0, pOptions );
        }

        return val;
    }

    function _asFloatFromType( pIn, pDefault, pOptions )
    {
        let val = null;

        const type = typeof pIn;

        switch ( type )
        {
            case _num:
            case _big:
                val = !isNanOrInfinite( pIn ) ? parseFloat( pIn ) : asFloat( pDefault, 0.0, pOptions );
                break;

            case _str:
                val = (isNumeric( pIn ) ? parseFloat( toDecimal( pIn, (pOptions.decimal_point || _dot) ) ) : asFloat( pDefault, 0.0, pOptions ));
                break;

            case _bool:
                val = pIn ? 1.0 : 0.0;
                break;

            case _obj:
                val = isNonNullObject( pIn ) ? _asFloatFromObj( pIn, val, pDefault, pOptions ) : asFloat( pDefault, 0.0, pOptions );
                break;

            default:
                break;
        }

        return val;
    }

    /**
     * Returns a floating-point value represented or implied by the value provided
     * @param {any} pValue a value we expect to convertible to a float
     * @param {number} pDefault a value to return if pValue cannot be converted to a valid float
     * @param pOptions
     * @returns {number} an floating-point value represented or implied by the value provided
     */
    const asFloat = function( pValue, pDefault = 0, pOptions = calculateDecimalSymbols() )
    {
        const {
            input,
            dflt,
            options
        } = _resolveAsArguments( true, _resolveInput.call( this, pValue ), pDefault, pOptions );

        let val = attempt( () => _asFloatFromType( input, dflt, options ) );

        if ( isNull( val ) || isNanOrInfinite( val ) )
        {
            val = asFloat( dflt, 0.0, options );
        }

        return val || 0.0;
    };

    String.prototype.asFloat = asFloat;
    Number.prototype.asFloat = asFloat;
    Boolean.prototype.asFloat = asFloat;

    const _toFloat = asFloat;

    const asPositiveInt = ( pStr ) => Math.max( 0, asInt( pStr ) );

    const asPositiveFloat = ( pStr ) => Math.max( 0.0, asFloat( pStr ) );

    const toNumberWithinRange = function( pStr, pMin, pMax, converter, pOptions = calculateDecimalSymbols() )
    {
        const options = { ...DEFAULT_NUMBER_SYMBOLS, ...(pOptions || {}) };

        const value = converter( pStr, 0, options );

        const minimum = converter( pMin, 0, options );
        const maximum = converter( pMax, 0, options );

        const greatest = Math.max( minimum, maximum );
        const smallest = Math.min( minimum, maximum );

        return clamp( value, smallest, greatest );
    };

    const toIntWithinRange = function( pStr, pMin, pMax, pOptions = calculateDecimalSymbols() )
    {
        return toNumberWithinRange( pStr, pMin, pMax, asInt, pOptions );
    };

    const toFloatWithinRange = function( pStr, pMin, pMax, pOptions = calculateDecimalSymbols() )
    {
        return toNumberWithinRange( pStr, pMin, pMax, asFloat, pOptions );
    };

    /**
     * Returns the specified value if it is >= 0 and < the length of the specified indexed object
     *                                                               (such as an Array or String)
     * @param {number} pIndex - candidate value to return
     * @param {*} pIndexed - an object with a length property that represents an ability to address its properties via a numeric value for which pIndex will be used
     * @param {Object} pOptions - a set of options to control subtle behaviors of the function, such as whether 0 or the last valid index is returned when the provided index is invalid
     * @returns {number} a number between 0 and one less than the length of the indexed object (i.e., Array or String)
     */
    const safeIndex = function( pIndex, pIndexed, pOptions = { defaultToEnd: false, min: 0 } )
    {
        const arr = isLikeArray( pIndexed ) ? pIndexed || [] : [] || [];

        const length = arr.length;

        const options = { ...({ defaultToEnd: false, min: 0, max: length - 1 }), ...(pOptions || {}) };

        const maxIndex = Math.min( asInt( options.max, length - 1 ), length - 1 );

        const minIndex = Math.max( 0, asInt( options.min, 0 ) );

        let index = asInt( pIndex, 0 );

        if ( index < minIndex || index > maxIndex )
        {
            index = options.defaultToEnd ? maxIndex : minIndex;
        }

        return clamp( index, minIndex, Math.max( minIndex, maxIndex ) );
    };

    const ENDS_WITH = ( s ) => e => s.endsWith( e );
    const STARTS_WITH = ( s ) => e => s.startsWith( e );
    const CONTAINS = ( s ) => e => s.includes( e );
    const MATCHES = ( s ) => e => isRegExp( e ) && e.test( s );

    const _matchesSome = function( pStr, pFilterCreator, ...pArr )
    {
        const s = asString( pStr, false );
        const arr = [].concat( ...(pArr || []) );
        return arr?.length > 0 ? arr.some( pFilterCreator( s ) ) : isEmpty( s );
    };

    const _matchesEvery = function( pStr, pFilterCreator, ...pArr )
    {
        const s = asString( pStr, false );
        const arr = [].concat( ...(pArr || []) );
        return arr?.length > 0 ? arr.every( pFilterCreator( s ) ) : isEmpty( s );
    };

    /**
     * Returns true if the string ends with any of the character sequences in the array
     * @param {string} pStr - a string to check for endings (the caller is responsible for removing whitespace if desired)
     * @param {[string]} pArr - one or more strings with which the string might end
     * @returns true if the string ends with any of the character sequences in the array
     */
    const endsWithAny = function( pStr, ...pArr )
    {
        return _matchesSome( pStr, ENDS_WITH, ...pArr );
    };

    /**
     * Returns true if the string starts with any of the character sequences in the array
     * @param {string} pStr - a string to evaluate (the caller is responsible for removing whitespace if desired)
     * @param {...string} pArr - one or more strings with which the string might begin or regular expressions against which to test the string
     * @returns true if the string begins with any of the character sequences in the array
     */
    const startsWithAny = function( pStr, ...pArr )
    {
        return _matchesSome( pStr, STARTS_WITH, ...pArr );
    };

    /**
     * Returns true if the specified string matches any of the provided regular expressions.
     * <br>
     *
     * @param {string} pStr - The string to be evaluated against the regular expressions.
     *
     * @param {...RegExp} pRx - A set of regular expressions to test against the input string.
     *
     * @returns {boolean}       true if the input string matches at least one of the provided regular expressions,
     *                          otherwise false.
     */
    const matchesAny = function( pStr, ...pRx )
    {
        return _matchesSome( pStr, MATCHES, ...pRx );
    };

    /**
     * Returns true if the specified string matches ALL the provided regular expressions.
     * <br>
     *
     * @param {string} pStr - The string to be evaluated against the regular expressions.
     *
     * @param {...RegExp} pRx - A set of regular expressions to test against the input string.
     *
     * @returns {boolean}       true if the input string matches every one of the provided regular expressions,
     *                          otherwise false.
     */
    const matchesAll = function( pStr, ...pRx )
    {
        return _matchesEvery( pStr, MATCHES, ...pRx );
    };

    /**
     * Returns true if the string contains any of the character sequences in the array
     * @param {string} pStr - a string to check for substrings (the caller is responsible for removing whitespace if desired)
     * @param {...string} pArr - one or more strings that the string might include
     * @returns true if the string includes any of the character sequences in the array
     */
    const includesAny = function( pStr, ...pArr )
    {
        return _matchesSome( pStr, CONTAINS, ...pArr );
    };

    /**
     * Returns true if the string includes ALL the character sequences in the array
     * @param {string} pStr - a string to check for substrings (the caller is responsible for removing whitespace if desired)
     * @param {[string]} pArr - one or more strings that the string must include
     * @returns true if the string includes ALL the character sequences in the array
     */
    const includesAll = function( pStr, ...pArr )
    {
        return _matchesEvery( pStr, CONTAINS, ...pArr );
    };

    function _objectToBoolean( pValue, ...pFunctionArgs )
    {
        if ( isNull( pValue ) )
        {
            return false;
        }
        else if ( isPrimitiveWrapper( pValue ) )
        {
            const value = attempt( () => pValue.valueOf() );

            if ( value instanceof Boolean )
            {
                return Boolean( value );
            }
            return evaluateBoolean( value );
        }
        else if ( isArray( pValue ) || isMap( pValue ) || isSet( pValue ) )
        {
            return Object.values( pValue ).flat().some( e => evaluateBoolean( e, ...pFunctionArgs ) );
        }
        else if ( isDate( pValue ) || isFunction( pValue?.getTime ) )
        {
            return attempt( () => pValue.getTime() ) > 0;
        }
        else if ( BUILTIN_TYPES.filter( e => pValue instanceof e ).length > 0 )
        {
            return ERROR_TYPES.filter( e => pValue instanceof e ).length <= 0;
        }
    }

    /**
     * Returns true if the value specified can be interpreted as an affirmative.
     * Used to allow configuration properties to be specified or obtained as strings, numbers, or even functions that return a truthy value
     * If the value specified is a function, the second parameter allows the caller to pass arguments to that function.
     *
     * @param {any} pValue the value or object to evaluate as a boolean (often a string)
     * @param  {...any} pFunctionArgs arguments to pass to the value being evaluated, if that value is a "function"
     * @returns {boolean} true if the value specified can be interpreted as an affirmative (or is a function that when called returns a "truthy" value)
     */
    const evaluateBoolean = function( pValue, ...pFunctionArgs )
    {
        let val = _resolveInput.call( this, pValue );

        // missing values are always interpreted as negatives (false)
        if ( isNull( val ) )
        {
            return false;
        }

        switch ( typeof val )
        {
            // if the value is a string, we check to see
            // if it is one of the strings defined to represent an affirmative (truthy) value
            case _str:
                return _affirmatives.includes( lcase( tidy( asString( val, true ) ) ) );

            // boolean values are already true or false, so just return the value
            case _bool:
                return Boolean( val );

            // if the value is a number, we consider any value > 0 to be a truthy value;
            // note that NaN is considered false
            case _num:
            case _big:
                return !isNaN( val ) && asFloat( val ) > 0.0;

            // if the value is a function, we try to invoke it with any arguments passed
            // and return the result of evaluating its return value
            case _fun:
                return evaluateBoolean( _attemptInvocation( val, ...pFunctionArgs ), ...pFunctionArgs );

            // if the value is an object, we return true if any of its properties evaluate to true;
            // note that this is an unexpected case at present,
            // but exists to catch all argument types the function may encounter
            case _obj:
                return _objectToBoolean( val, pFunctionArgs ) || false;

            default:
                return false;
        }
    };

    const isTrue = evaluateBoolean;
    const toBool = evaluateBoolean;
    /*

     Boolean.prototype.evaluate = Boolean.evaluate = evaluateBoolean;
     String.prototype.toBool = String.toBool = evaluateBoolean;
     */

    /**
     * This function converts all (carriage return + line feed) sequences to line feed only sequences
     *
     * @param {String} s a string representing a path or path-like value whose line feeds will be converted
     *
     * @returns {string} a string where new lines are delimited by line feed characters only
     * (without an extraneous carriage return character)
     */
    const toUnixLinebreaks = ( s ) => (asString( s )).replaceAll( /(\r\n)/g, _lf ).replaceAll( /(\n\r)/g, _lf ).replaceAll( /[\n\r]/g, _lf );

    /**
     * This function converts all line-feed only sequences to (carriage return + line feed) sequences
     * @returns {string} a string where new lines are delimited by (carriage return + line feed) characters
     * @param {string} s - a string representing a path or path-like value whose line feeds will be converted
     */
    const toWindowsLinebreaks = ( s ) => toUnixLinebreaks( asString( s ) ).replaceAll( /\n/g, _crlf );

    /**
     * Returns a filepath formatted for Linux or Unix
     * @param pPath a filepath, possibly in Windows format, to be transformed to a Unix-compatible filepath
     * @returns {string} a filepath formatted for Linux or Unix
     */
    const toUnixPath = function( pPath )
    {
        // trim any leading or trailing whitespace
        let path = asString( pPath, true );

        // replace any newline characters with a space character
        path = path.replaceAll( /(\r\n)|(\n)/g, _spc );

        // replace backslash with forward slash
        // and replace any duplicated path separators with a single separator
        path = path.replaceAll( /[\\\/]/g, "/" ).replace( /\/\//g, "/" );

        // escape any spaces in the path name
        path = path.replaceAll( / /g, "\ " );

        // replace any duplicated path separators with a single separator
        path = path.replaceAll( /\/\//g, "/" );

        return path.trim();
    };

    /**
     * Returns true if the specified path is expressed as relative to another path.
     * That is, this returns true if the path includes ./ or ../
     * @param {string} pPath a string representing a filepath that may or may not be relative to another path
     * @returns {boolean} true if the path includes ./ or ../
     */
    const isRelativePath = function( pPath )
    {
        let filepath = toUnixPath( pPath );
        return filepath.includes( _unixThisDir ) || filepath.includes( _unixPrevDir ) || filepath.startsWith( _dot );
    };

    /**
     * Returns an absolute filepath to the file or directory specified by pPath.
     * NOTE: This is equivalent to the node::path join or normalize functions,
     * but takes only 2 arguments and the second is assumed to represent an absolute path to the root directory
     *
     * @param {string} pPath a filepath relative to the root path
     * @param {string} pRootPath an absolute filepath to the root directory of the device on which this code is running
     * @returns {string|*} an absolute path to the file or directory specified by pPath
     */
    const toAbsolutePath = function( pPath, pRootPath )
    {
        let rootPath = toUnixPath( asString( pRootPath, true ) ) || __dirname;
        let filepath = toUnixPath( asString( pPath, true ) ) || __dirname;

        let root = rootPath.split( _slash );
        let path = filepath.split( _slash );

        let filePathParts = [];

        for( let i = path.length; i--; )
        {
            const s = path[i];

            if ( !root.includes( s ) )
            {
                filePathParts.unshift( s );
            }
            else
            {
                filePathParts.unshift( _dot + _dot );
            }
        }

        filepath = filePathParts.join( _slash );

        if ( filepath.startsWith( rootPath ) )
        {
            filepath = toUnixPath( filepath.replace( rootPath, _mt_str ) );
        }

        if ( !isRelativePath( filepath ) )
        {
            return toUnixPath( rootPath + "/" + filepath.replace( new RegExp( "^" + rootPath ), _mt_str ) );
        }

        const thisDir = _unixThisDir;

        // replace relative reference to the current directory
        while ( filepath.startsWith( thisDir ) && filepath.length >= thisDir.length )
        {
            // we remove the current directory reference, because we are going to prepend the base directory it represents
            filepath = filepath.length > thisDir.length ? filepath.slice( thisDir.length ) : _mt_str;
        }

        let dirs = [].concat( (rootPath.split( _unixPathSep ) || []) ).concat( (filepath.split( _unixPathSep ) || []) ).filter( e => !isBlank( e ) );

        // the ".." sequence means the directory one level prior, so...
        // every time we find this, we will remove that array element and the previous array element
        // unless there is no previous array element, which means we have reached the root
        let idx = dirs.indexOf( _dot + _dot );

        function moreDirectoriesToProcess( pIndex, pDirs )
        {
            return pIndex >= 0 && (pIndex < pDirs.length) && (pDirs.length > 1);
        }

        while ( moreDirectoriesToProcess( idx, dirs ) )
        {
            dirs = dirs.slice( 0, Math.max( 0, idx - 1 ) ).concat( dirs.slice( Math.min( dirs.length - 1, idx + 1 ) ) );

            // look for the next previous directory token
            idx = dirs.indexOf( _dot + _dot );
        }

        // rebuild the path for the array of directories
        filepath = dirs.join( _unixPathSep );

        return toUnixPath( filepath );
    };

    const _trim = ( s ) => asString( s, true ).trim();

    // returns true if the specified value contains only whitespace characters
    const _isMt = ( s ) => _mt === _trim( s );

    // convert the specified string to all lowercase
    const _lcase = ( s ) => _toStr( s ).toLowerCase();

    const _ucase = ( s ) => _toStr( s ).toUpperCase();

    const _lct = ( s ) => _lcase( _trim( s ) );

    const _uct = ( s ) => _ucase( _toStr( s ) );

    const _cap = ( s ) => _uct( _trim( s ).slice( 0, 1 ) ) + _lct( _trim( s ).slice( 1 ) );

    const _rtOf = ( pStr, w ) =>
    {
        let s = _toStr( pStr );
        let pos = (_num === typeof w) ? w : s.lastIndexOf( _toStr( w ) );
        return (pos >= 0 && pos < (s.length - 1)) ? s.slice( -(pos + 1) ) : _mt;
    };

    const _reg = ( rx, pFlags ) =>
    {
        if ( _str === typeof rx )
        {
            let x = (rx || _tilde);
            if ( pFlags )
            {
                try
                {
                    x = new RegExp( x.replaceAll( /\\/g, "\\" ), pFlags );
                    return (x instanceof RegExp) ? x : (rx || _tilde);
                }
                catch( ex )
                {
                    // ignored
                }
            }
            return x || (rx || _tilde);
        }
        else if ( rx instanceof RegExp )
        {
            let exp = rx || /~/;

            let validFlags = e => ["d", "g", "i", "m", "s", "u", "v", "y"].includes( e );

            let arr = [...((_rtOf( exp.toString(), _unixPathSep ) || _mt).split( _mt ))].sort().map( _lcase ).filter( validFlags );

            arr.push( isArray( pFlags ) ? pFlags : ((pFlags || _mt).split( _mt )) );

            let flags = [...(new Set( arr.flat().map( _lcase ) ))].filter( validFlags ).join( _mt );

            return _isMt( flags ) ? new RegExp( exp ) : new RegExp( exp, flags );
        }
    };

    const _rp = ( r ) => (asString( r || _mt ) || _mt);

    const _rplA = ( s, rx, r = _mt ) => asString( s ).replaceAll( _reg( rx, "g" ), _rp( r || _mt ) );

    const _rpl = ( s, rx, r = _mt ) => asString( s ).replace( _reg( rx, (_rtOf( (rx || /~/), _unixPathSep )) ), _rp( r || _mt ) );

    const $ln = ( e ) => asInt( (e ? (e.length || 0) : 0) ) || 0;

    // returns the Nth element of a collection or the Nth character of a string
    const $nth = ( pArr, pIdx = 0, pDefault = null ) => (null != pArr) && ($ln( isArray( pArr ) || isString( pArr ) ? [...(pArr || [])] : [pArr] ) > pIdx ? [...(pArr || [])][pIdx] : pDefault);

    const $last = ( pArr, pDefault = null ) => (isArray( pArr ) || isString( pArr )) ? $nth( [...(pArr)], $ln( pArr ) - 1, pDefault ) : pDefault;

    /**
     * Returns true if the specified value is a string and is not the empty string (unless the third argument is true)
     * or a string containing the text "undefined", "null", or "void" (as can be the result of type coercion),
     * (unless the second argument is false or missing)
     *
     * @param {any} pString - a value that may or may not be a valid string as per our criteria
     *
     * @param {boolean} pRemoveCoercionArtifacts when true, the function will replace the literal text,
     * "void", "null", or "undefined" with the empty string.
     * This is sometimes necessary to compensate for APIs that return that text when coercing values to a string.
     *
     * @param {boolean} pAcceptEmptyString when true, this function returns true even if the string is the empty string
     *
     * @returns {boolean} true if the value specified is a string
     * and is not the empty string (unless the third argument is true)
     * or a string containing the text "undefined", "null", or "void" (as can be the result of type coercion),
     * (unless the second argument is false or missing)
     */
    const isValidString = function( pString, pRemoveCoercionArtifacts, pAcceptEmptyString )
    {
        if ( pString && (isString( pString )) )
        {
            let s = (_mt_str + (pRemoveCoercionArtifacts ? (_mt_str + pString).replace( /null|undefined|void/gi, _mt_str ) : pString));

            return pAcceptEmptyString || !isEmpty( s );
        }

        return false;
    };

    const _prepareJson = function( pString )
    {
        return isString( pString ) ? tidy( pString ) : isObject( pString ) ? JSON.stringify( pString ) : _mt_str;
    };

    /**
     * Returns true if the specified input is a valid JSON entity.<br>
     * A valid JSON entity, for this purpose, is defined as either
     * a string representing an Object or an Array.<br>
     *
     * @param {string|object} pString - The input to validate. It can be a string or an object.
     *                                  If it's an object, it will be converted to a JSON string.
     *
     * @param {Array<string>} [pChars=["{", "}"]] - The expected starting and ending characters
     *                                              of a valid JSON structure. Defaults to curly braces.
     *
     * @param {boolean} [pTest=false] - If true, parses the JSON text to ensure it represents an object or array.<br>
     *                                  Defaults to false, in which case, we only validate that the string appears to have a proper form.
     *
     * @returns {boolean} Returns true if the input is a string representing a JSON object or array
     * based on the specified parameters; otherwise, false.
     */
    const isValidJsonEntity = function( pString, pChars = ["{", "}"], pTest = false )
    {
        let str = _resolveInput.call( this, pString );

        const s = attempt( _prepareJson, str ) || asString( str, true );

        let rx = new RegExp( _rxValidJson, "s" ); // the 's' flag means to enable dot (.) to match newline characters (\n)

        let matches = rx.exec( s );

        let chars = [].concat( ...(pChars || ["{", "}"]) );

        if ( !isNull( matches ) && matches.length > 3 && (chars[0] === matches[1] && chars[1] === matches[3]) )
        {
            try
            {
                return !pTest || isObject( JSON.parse( s ) );
            }
            catch( ex )
            {
                // ignore
            }
        }
        return false;
    };

    /**
     * Returns true if the specified string appears to be a JSON expression representing an Object.
     *
     * @param {string|object} pString a string that might be a JSON expression representing an Object
     *
     * @param {boolean} pTest If true, this function will only return true if we can successfully parse the JSON
     *
     * @returns {boolean} true if the string appears to be a JSON expression representing an Object
     */
    const isValidJsonObject = function( pString, pTest = false )
    {
        return isValidJsonEntity( pString, ["{", "}"], pTest ) && ( !pTest || !isArray( JSON.parse( pString ) ));
    };

    /**
     * Returns true if the specified string appears to be a JSON expression representing an Array.<br>
     *
     * @param pString a string that might be a JSON expression representing an Array
     *
     * @param {boolean} pTest If true, this function will only return true if we can successfully parse the JSON
     *
     * @returns {boolean} true if the string appears to be a JSON expression representing an Array
     */
    const isValidJsonArray = function( pString, pTest = false )
    {
        return isValidJsonEntity( pString, ["[", "]"], pTest ) && ( !pTest || isArray( JSON.parse( pString ) ));
    };

    /**
     * Determines whether a given input can be considered as JSON or not.
     *
     * The function evaluates the input string by checking various conditions:
     * - If the input is not a string or is blank, it checks if it is a number.
     * - Trims the input string and removes leading or trailing whitespaces.
     * - Checks if the input is enclosed in appropriate brackets.
     * - Validates specific keywords such as "null", "void", and "undefined".
     * - Ensures that the input does not contain invalid characters for JSON representation.
     *
     * @function
     * @param {string|number|any} pStr - The input value to evaluate as potential JSON.
     * @returns {boolean} - true if the input is considered JSON, otherwise false.
     */
    const isJson = function( pStr )
    {
        if ( !isString( pStr ) || isBlank( pStr ) )
        {
            return isNumber( pStr );
        }

        const str = tidy( asString( pStr, true ) ).trim().replace( /^[ \n\r]+/, _mt_str ).replace( /[ \n\r]+$/, _mt_str );

        if ( enclosed( str ) )
        {
            return true;
        }

        return "null" === str || "void" === str || "undefined" === str || isNumber( str ) || !(/[^0-9-.]+/.test( str ));
    };

    /**
     * @typedef {Object} JsonValidationOptions Options to control the behavior of the 'isValidJson' function
     *
     * @property {boolean} [jsonObjectsOnly=false] When true, the string must represent an object, rather than an array or other type
     * @property {boolean} [jsonArraysOnly=false]  When true, the string must represent an array, rather than an object or other type
     * @property {boolean} [acceptPrimitives=false] When true, the string can represent any valid JavaScript type, such as a number, string, or even null or undefined
     * @property {object} [jsonOptions={ objectsOnly: false, arraysOnly: false, test: false }] An alternative mechanism for passing the validation options
     * @property {boolean} [testJson=false] When true, potentially valid JSON will be parsed to ensure it is actually valid
     *
     */

    const JSON_VALIDATION_OPTIONS =
        {
            jsonObjectsOnly: false,
            jsonArraysOnly: false,
            acceptPrimitives: false,
            jsonOptions: { objectsOnly: false, arraysOnly: false, test: false },
            testJson: false
        };

    /**
     * Returns true if the specified string appears to be a JSON expression representing an Object or Array.
     *
     * @param {string|object} pString a string that might be a JSON expression representing an Object
     *
     * @param {JsonValidationOptions} pOptions an object defining whether to return true only for Arrays or Objects
     *
     * @returns {boolean} true if the string appears to be a JSON expression representing an Object or Array
     */
    const isValidJson = function( pString, pOptions = JSON_VALIDATION_OPTIONS )
    {
        let str = _resolveInput.call( this, pString );

        const s = attempt( _prepareJson, str ) || asString( str, true );

        const options = populateOptions( pOptions, JSON_VALIDATION_OPTIONS );

        let testJson = options?.testJson || options?.jsonOptions?.test;

        if ( options?.jsonObjectsOnly || options?.jsonOptions?.objectsOnly )
        {
            return isValidJsonObject( s, testJson );
        }

        if ( options?.jsonArraysOnly || options?.jsonOptions?.arraysOnly )
        {
            return isValidJsonArray( s, testJson );
        }

        let is = isValidJsonObject( s, testJson ) || isValidJsonArray( s, testJson );

        if ( !is && options?.acceptPrimitives )
        {
            is = isJson( s );
        }

        return is;
    };

    const DEFAULT_VALID_NUMBER_OPTIONS = lock(
        {
            minimumValue: Number.NEGATIVE_INFINITY,
            maximumValue: Number.POSITIVE_INFINITY,
            ...DEFAULT_NUMBER_SYMBOLS
        } );

    const _ano = ( pOptions ) => { return { ...DEFAULT_VALID_NUMBER_OPTIONS, ...(pOptions || {}) }; };

    /**
     * Returns true if the argument is a number
     * (and optionally, if it is in the valid range defined in the pOptions argument)
     *
     * @param {number} pNum a value to check for numeric validity
     *
     * @param {Object} pOptions (optional) an object defining the minimum and maximum valid values accepted
     *
     * @returns true if the argument is a number (and optionally, if it is in the valid range defined in the pOptions argument)
     */
    const isValidNumber = function( pNum, pOptions = DEFAULT_VALID_NUMBER_OPTIONS )
    {
        const options = _ano( pOptions );

        const minValue = Math.max( Number.NEGATIVE_INFINITY, (0 === options?.minimumValue ? 0 : options.minimumValue) );

        const maxValue = Math.min( Number.POSITIVE_INFINITY, (0 === options?.maximumValue ? 0 : options.maximumValue) );

        // if the argument isn't defined, is null, or is not a numeric type or instance of Number, it is not valid, return false
        if ( _ud === typeof pNum || null == pNum || !([_num, _big].includes( typeof pNum ) || (_obj === typeof pNum && pNum instanceof Number)) )
        {
            return false;
        }

        let num = pNum;

        // we attempt to parse the value as a float and reject NaN or Infinity
        try
        {
            num = parseFloat( asString( pNum, true ) );

            if ( isNanOrInfinite( num ) )
            {
                return false;
            }
        }
        catch( ex )
        {
            toolBocksModule.reportError( ex, "trying to interpret " + asString( pNum ) + " as a number", S_WARN, (modName + _colon + _colon + "isValidNumber") );
        }

        // create a local variable to control the rest of the logic
        // initialize it according to what we know so far
        let valid = !((isNanOrInfinite( pNum ) || isNanOrInfinite( num )));

        // if the argument is a number, is it in the valid range specified
        if ( valid )
        {
            valid = num >= minValue && num <= maxValue;
        }

        // return the results
        return valid;
    };

    const isValidNumeric = function( pStr, pOptions = DEFAULT_VALID_NUMBER_OPTIONS )
    {
        const options = _ano( pOptions );

        if ( isValidNumber( pStr, options ) )
        {
            return true;
        }

        switch ( typeof pStr )
        {
            case _str:

                let s = toCanonicalNumericFormat( pStr, options );

                let num = parseFloat( s ) || Number( s );

                return isValidNumber( num, options );

            case _obj:
                if ( pStr instanceof Number || pStr instanceof BigInt )
                {
                    return isValidNumber( parseFloat( pStr ) );
                }
                break;

            case _fun:
                try
                {
                    let n = pStr.call( $scope(), pStr );
                    return isValidNumber( n, pOptions );
                }
                catch( ex )
                {
                    // ignore
                }
                break;

            default:
                break;
        }
        return false;
    };


    /**
     * Returns true if the specified string is allowed as a file name
     *
     * @param {string} pStr the string to evaluate
     *
     * @returns {boolean} true if the string could be used as a file name
     */
    const isLegalFileName = function( pStr )
    {
        if ( isString( pStr ) && !isBlank( pStr ) )
        {
            return !/[*?><:|"\\\/]/.test( pStr );
        }
        return false;
    };

    /**
     * Returns true if the specified string is very likely to be a filepath
     *
     * @param {string} pStr the string to evaluate
     *
     * @returns {boolean} true if the string is very likely to represent a filepath or URL
     */
    const isFilePath = function( pStr )
    {
        if ( isString( pStr ) && !isBlank( pStr ) )
        {
            if ( pStr.length > 260 )
            {
                return false;
            }

            if ( /[*?><|"]/.test( pStr ) )
            {
                return false;
            }

            if ( /[\\\/\w._-]+/.test( pStr ) )
            {
                const parts = pStr.split( /[\\\/]/g );
                return isLegalFileName( parts[parts.length - 1] );
            }
        }

        return false;
    };

    /**
     * Returns the string representation of the specified argument in all lowercase characters.
     * Shorthand for asString( pStr, false ).toLowerCase();
     * @param pStr a string or value that can be converted to a string using asString
     * @returns {string} the string representation of the specified argument in all lowercase characters
     */
    const lcase = ( pStr ) => asString( pStr, false ).toLowerCase();

    /**
     * Returns the string representation of the specified argument in all uppercase characters.
     * Shorthand for asString( pStr, false ).toUpperCase();
     * @param pStr a string or value that can be converted to a string using asString
     * @returns {string} the string representation of the specified argument in all uppercase characters
     */
    const ucase = ( pStr ) => asString( pStr, false ).toUpperCase();

    const PROPERCASE_OPTIONS =
        lock( {
                  separator: _spc,
                  prefixes: ["Mc", "Mac", "O'"],
                  exceptions: ["von", "van", "de", "del", "la", "dos", "da", "der", "di", "du", "et", "al", "o'", "mc", "mac", "st"],
                  compounds: ["mary ellen", "dawn marie", "mary ann", "mary anne", "lisa marie", "anne marie", "mary jo"],
                  middles: ["ann", "jo", "marie", "jane", "sue", "lynn", "lynne", "beth", "may", "grace", "ray", "joe", "dean", "lee", "gene", "bob"],
                  rxAddr: /\d+\s*((N|E|S|W|NE|NW|SE|SW)[. ]?)?\s*\w+\s*(AVE(NUE)?|BLVD|ST(REET|[ .])|ROAD|RD([ .])|CIR(CLE)?|COURT|CT([ .])|DR(IVE|[ .])|LANE|LN([ .])|PL(ACE|[ .])|PARKWAY|PKWY|SQ(UARE|[ .])|TER(RACE|[ .])|ROUTE|RT([ .])|AVENUE|BOULEVARD)/gi,
                  rxEmail: /\S+@\w+\.(com|edu|gov|org|net|co|info|biz|io)/gi
              } );

    /**
     * Used by other methods to handle surnames with mix capitalization
     * @param pString a string that might represent a mixed cased surname
     * @param pOptions an object specifying additional surname prefixes to handle
     * @returns {string} a string with proper capitalization of the name
     */
    const handleMc = function handleMc( pString, pOptions = PROPERCASE_OPTIONS )
    {
        const options = { ...PROPERCASE_OPTIONS, ...(pOptions || {}) };

        let s = asString( pString, false ) || _mt_str;

        let prefixes = ["Mc", "Mac", "O'"].concat( options?.prefixes || [] ).flat();

        if ( !includesAny( s, ...prefixes ) )
        {
            return s;
        }

        let out = _mt_str;

        let tokens = s.split( _spc );

        for( let i = 0, n = tokens.length; i < n; i++ )
        {
            let t = tokens[i];

            let Mc = -1;
            let len = 0;

            while ( Mc !== 0 && prefixes.length > 0 )
            {
                let prefix = prefixes.shift();

                Mc = t.indexOf( prefix );

                len = prefix.length;

                if ( Mc === 0 && len > 0 )
                {
                    break;
                }
            }

            if ( Mc === 0 && t.length > len )
            {
                t = t.substring( 0, len ) + t.substring( len, len + 1 ).toUpperCase() + t.substring( len + 1, t.length );
            }

            out += (t + _spc);
        }

        return out.trim();
    };

    /**
     * Returns a string formatted as a name in proper case
     * handling common surnames that include a hyphen, apostrophe, Mc, or Mac, etc
     * @param pStr the string to convert to ProperCase
     * @param pOptions an object defining the separator to use to split the string into 'words' as well as other behaviors
     * @returns {string}
     */
    const toProperCase = function( pStr, pOptions = PROPERCASE_OPTIONS )
    {
        const options = { ...PROPERCASE_OPTIONS, ...(pOptions || {}) };

        let s = asString( pStr, false ) || _mt_str;

        let out = _mt_str;

        let sep = (options?.separator || _spc);

        let words = s.split( sep ).filter( e => !isEmpty( e ) );

        let word = _mt_str;

        let temp = _mt_str;

        for( let i = 0; i < words.length; i++ )
        {
            temp = _mt_str;

            // reset
            word = words[i];

            out += word.substring( 0, 1 ).toUpperCase();

            temp = word.substring( 1, word.length ).toLowerCase();

            if ( temp.indexOf( _apos ) >= 0 )
            {
                //handle O'Leary
                temp = _apos + toProperCase( temp, Object.assign( { ...options }, { separator: _apos } ) );
            }

            let pos = temp.indexOf( _hyphen );

            if ( pos >= 0 )
            {
                //handle Thorne-Smith (temp = horne-smith )
                temp = temp.substring( 0, pos ) + _hyphen + handleMc( temp.substring( pos + 1, pos + 2 ).toUpperCase() + temp.substring( pos + 2, temp.length ) );
            }

            out += temp;

            if ( i < (words.length - 1) )
            {
                out += sep;
            }
            else
            {
                if ( s.substring( s.length - 1 ) === _spc )
                {
                    out += _spc;
                }
            }
        }

        out = handleMc( out ) || out;

        return out;
    };

    String.prototype.toProperCase = function()
    {
        return toProperCase( this );
    };

    function _toArr( pVal )
    {
        return isArray( pVal ) ? [...pVal].flat().filter( e => isString( e ) && !isBlank( e ) ) : (isString( pVal ) ? asString( pVal, true ).split( _comma ).filter( e => !isBlank( e ) ) : []);
    }

    function asProperCaseName( pName, pOptions = PROPERCASE_OPTIONS, pIsFirstName = false )
    {
        let options = populateOptions( pOptions || {}, PROPERCASE_OPTIONS );

        // convert the name to lowercase and trim
        let name = _lct( asString( pName, true ) );

        // remove honorific prefixes
        name = name.replace( /^(mr\s+|mr\.\s+|dr\s+|dr\.\s+|ms\s+|ms\.\s+)/gi, _mt ).trim();

        name = name.replaceAll( /\s{2,}/g, _spc );

        let formattedName = asString( name, true );

        // capitalize the first letter of *each word* using word boundary (\b)
        formattedName = formattedName.replace( /\b([a-z])/gi, ( match, char ) =>
        {
            return ucase( asString( char, true ) );
        } );

        if ( !!pIsFirstName )
        {
            let exceptions = _toArr( options.exceptions || PROPERCASE_OPTIONS.exceptions || [] ).filter( e => !isBlank( e ) ).map( e => _lct( e ) );

            // handle specific exceptions such as 'van', 'de', 'dos', 'Mc'
            // we only apply this if the word is *not* the first word in the name
            formattedName = formattedName.replace( /\b([a-z]+)\b/gi, ( match, word, index ) =>
            {
                if ( index > 0 && exceptions.includes( word ) )
                {
                    // Check if it's an 'O\'...' name before lowercasing 'o\''
                    if ( word === "o'" && formattedName.charAt( index + 2 ).match( /[a-z]/i ) )
                    {
                        return "O'"; // Keep the 'O' capitalized for O'Reilly, for example
                    }
                    return _lct( word );
                }
                return match;
            } );

            // handle Mc/Mac-like exceptions (e.g., McNamara, McDonald)
            // capitalize the letter immediately after 'Mc' or 'Mac' if it exists
            formattedName = formattedName.replace( /(mc|mac)([a-z])/gi, ( match, prefix, remaining ) =>
            {
                return toProperCase( prefix ) + ucase( remaining );
            } );

            // handle hyphens and apostrophes for double capitalization (e.g., Smith-Jones, O'Leary)
            formattedName = formattedName.replace( /([-' ])([a-z])/gi, ( match, separator, remaining ) =>
            {
                return separator + ucase( remaining );
            } );

            // handle Roman Numerals (IV, III) and Ordinals (3rd)
            formattedName = formattedName.replace( /\b(i{1,3}|iv|v|vi{1,3}|ix|x|[1-9][stndrh]{2})\b/gi, ( match ) =>
            {
                return ucase( match );
            } );

            // titles and honorifics
            formattedName = formattedName.replace( /\b(md|dds)\b/gi, ( match ) =>
            {
                return ucase( match );
            } );

            formattedName = formattedName.replace( /\b(ph\.?d\.)\b/gi, ( match ) =>
            {
                return "PhD";
            } );
        }

        return asString( formattedName, true ).replace( /\s+/, _spc ).trim();
    }

    function _findSplitOnException( pNameParts, pExceptions = PROPERCASE_OPTIONS.exceptions )
    {
        let idx = -1;

        let parts = _toArr( pNameParts || [] ).filter( e => !isBlank( e ) ).map( e => _lct( e ) );

        let exceptions = _toArr( pExceptions || [] ).filter( e => !isBlank( e ) ).map( e => _lct( e ) );

        if ( $ln( exceptions ) > 0 )
        {
            for( let exc of exceptions )
            {
                idx = parts.indexOf( exc );
                if ( idx >= 0 )
                {
                    break;
                }
            }
        }

        return idx;
    }

    function _findSplitOnCompoundFirstName( pNameParts, pOptions = PROPERCASE_OPTIONS )
    {
        let options = { ...PROPERCASE_OPTIONS, ...(pOptions || {}) };

        let idx = -1;

        let parts = _toArr( pNameParts || [] ).filter( e => !isBlank( e ) ).map( e => _lct( e ) );

        let compoundNames = _toArr( options.compounds || [] ).filter( e => !isBlank( e ) ).map( e => _lct( e ) );

        if ( $ln( compoundNames ) > 0 )
        {
            const firstPart = _lct( parts.slice( 0, 2 ).join( _spc ) );

            for( let cn of compoundNames )
            {
                if ( _lct( cn ) === firstPart )
                {
                    idx = 2;
                    break;
                }
            }
        }

        if ( idx < 0 && $ln( parts ) > 2 )
        {
            let middles = _toArr( options.middles || PROPERCASE_OPTIONS.middles || [] ).filter( e => !isBlank( e ) ).map( e => _lct( e ) );

            const middleName = _lct( parts[1] );

            if ( middles.includes( middleName ) )
            {
                idx = 2;
            }
        }

        return idx;
    }

    function _findSplitOnInitial( pNameParts )
    {
        let parts = _toArr( pNameParts ).filter( e => !isBlank( e ) ).map( e => _lct( e ) );

        // this also handles nicknames
        let idx = parts.findLastIndex( e => ($ln( e ) < 2 || /^\w\.$/.test( e.trim() ) || /^["(]\s*\w+[")]$/.test( e.trim() )) );
        if ( idx >= 0 )
        {
            idx += (idx < $ln( parts ) - 1) ? 1 : 0;
        }
        return idx;
    }

    function _nameContainsEmail( pFirstName, pLastName, pOptions = PROPERCASE_OPTIONS )
    {
        let rxEmail = pOptions?.rxEmail || /\S+@\w+\.(com|edu|gov|org|net|co|info|biz|io)/gi;

        return (isRegExp( rxEmail ) && (rxEmail.test( pFirstName ) || rxEmail.test( pLastName )));
    }

    function _nameContainsAddress( pFirstName, pLastName, pOptions = PROPERCASE_OPTIONS )
    {
        let rxAddr = pOptions?.rxAddr || /\d+\s*((N|E|S|W|NE|NW|SE|SW)[. ]?)?\s*\w+\s*(AVE(NUE)?|BLVD|ST(REET|[ .])|ROAD|RD([ .])|CIR(CLE)?|COURT|CT([ .])|DR(IVE|[ .])|LANE|LN([ .])|PL(ACE|[ .])|PARKWAY|PKWY|SQ(UARE|[ .])|TER(RACE|[ .])|ROUTE|RT([ .])|AVENUE|BOULEVARD)/gi;

        return (isRegExp( rxAddr ) && (rxAddr.test( pFirstName ) || rxAddr.test( pLastName )));
    }

    function normalizeName( pFirstName, pLastName, pOptions = PROPERCASE_OPTIONS, pOtherContactData = {} )
    {
        let options = { ...PROPERCASE_OPTIONS, ...(pOptions || {}) };

        let exceptions = _toArr( options.exceptions || PROPERCASE_OPTIONS.exceptions || [] ).filter( e => !isBlank( e ) ).map( e => _lct( e ) );

        let firstName = asProperCaseName( asString( pFirstName, true ), options, true );
        let lastName = asProperCaseName( asString( pLastName, true ), options, false );

        function _removeContactData( pName, pData = pOtherContactData )
        {
            let name = asString( pName, true );

            let data = pData || {};

            name = name.replace( (asString( data.address ) || _mt), _mt );
            name = name.replace( (asString( data.phoneNumber || data.phone ) || _mt), _mt );
            name = name.replace( (asString( data.emailAddress || data.email ) || _mt), _mt );

            return asString( name, true );
        }

        if ( isPopulatedObject( pOtherContactData ) )
        {
            firstName = asProperCaseName( _removeContactData( firstName, pOtherContactData ), options, true );
            lastName = asProperCaseName( _removeContactData( lastName, pOtherContactData ), options, false );
        }

        if ( firstName === lastName )
        {
            const parts = firstName.split( / / );

            if ( 2 === $ln( parts ) )
            {
                firstName = asString( parts[0], true );
                lastName = asString( parts[1], true );
            }
            else if ( $ln( parts ) > 2 )
            {
                let idx = _findSplitOnException( parts, exceptions );

                if ( idx < 0 )
                {
                    idx = _findSplitOnInitial( parts );
                }

                if ( idx < 0 )
                {
                    idx = _findSplitOnCompoundFirstName( parts, options );
                }

                if ( idx >= 0 )
                {
                    firstName = asProperCaseName( parts.slice( 0, idx ).join( _spc ), true );
                    lastName = asProperCaseName( parts.slice( idx ).join( _spc ), true );
                }
                else
                {
                    firstName = asProperCaseName( parts[0], true );
                    lastName = asProperCaseName( parts.slice( 1 ).join( _spc ), true );
                }
            }
        }
        else if ( $ln( lastName ) > $ln( firstName ) && lastName.startsWith( firstName ) && lastName.includes( _spc ) )
        {
            lastName = lastName.replace( firstName, _mt ).trim();
        }
        else if ( $ln( lastName ) < $ln( firstName ) && firstName.endsWith( lastName ) && firstName.includes( _spc ) )
        {
            firstName = firstName.replace( lastName, _mt ).trim();
        }

        return {
            first: asString( firstName, true ).replaceAll( / {2,}/g, _spc ),
            last: asString( lastName, true ).replaceAll( / {2,}/g, _spc ),
            nameContainsEmail: _nameContainsEmail( firstName, lastName, options ),
            nameContainsAddress: _nameContainsAddress( firstName, lastName, options )
        };
    }


    /**
     * Converts a string in "snake case" ( some_variable_name ) into "camel case" ( someVariableName )
     * @param pStr a string to convert to camel case
     * @returns {string} the specified string formatted in "camel case"
     */
    const toCamelCase = function( pStr )
    {
        let s = asString( pStr, false ) || _mt_str;

        s = lcase( s.slice( 0, 1 ) ) + s.slice( 1 );

        let re = /_+(\w)/gi;

        function lambda( pMatch )
        {
            let match = pMatch.replace( /^_+/, _mt_str );

            return match.substring( 0 ).toUpperCase() + match.substring( 1 ).toLowerCase();
        }

        return s.replace( re, lambda );
    };

    /**
     * Converts a string in camelCase (or other format) ( someVariableName ) into "snake case" ( some_variable_name )
     * @param pStr a string to convert to camel case
     * @returns {string} the specified string formatted in "snake case"
     */
    const toSnakeCase = function( pStr )
    {
        let s = asString( pStr, false ) || _mt_str;

        s = lcase( s.slice( 0, 1 ) ) + s.slice( 1 );

        let re = /[A-Z]/g;

        function lambda( pMatch )
        {
            return (_underscore + lcase( (pMatch.substring( 0 )) ));
        }

        return lcase( s.replace( re, lambda ) ).replaceAll( /_{2,}/g, _underscore );
    };

    /**
     * This is an extremely 'paranoid' function for producing a copy of a string that cannot possibly be pointing to the original string in memory
     * @param pStr  a string to copy
     * @returns {string} a string with the same characters as the string specified, but not identical to that string
     */
    const copyString = function( pStr )
    {
        const s = asString( pStr, false );

        return (_mt_str + ([].concat( ...(asString( s, false ).split( _mt_chr )) ) || []).join( _mt_chr ));
    };

    /**
     * Returns true if the argument is not a string or if the string contains only whitespace
     * @param pStr a value to test
     * @returns {boolean} true if the argument is not a string or if the string contains only whitespace
     */
    const isUnpopulated = function( pStr )
    {
        return (_ud === typeof pStr || null == pStr || ( !isString( pStr ) || isBlank( pStr )));
    };

    const reverseString = function( pStr )
    {
        let str = _resolveInput.call( this, pStr );

        if ( null == str || _ud === typeof str || isBlank( str ) )
        {
            return _mt_str;
        }

        let arr = [].concat( str );

        switch ( typeof str )
        {
            case _ud:
                arr = [];
                break;

            case _str:
                arr = asString( str ).split( _mt_chr );
                break;

            case _num:
            case _big:
                let s = asString( str );
                arr = s.split( _mt_chr );
                break;

            case _fun:
                arr = [];
                break;

            case _obj:

                if ( isArray( str ) )
                {
                    arr = [].concat( ...(str || []) );
                }

                break;

            default:
                break;
        }

        arr = arr.reverse();

        return asString( arr.join( _mt_chr ) );
    };

    String.prototype.reverse = String.prototype.reverse || reverseString;

    const DEFAULT_TIDY_OPTIONS =
        {
            trim: true,
            replaceTabsWithSpaces: false,
            replaceSpacesWithTabs: false,
            removeRedundantSpaces: true,
            spacesPerTab: 4,
            functions: [],
            lowercase: false,
            uppercase: false,
            camelCase: false,
            snakeCase: false,
            properCase: false,
            capitalize: false,
        };

    const TRIM_OPERATIONS =
        {
            trim: ( str ) => asString( str, true ).replaceAll( /[\r\n]+/g, _spc ).trim(),
            replaceTabsWithSpaces: ( str, options ) => asString( str ).replaceAll( /\t/g, _spc.repeat( Math.max( 1, asInt( options?.spacesPerTab || 1 ) ) ) ),
            replaceSpacesWithTabs: ( str, options ) => asString( str ).replaceAll( new RegExp( _spc.repeat( Math.max( 1, asInt( options?.spacesPerTab || 1 ) ) ), "g" ), _tab ),
            removeRedundantSpaces: ( str ) => asString( str ).replaceAll( / {2,}/g, _spc )
        };

    const CASE_OPERATIONS =
        {
            toLowerCase: lcase,
            lowercase: lcase,
            toUpperCase: ucase,
            uppercase: ucase,
            capitalize: ( input ) =>
                input.length > 1
                ? ucase( input.slice( 0, 1 ) ) + lcase( input.slice( 1 ) )
                : ucase( input ),
            camelCase: toCamelCase,
            toCamelCase: toCamelCase,
            snakeCase: toSnakeCase,
            toSnakeCase: toSnakeCase,
            properCase: ( input, options ) =>
                toProperCase( input, Object.assign( { ...PROPERCASE_OPTIONS }, options || {} ) ),
            toProperCase: ( input, options ) =>
                toProperCase( input, Object.assign( { ...PROPERCASE_OPTIONS }, options || {} ) )
        };

    function convertCase( pString, pOptions = DEFAULT_TIDY_OPTIONS )
    {
        let str = asString( pString );

        const options = { ...DEFAULT_TIDY_OPTIONS, ...(pOptions || {}) };

        for( const [key, operation] of Object.entries( CASE_OPERATIONS ) )
        {
            if ( options[key] )
            {
                str = operation( str, options ) || str;
            }
        }

        return asString( str );
    }

    /**
     * A null-safe, type-safe, alternative to the String method, trim
     * Trims and returns a string or a char[] or a string representation
     * of the value passed
     *
     * Tidy performs optional transformations specified in the optional second argument, pOptions.
     * This function can be used as a sort of 'swiss army knife' for strings, based on the options passed,
     * especially the ability to pass one or more functions to transform the result
     *
     * @param {string} pString - the value to trim and return as a String
     * @param {Object} pOptions - optional operations or transformations to perform on the string,
     *                            such as toLowerCase, toUpperCase, removeRedundantSpaces, replaceSpacesWithTabs, replaceTabsWithSpaces, etc.
     *                            It is also possible to pass one or more functions to apply to the string before it is returned.
     *
     * @returns {string} a string or char[] or a string representation
     * of the value passed with whitespace removed
     * and any optional transformations applied
     */
    const tidy = function( pString, pOptions = DEFAULT_TIDY_OPTIONS )
    {
        const options = { ...DEFAULT_TIDY_OPTIONS, ...(pOptions || {}) };

        let str = asString( _resolveInput.call( this, pString ) || pString, options?.trim );

        for( const [key, operation] of Object.entries( TRIM_OPERATIONS ) )
        {
            if ( options[key] )
            {
                str = operation( str, options );
            }
        }

        let operations = [];

        if ( options?.functions )
        {
            operations = operations.concat( ...(options?.functions || []) ).filter( e => isFunction( e ) && e.length > 0 );
        }

        let temp = (_mt_str + asString( str ));

        if ( operations.length )
        {
            for( const func of operations )
            {
                if ( isFunction( func ) )
                {
                    try
                    {
                        str = func.apply( this || $scope, [str, options] );
                    }
                    catch( ex )
                    {
                        toolBocksModule.reportError( ex, "trying to execute " + asString( func?.name || functionToString.call( func ) ) + " as a number", S_WARN, (modName + _colon + _colon + "tidy") );
                    }
                }

                str = asString( str || temp );
            }
        }

        str = convertCase( asString( str, options?.trim ), options );

        return str;
    };

    String.prototype.tidy = tidy;

    function toggleCaps( pStr, pFirstLetterCase, pRestCase )
    {
        let str = asString( pStr );
        return (str?.length || 0) > 1 ? (pFirstLetterCase( str.slice( 0, 1 ) ) + pRestCase( str.slice( 1 ) )) : pFirstLetterCase( str );
    }

    function capitalize( pStr, pPreserve = false )
    {
        return toggleCaps( asString( pStr ), ucase, (pPreserve ? asString : lcase) );
    }

    function uncapitalize( pStr )
    {
        return toggleCaps( asString( pStr ), lcase, asString );
    }

    function cartesian( pStrA, pStrB )
    {
        let a = asString( pStrA );
        let b = asString( pStrB );

        let s = _mt_str;

        for( let i = 0, n = a.length; i < n; i++ )
        {
            for( let j = 0, m = b.length; j < m; j++ )
            {
                s += a.charAt( i ) + b.charAt( j );
            }
        }

        return s;
    }

    function repeat( pStr, pCount )
    {
        if ( isNumber( pCount ) )
        {
            return asString( pStr ).repeat( pCount );
        }
        if ( isString( pCount ) )
        {
            return asString( pStr ).repeat( asString( pCount ).length );
        }
        if ( isFunction( pCount ) )
        {
            let s = pStr;
            try
            {
                s = pCount.call( asString( pStr ) );
            }
            catch( ex )
            {
                toolBocksModule.reportError( ex, ex.message, S_WARN, (modName + _colon + _colon + "repeat") );
            }
            return s;
        }
    }

    const extractProtocol = ( str ) => _trim( _rpl( _trim( ((/^(sm|ht|f)?tp(s)*:\/\//.exec( _trim( str ) ) || [])[0]) || _mt_str ), /:\/\// ) );

    const filePathToUrl = function( pStr )
    {
        // TODO
        return pStr;
    };

    const cleanUrl = function( pStr, pPreserveTrailingSlash = true, pPreserveProtocol = true, pPreserveCase = true )
    {
        let url = asString( pStr, true );

        if ( _lct( url ).startsWith( "file:" ) )
        {
            return filePathToUrl( pStr );
        }

        let original = asString( url, true );

        const protocol = extractProtocol( url );

        const rx = new RegExp( "^" + protocol + "://", "i" );

        url = url.replace( rx, _mt_str );

        const arr = url.split( /[\/\\]/ ).map( e => asString( e, true ) ).filter( e => !isBlank( e ) );

        url = asString( arr.join( "/" ), true );

        if ( pPreserveProtocol )
        {
            url = (protocol.replace( /:\/\/$/, _mt_str ) + "://") + url;
        }

        const preserveTrailingSlash = pPreserveTrailingSlash && original.endsWith( "/" );

        if ( preserveTrailingSlash )
        {
            if ( !(url.endsWith( "/" )) )
            {
                url += "/";
            }
        }
        else
        {
            url = url.replace( /\/$/, _mt_str );
        }

        return pPreserveCase ? url : lcase( url );
    };

    const lengthPriorityComparator = ( pLongestFirst ) => ( a, b ) =>
    {
        let comp = a.length - b.length;
        return (comp === 0) ? a.localeCompare( b ) : pLongestFirst ? -comp : comp;
    };

    const DEFAULT_SUBSTRING_OPTIONS =
        {
            caseSensitive: true,
            ignored: []
        };

    function findDuplicatedSubstrings( pStr, pOptions = DEFAULT_SUBSTRING_OPTIONS )
    {
        const options = { ...DEFAULT_SUBSTRING_OPTIONS, ...(pOptions || {}) };

        const s = asString( isArray( pStr ) ? pStr.join( _mt_str ) : pStr );

        const caseSensitive = options?.caseSensitive && (true !== options?.ignoreCase);

        const ignored = options?.ignored || [];

        let common = [];

        for( let i = 0, n = s.length; i < n; i++ )
        {
            let j = i + 1;

            let a = s.slice( i, i + 1 );

            if ( ignored.includes( a ) || ignored.includes( a.slice( -1 ) ) )
            {
                continue;
            }

            let idx = caseSensitive ? s.indexOf( a, j ) : ucase( s ).indexOf( ucase( a ), j );

            while ( idx >= 0 && ((i + a.length + 1) < n) )
            {
                common.push( a );

                a = s.slice( i, Math.min( (i + a.length + 1), n ) );

                if ( ignored.includes( a ) || ignored.includes( a.slice( -1 ) ) )
                {
                    break;
                }

                idx = caseSensitive ? s.indexOf( a, j ) : ucase( s ).indexOf( ucase( a ), j );
            }
        }

        return [...(new Set( common ))].sort( lengthPriorityComparator( true ) );
    }

    function findCommonSubstrings( ...pStrs )
    {
        const common = [];

        // filter out empty strings
        let strings = [...(pStrs || [])].flat().map( asString ).filter( e => !isEmpty( e ) );

        if ( strings.length < 1 )
        {
            return common;
        }
        else if ( strings.length < 2 )
        {
            return findDuplicatedSubstrings( strings[0] );
        }

        // sort strings by length, shortest string first
        // because no common substring can be longer than the shortest complete string
        strings = strings.sort( lengthPriorityComparator( false ) );

        // keep track of the index of the current search string in each of the other strings

        let indices = [];

        let s = strings[0];

        let a = _mt_str;

        for( let i = 0, n = s.length; i < n && (i + a.length) < n; )
        {
            a = s.slice( i, Math.min( (i + a.length + 1), n ) );

            indices = strings.map( e => e.indexOf( a ) );

            if ( indices.every( e => e >= 0 ) )
            {
                common.push( a );
            }
            else
            {
                a = _mt_str;
                i += 1;
            }
        }

        return [...(new Set( common ))].sort( lengthPriorityComparator( true ) );
    }

    const MIN_PHONE_NUM_LEN = 10;

    function formatPhoneNumber( pPhoneNumber )
    {
        let s = asString( pPhoneNumber || _mt );

        if ( !isBlank( s ) && asInt( s.length ) >= MIN_PHONE_NUM_LEN )
        {
            s = s.replaceAll( RX_NON_DIGITS, _mt ).trim().replace( /^1/, _mt );

            if ( asInt( s.length ) >= MIN_PHONE_NUM_LEN )
            {
                return "(" + s.slice( 0, 3 ) + ") " + s.slice( 3, 6 ) + _hyphen + s.slice( 6, 10 );
            }

            return asString( s, true ) || _mt;
        }

        return pPhoneNumber;
    }

    let mod =
        {
            dependencies,
            DEFAULT_AS_STRING_OPTIONS,
            DEFAULT_NUMBER_SYMBOLS,
            PROPERCASE_OPTIONS,
            asString,
            _toStr,
            isEmpty,
            isNotEmpty: s => !isEmpty( s ),
            isBlank,
            isNotBlank: s => !isBlank( s ),
            isUnpopulated,
            isAllCaps,
            isNoCaps,
            isMixedCase,
            tidy,
            occurrencesOf,
            leftOf,
            leftOfLast,
            rightOf,
            rightOfLast,
            trimLeadingCharacters,
            trimMatchingChars,
            calculateDecimalSymbols,
            deriveDecimalSymbols,
            toCanonicalNumericFormat,
            asInt,
            _toInt,
            asFloat,
            _toFloat,
            asPositiveInt,
            asPositiveFloat,
            toIntWithinRange,
            toFloatWithinRange,
            safeIndex,
            clamp,
            validIdentifier,
            asKey,
            endsWithAny,
            startsWithAny,
            includesAny,
            includesAll,
            matchesAny,
            matchesAll,
            evaluateBoolean,
            isTrue,
            toBool,
            toUnixLinebreaks,
            toWindowsLinebreaks,
            enclosedIn,
            isValidString,
            isValidNumber,
            isValidNumeric,
            isValidJsonObject,
            isValidJsonArray,
            isValidJson,
            isJson,
            isLegalFileName,
            isFilePath,
            lcase,
            ucase,
            toCamelCase,
            toSnakeCase,
            toProperCase,
            asProperCaseName,
            normalizeName,
            formatPhoneNumber,
            copyString,
            reverseString,
            capitalize,
            uncapitalize,
            cartesian,
            repeat,
            findDuplicatedSubstrings,
            findCommonSubstrings,
            toUnixPath,
            isRelativePath,
            toAbsolutePath,
            extractProtocol,
            cleanUrl,
            toCString,
            fromCString,
            formatMessage,
            interpolate,
            getFunctionSource,
            toByteArray,
            asUtf8ByteArray,
            fromUtf8ByteArray,
            _trim,
            _isMt,
            _lcase,
            _ucase,
            _lct,
            _uct,
            _cap,
            _rpl,
            _rplA,
            $ln,
            $nth,
            $last,
            classes: { ModuleEvent, ToolBocksModule },
        };

    mod = toolBocksModule.extend( mod );

    return mod.expose( mod, INTERNAL_NAME, (_ud !== typeof module ? module : mod) ) || mod;

}());
