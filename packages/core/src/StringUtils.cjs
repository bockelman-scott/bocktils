/**
 * Defines several useful functions for manipulating Strings.
 * DEPENDS ON Constants.cjs
 */

/** import the Constants we depend upon using require for maximum compatibility with Node versions */
const constants = require( "./Constants.cjs" );

/** import the TypeUtils we depend upon using require for maximum compatibility with Node versions */
const typeUtils = require( "./TypeUtils.cjs" );

/**
 * Defines a string to represent the type, undefined
 */
const { _ud = "undefined" } = constants;

/**
 * This function returns the host environment scope (Browser window, Node.js global, or Worker self)
 */
const $scope = constants?.$scope || function()
{
    return (_ud === typeof self ? ((_ud === typeof global) ? {} : (global || {})) : (self || {}));
};

/**
 * This immediately invoked function expression (IIFE)
 * defines and returns the StringUtils module
 */
(function exposeModule()
{
    /**
     * Define a string key which is unlikely to collide with other libraries or properties.
     * We use this to store the module generated by this function in global scope.
     * We can avoid re-executing the rest of this function if the module is already defined.
     */
    const INTERNAL_NAME = "__BOCK__STRING_UTILS__";

    /**
     * Checks to see if this module is already defines and available in the global scope
     * Returns the existing module instead of recreating it, if it is already present.
     */
    if ( $scope() && (null != $scope()[INTERNAL_NAME]) )
    {
        return $scope()[INTERNAL_NAME];
    }

    /**
     * An array of this module's dependencies
     * which are re-exported with this module,
     * so if you want to, you can just import the leaf module
     * and then use the other utilities as properties of that module
     */
    const dependencies =
        {
            constants,
            typeUtils
        };

    const
        {
            _mt_str,
            _mt_chr,
            _dblqt,
            _sglqt,
            _spc,
            _dot,
            _comma,
            _underscore,
            _ellipsis,
            _tab,
            _z,
            _unixPathSep,
            _unixPrevDir,
            _unixThisDir,
            _lf,
            _crlf,
            _colon,
            _slash,
            S_TRUE,
            S_FALSE,
            S_ERROR = "error",
            S_ERR_PREFIX = `An ${S_ERROR} occurred while`,
            S_DEFAULT_OPERATION = "executing script",
            S_WARN = "warn",
            S_LOG = "log",
            S_DEBUG = "debug",
            S_INFO = "info",
            S_TRACE = "trace",
            RESERVED_WORDS,
            _affirmatives,
            _str,
            _fun,
            _num,
            _big,
            _bool,
            _obj,
            _symbol,
            IllegalArgumentError,
            ComparatorFactory,
            funcToString,
            populateOptions,
            lock,
            classes
        } = constants;

    const { ModuleEvent, ModulePrototype } = classes;

    if ( _ud === typeof CustomEvent )
    {
        CustomEvent = ModuleEvent;
    }

    const modName = "StringUtils";

    let modulePrototype = new ModulePrototype( modName, INTERNAL_NAME );

    const
        {
            isUndefined,
            isDefined,
            isNull,
            isNotNull,
            isNonNullObject,
            isString,
            isNumber,
            isBigInt,
            isNumeric,
            isBoolean,
            isObject,
            isArray,
            isFunction,
            isDecimal,
            isBinary,
            isOctal,
            isHex,
            isNanOrInfinite,
            toDecimal,
            firstMatchingType
        } = typeUtils;

    /**
     * These are the default values assumed for number formatting, when calling methods such as asInt or asFloat
     * @type {Readonly<{decimal_point: string, currency_symbol: RegExp, grouping_separator: string}>}
     */
    const DEFAULT_NUMBER_SYMBOLS = constants?.DEFAULT_NUMBER_FORMATTING_SYMBOLS || lock(
        {
            decimal_point: ".",
            grouping_separator: ",",
            currency_symbol: /\$|USD/
        } );

    /**
     * This regular expression is used to determine if a string
     * is a valid JSON object or array
     */
    const _rxValidJson = /^([{\[])(.*)*([}\]])$/s;

    const AS_INT = "asInt";

    /**
     * When a function is added to a built-in object prototype,
     * the value does not need to be passed in, so we need to find it
     * @param pValue either a value or undefined when the value should be the value of 'this'
     * @returns {number | string} the value to use in the function
     * @private
     */
    function _resolveInput( pValue )
    {
        let input = pValue;

        if ( isUndefined( pValue ) )
        {
            if ( this instanceof Number || Number === this?.constructor || isNumber( this?.prototype ) )
            {
                input = (Number( this ).valueOf() || parseFloat( _mt_str + this )) || pValue;
            }
            if ( this instanceof String || String === this?.constructor || isString( this?.prototype ) )
            {
                input = (String( this ).valueOf() || asString( _mt_str + this )) || pValue;
            }
            if ( this instanceof Boolean || Boolean === this?.constructor || isBoolean( this?.prototype ) )
            {
                input = this.valueOf() || Boolean( this ) || pValue;
            }
        }

        return input || pValue;
    }

    /**
     * @typedef {Object} AsStringOptions
     *
     * @property {boolean} [omitFunctions=true]
     * @property {boolean} [executeFunctions=false]
     * @property {boolean} [returnFunctionSource=false]
     * @property {string} [joinOn=""]
     * @property {boolean} [removeLeadingZeroes=true]
     * @property {boolean} [assumeNumeric=false]
     * @property {boolean} [assumeAlphabetic=true]
     * @property {Object|function|null} [dateFormatter=null],
     * @property {Array.<function>} [transformations=[]]
     * @property {boolean} [checkForByteArray=false]
     *
     */

    /**
     * These are the default options for the {@link #asString} function.
     *
     * @type {AsStringOptions}
     */
    const DEFAULT_AS_STRING_OPTIONS =
        {
            omitFunctions: true,
            executeFunctions: false,
            returnFunctionSource: false,
            joinOn: _mt_chr,
            removeLeadingZeroes: true,
            assumeNumeric: false,
            assumeAlphabetic: true,
            dateFormatter: null,
            transformations: [function( s ) { return s;}],
            checkForByteArray: false
        };

    function _executeTransformations( pString, ...pTransformations )
    {
        let s = (_mt_str + pString);

        let prior = (_mt_str + s);

        let transformations = ([].concat( ...pTransformations )).filter( e => isFunction( e ) && e.length > 0 );

        if ( transformations?.length )
        {
            for( let f of transformations )
            {
                try
                {
                    s = f( s );
                }
                catch( ex )
                {
                    if ( isNull( s ) || (_mt_str === (_mt_str + s).trim()) )
                    {
                        s = prior;
                    }
                }

                prior = s;
            }
        }

        return s;
    }

    function getFunctionSource( pFunction )
    {
        return isFunction( pFunction ) ? funcToString.call( pFunction, pFunction ) : isString( pFunction ) ? asString( pFunction, true ) : _mt_str;
    }

    function asUtf8ByteArray( pStr )
    {
        const bytes = [];

        for( let i = 0, n = pStr.length; i < n; i++ )
        {
            let code = pStr.charCodeAt( i );

            if ( code < 0x80 )
            {
                bytes.push( code );
            }
            else if ( code < 0x800 )
            {
                bytes.push( (0xc0 | (code >> 6)), (0x80 | (code & 0x3f)) );
            }
            else if ( code < 0xd800 || code >= 0xe000 )
            {
                bytes.push( (0xe0 | (code >> 12)), (0x80 | ((code >> 6) & 0x3f)), (0x80 | (code & 0x3f)) );
            }
            else
            {
                i++;

                // UTF-16 encodes these using two code units.
                // The actual code point is calculated as follows:
                // ((charCode - 0xD800) << 10 | str.charCodeAt(i) - 0xDC00) + 0x10000
                code = 0x10000 + (((code & 0x3FF) << 10) | (pStr.charCodeAt( i ) & 0x3FF));
                bytes.push( (0xf0 | (code >> 18)), (0x80 | ((code >> 12) & 0x3f)), (0x80 | ((code >> 6) & 0x3f)), (0x80 | (code & 0x3f)) );
            }
        }

        return bytes;
    }

    function fromUtf8ByteArray( pBytes )
    {
        let s = _mt_str;

        for( let i = 0, n = pBytes.length; i < n; i++ )
        {
            let byte = pBytes[i];

            if ( (byte & 0x80) === 0x00 )
            {
                // 1-byte character
                s += String.fromCharCode( byte );
            }
            else if ( (byte & 0xe0) === 0xc0 )
            {
                // 2-byte character
                s += String.fromCharCode( ((byte & 0x1f) << 6) | (pBytes[++i] & 0x3f) );
            }
            else if ( (byte & 0xf0) === 0xe0 )
            {
                // 3-byte character
                s += String.fromCharCode( ((byte & 0x0f) << 12) | ((pBytes[++i] & 0x3f) << 6) | (pBytes[++i] & 0x3f) );
            }
            else if ( (byte & 0xf8) === 0xf0 )
            {
                // 4-byte character (surrogate pair)
                let codePoint = ((byte & 0x07) << 18) | ((pBytes[++i] & 0x3f) << 12) | ((pBytes[++i] & 0x3f) << 6) | (pBytes[++i] & 0x3f);
                codePoint -= 0x10000;
                s += String.fromCharCode( 0xD800 + (codePoint >> 10) );
                s += String.fromCharCode( 0xDC00 + (codePoint & 0x3FF) );
            }
        }

        return s;
    }

    /**
     * Returns a string representation of the argument passed,<br>
     * optionally removing leading and trailing whitespace<br>
     * and performing other transformations as specified in the options.<br>
     *
     * @param {*} pStr - Any valid type for which a string representation is desired
     *
     * @param {boolean} [pTrim=false] - Pass true to return a string with leading and trailing whitespace removed.<br />
     *
     * @param {AsStringOptions} pOptions An object specifying how to handle special circumstances,<br>
     * such as functions, arrays, and objects, as well as additional transformations to perform (such as to lowercase, etc.)<br>
     *
     * @returns {string} a string representation of the argument<br>
     *                   if the argument is already a string, returns a new copy of the string
     *                   if the argument is a number or big integer,
     *                                      attempts to parse the number as a float
     *                                      and then return a string representation of the resulting value
     *                   if the argument is an object,
     *                                   if the object is an Array, joins the asString value of each element
     *                                   if the object is one of the built-in JavaScript types,
     *                                      returns a asString of its canonical string representation
     *                                   if the object defines a toJson method, returns the result of calling that method on the object
     *                                   otherwise, attempts to call JSON.stringify passing the object as the argument
     *                  if the argument is a function, attempts to execute that function and return its result(s) as a asString
     *                  in all other cases, returns an empty string
     *
     *                  if this function is called with 2 arguments and the second argument is truthy,
     *                  the returned value will be trimmed (leading and trailing whitespace is removed)
     */
    const asString = function( pStr, pTrim = false, pOptions = DEFAULT_AS_STRING_OPTIONS )
    {
        // ingest any options passed; specific options override the default options ingested
        const options = Object.assign( Object.assign( {}, DEFAULT_AS_STRING_OPTIONS ), pOptions || {} );

        // capture 'this' in a closure-scoped variable for use in the 'stringify' function below
        const me = asString || this;

        const methodName = "asString";

        let s = _mt_str;

        // allow this function to be added as a method to String.prototype if desired
        if ( isUndefined( pStr ) || isNull( pStr, true ) || arguments.length <= 0 )
        {
            // note that we code this in such a way that it can be bound to the String.prototype as a member function (a.k.a. method)
            if ( (this instanceof String || String === this?.constructor) && isFunction( this.asString ) )
            {
                return me( String( this ).valueOf() || me( this, pTrim ), pTrim );
            }
        }

        let input = _resolveInput.call( this, pStr );

        const transformations = ([].concat( options?.transformations || [] )).filter( e => isFunction( e ) && e.length > 0 );

        // handle the easiest case immediately
        if ( isString( input ) )
        {
            s = pTrim ? input.trim() : input;

            if ( options.assumeNumeric )
            {
                s = input.trim();

                let chars = s.split( _mt_chr );

                if ( options.removeLeadingZeroes )
                {
                    let iterations = 0;

                    while ( chars?.length > 0 && /[\s0]/.test( chars[0] ) && iterations++ < (s?.length || 0) )
                    {
                        chars.shift();
                    }
                }

                s = chars.join( _mt_chr );

                s = s.replace( /\D+$/g, _mt_str );

                try
                {
                    let n = parseFloat( s );
                    s = String( n );
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, "removing non-numeric characters", S_ERROR, (modName + _colon + _colon + methodName), s );
                }
            }

            if ( pTrim )
            {
                return (_mt_str + (s || _mt_str).trim());
            }

            s = _executeTransformations( s, transformations );

            return s;
        }

        // return a value based on the type pf the argument
        switch ( typeof input )
        {
            // double-check the easy case
            case _str:
                s = (_mt_str + (input || _mt_str));
                break;

            // numeric values are converted to the string representation of their float value
            case _num:
            case _big:
                try
                {
                    let n = isBigInt( input ) || !isNanOrInfinite( input ) ? parseFloat( input ) : 0;
                    s = isNanOrInfinite( n ) ? "0" : (_mt_str + n);
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, "trying to interpret " + (_mt_str + input) + " as a number", S_WARN, (modName + _colon + _colon + methodName) );
                }
                break;

            // booleans are converted to either the string "true" or the string "false"
            case _bool:
                s = input ? S_TRUE : S_FALSE;
                break;

            // objects are special case...
            case _obj:
                // if the argument is an array, recursively call this function on each element and join the results on the joinOn option or the empty character
                if ( Array.isArray( input ) )
                {
                    if ( options.checkForByteArray && input.every( e => isNumeric( e ) && toDecimal( e ) ) <= 255 )
                    {
                        s = fromUtf8ByteArray( input.map( e => toDecimal( e ) ) );
                    }
                    else
                    {
                        s = [].concat( ...(input || []) ).map( e => asString( e, pTrim, options ) ).join( (asString( options.joinOn ) || _mt_chr) );
                    }
                    break;
                }

                // handle ObjectWrapper types
                if ( input instanceof Boolean )
                {
                    s = input.valueOf() ? S_TRUE : S_FALSE;
                    break;
                }

                // handle ObjectWrapper types
                if ( input instanceof Number )
                {
                    s = asString( _mt_str + input.valueOf(), pTrim, options );
                    break;
                }

                // handle Dates by converting to the normal local string representation
                // unless a date formatter has been supplied
                if ( input instanceof Date )
                {
                    if ( isFunction( options.dateFormatter ) )
                    {
                        try
                        {
                            s = options.dateFormatter.call( $scope(), input );
                        }
                        catch( ex )
                        {
                            modulePrototype.reportError( ex, "formatting a Date", S_WARN, (modName + _colon + _colon + methodName) );
                            s = input.toISOString();
                        }
                    }
                    else
                    {
                        s = input.toISOString();
                    }
                    break;
                }

                // convert RegExp to their normal string representation
                if ( input instanceof RegExp )
                {
                    s = input.toString();
                    break;
                }

                // if the object defines a toString method, we try that
                if ( isFunction( input?.toString ) )
                {
                    s = input.toString();

                    //if the string representation is the generic string,
                    if ( "[object object]" === lcase( s ) || "Object" === s || isBlank( s ) )
                    {
                        // try to get the value of a name property or the constructor's name
                        // note that this could return undesirable results for objects with a coincidental name property
                        try
                        {
                            s = input?.name || input?.constructor?.name || _mt_str;
                        }
                        catch( ex )
                        {
                            try
                            {
                                s = input?.constructor?.name || _mt_str;
                            }
                            catch( e )
                            {
                                modulePrototype.reportError( e, "obtaining the name of a function", S_WARN, (modName + _colon + _colon + methodName) );
                            }
                        }

                        if ( "[object object]" === lcase( s ) || "Object" === s || isBlank( s ) )
                        {
                            // this is a bit of a hack, but if the JsonUtils are also loaded,
                            // we want to use the asJson function, which can handle circular references
                            let stringify = firstMatchingType( _fun, me.stringify, ($scope()["__BOCK_JSON_UTILS__"] || $scope()["__BOCK_JSON_INTERPOLATION__"])?.asJson, $scope().asJson, JSON.stringify );

                            try
                            {
                                s = isFunction( input?.toJson ) ? (input.toJson() || (stringify || JSON.stringify)( input )) : (stringify || JSON.stringify)( input );
                            }
                            catch( ex )
                            {
                                modulePrototype.reportError( ex, "while converting an object to JSON", S_WARN, (modName + _colon + _colon + methodName) );

                                if ( !isString( s ) || isBlank( s ) )
                                {
                                    const entries = [...(Object.entries( input ) || [])];

                                    s = entries.map( entry => asString( entry[0] ) + ":" + asString( entry[1] ) ).join( _comma );
                                }
                                else if ( lcase( asString( ex.message ) ).includes( "circular" ) )
                                {
                                    s = asString( ex.message );
                                }
                            }
                        }
                    }
                }

                break;

            case _fun:

                if ( !options.omitFunctions )
                {
                    if ( options.executeFunctions )
                    {
                        try
                        {
                            s = input.call( $scope() );
                        }
                        catch( ex )
                        {
                            modulePrototype.reportError( ex, "while executing a function as input to asString", S_WARN, (modName + _colon + _colon + methodName) );

                            s = input?.name || input?.constructor?.name || (options.returnFunctionSource ? getFunctionSource( input ) : _mt_str);
                        }
                    }

                    if ( isBlank( s ) )
                    {
                        try
                        {
                            s = (options.returnFunctionSource ? getFunctionSource( input ) : _mt_str) || input?.name || input?.constructor?.name || _mt_str;
                        }
                        catch( ex )
                        {
                            modulePrototype.reportError( ex, "getting a string representation of a function", S_WARN, (modName + _colon + _colon + methodName) );
                        }
                    }

                    s = asString( s, pTrim, options );
                }
                else
                {
                    s = _mt_str;
                }

                if ( isBlank( s ) )
                {
                    let regExp = /^class/.test( s ) ? /^class/ : /^(async )*function/;

                    if ( regExp.test( s ) )
                    {
                        s = asString( s.replace( regExp, _mt_str ), true, options );

                        let idx = s.indexOf( _spc );

                        if ( idx > 1 )
                        {
                            s = s.slice( 0, idx );
                        }
                        else
                        {
                            idx = s.indexOf( "{" );
                            if ( idx > 1 )
                            {
                                s = s.slice( 0, idx );
                            }
                        }
                    }
                }

                break;

            default:
                s = _mt_str;
                break;
        }

        // if the string is the null-terminator (perhaps the string came from a C-API)
        if ( _z === s )
        {
            return _mt_str;
        }

        return _executeTransformations( _mt_str + ((true === pTrim) ? ((_mt_str + s).trim()) : s), transformations );
    };

    String.prototype.asString = asString;
    Number.prototype.asString = asString;
    Boolean.prototype.asString = asString;

    /**
     * Returns a C-language compatible string
     * by converting the JavaScript String to a C-style String (8 byte chunks, null-terminated)
     * This is necessary when interacting with some C/C++ addons.
     */
    const toCString = function( pString )
    {
        return Buffer.from( `${pString}\0`, "ucs2" );
    };

    /**
     *  Returns a Javascript-compatible string by converting a C-style string into a JavaScript String,
     *  removing null-terminators, for example
     *
     * @param pCString a string (or buffer) believed to be a string in a C-language compatible format
     * @param pLen the length of the string
     * @returns {string} a JavaScript string
     */
    const fromCString = function( pCString, pLen = -1 )
    {
        let buffer = Buffer.from( pCString, "ucs2" );

        let s = buffer.toString();

        // remove the null terminators;
        // Unicode characters may occupy either one or 2 bytes,
        // ordinary ascii string will have _z between each character
        if ( s )
        {
            let chars = s.split( _mt_chr );
            chars = chars.filter( ( c, i ) => (s.charCodeAt( i ) > 0 ? c : _mt_chr) );
            s = chars.join( _mt_chr );
        }

        // if the desired length is known ahead of time, we can also slice the returned (and scrubbed) value
        if ( pLen > 0 )
        {
            s = s.slice( 0, pLen );
        }

        // double-check we have no dangling null-terminators
        while ( s.endsWith( _z ) )
        {
            s = s.replace( /\u0000+$/g, _mt_str );
        }

        // return our glorious JavaScript-compatible character sequence
        return s;
    };

    /**
     * Returns true if the string contains interpolatable variables
     *
     * @param pMsg
     * @returns {*|boolean}
     * @private
     */
    const _containsPlaceholders = function( pMsg )
    {
        return pMsg.includes( "{" ) &&
               pMsg.includes( "}" ) &&
               (/\{\d+}/.test( pMsg ));
    };

    /**
     * Returns a string that contains typical java-like message format placeholders, such as {0}. {1}, etc.
     * with those placeholders replaced by the corresponding elements of the provided array of values
     * @param pMsg a string potentially containing indexed placeholders, such as {0}
     * @param pData an array of values to use when replacing the indexed placeholders
     * @returns {string} a string with placeholders replaced with corresponding elements of the pData array
     * @private
     */
    const _replaceIndexPlaceholders = function( pMsg, ...pData )
    {
        let msg = asString( pMsg, false );

        if ( _containsPlaceholders( msg ) )
        {
            const substitutions = Array.isArray( pData ) ? pData : [pData];

            msg = msg.replace( /{\d+}/g, match => substitutions[parseInt( match.slice( 1, -1 ) )] );
        }

        return msg;
    };

    /**
     * Returns a string with placeholders populated from the second, third, fourth, ... nth arguments
     * @param pMsg a string potentially containing indexed placeholders, such as {0} or {1}
     * @param pData one or more values to use to replace placeholders, the first of these will replace {0}, the second of these will replace {1}, and so on
     * @returns {string} a string with placeholders replaced with the corresponding value specified
     */
    const formatMessage = function( pMsg, ...pData )
    {
        let msg = asString( pMsg, false );

        return _replaceIndexPlaceholders( msg, ...pData );
    };

    function hasUnresolvedVariables( pString )
    {
        return pString.includes( "${" ) && pString.includes( "}" ) && (/\$\{\w+}/.test( pString ));
    }

    /**
     * Returns a string with variables replaced with values found in the specified scope
     * @param pStr a string potentially containing variable tokens, such as ${myVariableName}
     * @param pVariablesMap an object (or scope) defining the variables contained in the string
     *
     * NOTE:  This is equivalent to using template strings `such as ${this}`,
     * but allows the scope to be specified
     *
     * @returns {string} a string with variable tokens replaced by values in the specified map or scope
     */
    const interpolate = function( pStr, pVariablesMap = { ...$scope() } )
    {
        let str = asString( pStr, false );

        if ( hasUnresolvedVariables( str ) )
        {
            let variables = {};

            Object.assign( variables, pVariablesMap || $scope() );

            let entries = (pVariablesMap instanceof Map) ? pVariablesMap.entries() : (_obj === typeof pVariablesMap) ? Object.entries( pVariablesMap ) : [["", ""]];

            for( let [key, value] of entries )
            {
                const k = asString( key, true );

                if ( !isBlank( k ) && !(_ud === typeof value || null === value || _fun === typeof value || _symbol === typeof value || ["global", "this", "self", "window"].includes( k )) )
                {
                    variables[key] = value;
                }
            }

            for( let entry of Object.entries( variables ) )
            {
                str = str.replaceAll( new RegExp( "\\$\\{" + entry[0] + "\\}", "g" ), asString( entry[1], false ) );

                if ( !hasUnresolvedVariables( str ) )
                {
                    break;
                }
            }
        }

        return asString( str, false );
    };

    const DEFAULT_VALID_IDENTIFIER_OPTIONS =
        {
            defaultIdentifier: _underscore
        };

    /**
     * Returns a string that is a valid JavaScript identifier.
     * @see https://developer.mozilla.org/en-US/docs/Glossary/Identifier
     *
     * @param {*} pStr a value to be used as a variable or property name
     * @param pOptions an object to specify how to handle unusual cases
     */
    const validIdentifier = function( pStr, pOptions = DEFAULT_VALID_IDENTIFIER_OPTIONS )
    {
        const options = Object.assign( Object.assign( {}, DEFAULT_VALID_IDENTIFIER_OPTIONS ), pOptions || {} );

        let s = asString( pStr, true ).trim();

        if ( isBlank( s ) )
        {
            return options?.defaultIdentifier || _underscore;
        }

        let chars = s.split( _mt_chr );

        while ( chars.length && !(/[A-Za-z$_]/.test( chars[0] )) )
        {
            chars.shift();
        }

        s = chars.join( _mt_chr );

        s = s.replaceAll( /[^A-Za-z$_]/g, _mt_str );

        if ( isBlank( s ) || RESERVED_WORDS.includes( s ) )
        {
            return options?.defaultIdentifier || _underscore;
        }

        return asString( s, true );
    };

    const DEFAULT_AS_KEY_OPTIONS = { supportDotNotation: false, defaultIdentifier: _underscore };

    /**
     * Returns a string that can be used as a key in a map or map-like structure, such as an object literal
     * Note that just about any string can be a key and that integers can be used as keys (that is in fact, part of how Array is implemented)
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_Types#object_literals
     *
     * @param {*} pStr
     * @param {Object} pOptions
     */
    const asKey = function( pStr, pOptions = DEFAULT_AS_KEY_OPTIONS )
    {
        const options = populateOptions( pOptions, DEFAULT_AS_KEY_OPTIONS );

        let s = asString( pStr, true );

        if ( isBlank( s ) || RESERVED_WORDS.includes( s ) )
        {
            return options?.defaultIdentifier || _underscore;
        }

        const validName = validIdentifier( s, options );

        if ( s === validName )
        {
            return s;
        }

        if ( s.includes( _dot ) && options.supportDotNotation )
        {
            let keys = s.split( _dot );

            keys = keys.map( e => (asKey( e )) );

            s = keys.join( _dot );

            return _dblqt + s + _dblqt;
        }

        const validIndex = isObject( pStr ) || /[^\d,.\sA-FXx]/.test( s ) ? "-1" : asInt( s, 0 );

        if ( asString( validIndex, true ) === s )
        {
            return parseInt( s );
        }

        return _dblqt + s.replaceAll( /[\W$_]/g, _mt_str ) + _dblqt;
    };


    /**
     * Returns true if the string representation of the argument is specifically the empty string
     * @param {any} pStr - a string or object to check for emptiness
     * @returns {boolean} true if the string representation of the argument is the empty string
     */
    const isEmpty = function( pStr )
    {
        return (_mt_str === asString( pStr, false )) || (_z === pStr) || (asString( pStr, false )?.length || 0) <= 0;
    };

    /**
     * Returns true if the string representation of the argument is the empty string or only whitespace characters
     * @param {any} pStr - a string or object to check for emptiness
     * @returns {boolean} true if the string representation of the argument is the empty string or only whitespace characters
     */
    const isBlank = function( pStr )
    {
        return (_mt_str === asString( pStr, true ).trim()) || (_z === pStr);
    };

    const DEFAULT_IS_CAPS_OPTIONS =
        {
            allowWhitespace: true,
            allowDigits: false
        };

    /**
     * Returns true if every character in the specified string is an UPPERCASE letter
     * @param pStr a string to test for all capital letters
     * @param pOptions an object defining how to treat whitespace and digits
     * @returns {boolean} true if the string specified consists solely of UPPERCASE letters
     */
    const isAllCaps = function( pStr, pOptions )
    {
        const options = Object.assign( Object.assign( {}, DEFAULT_IS_CAPS_OPTIONS ), pOptions || {} );

        const str = asString( pStr, options.allowWhitespace );

        const hasLowerCase = options.allowDigits ? /[a-z]/.test( str ) : /[a-z0-9]/.test( str );

        return !hasLowerCase;
    };

    /**
     * Returns true if **NO** character in the specified string is an UPPERCASE letter
     * @param pStr a string to test for the presence of capital letters
     * @returns {boolean} true if the string specified consists solely of lowercase letters or numbers
     */
    const isNoCaps = function( pStr )
    {
        const str = asString( pStr, true );
        return !(/[A-Z]/.test( str ));
    };

    /**
     * Returns a substring not longer than pMaxLength
     * @param pStr the string to (potentially) truncate to the specified length
     * @param pMaxLength the length to which to truncate the string
     * @returns {string}
     */
    function truncate( pStr, pMaxLength = -1 )
    {
        let s = asString( pStr );

        const maxLength = asInt( pMaxLength, -1 );

        if ( maxLength >= 0 )
        {
            return s.slice( 0, Math.min( maxLength, s.length ) );
        }

        return s;
    }

    /**
     * Returns true if the specified string contains both UPPERCASE and lowercase letters
     * @param pStr a string to test for mixed case characters
     * @returns {boolean} true if the string specified contains both UPPERCASE and lowercase letters
     */
    const isMixedCase = function( pStr )
    {
        const str = asString( pStr, true );
        return /[A-Z]/.test( str ) && /[a-z/]/.test( str );
    };

    function appendEllipsis( pStr, pMaxLength = -1, pEllipsis = _ellipsis )
    {
        let s = asString( pStr );

        const ellipsis = asString( pEllipsis ) || _ellipsis;

        const ellipsisLength = (ellipsis?.length || 3);

        const defaultMaxLength = (s?.length || 0) + ellipsisLength;

        let maxLength = asInt( pMaxLength, defaultMaxLength );
        maxLength = Math.max( (maxLength > 0 ? maxLength : defaultMaxLength), ellipsisLength );

        if ( ((s + ellipsis)?.length || 0) <= maxLength )
        {
            s += (ellipsis || _mt_str);
        }
        else
        {
            s = s.slice( 0, Math.min( s.length, Math.max( 1, (maxLength - ellipsisLength) ) ) );
            s += ellipsis;
        }

        return truncate( s, pMaxLength );
    }

    function prependEllipsis( pStr, pMaxLength = -1, pEllipsis = _ellipsis )
    {
        let s = asString( pStr );

        const ellipsis = asString( pEllipsis ) || _ellipsis;

        const ellipsisLength = (ellipsis?.length || 3);

        const defaultMaxLength = ellipsisLength + (s?.length || 0);

        let maxLength = asInt( pMaxLength, defaultMaxLength );
        maxLength = Math.max( (maxLength > 0 ? maxLength : defaultMaxLength), ellipsisLength );

        if ( ((ellipsis + s)?.length || 0) <= maxLength )
        {
            s = (ellipsis || _mt_str) + s;
        }
        else
        {
            s = ellipsis + s.slice( 0, Math.min( s.length, Math.max( 1, (maxLength - ellipsisLength) ) ) );
        }

        return truncate( s, pMaxLength );
    }

    /**
     * Returns the number of times a specified substring appears in the specified string
     *
     * @param pStr {string} string possibly containing one or more occurrences of substring
     * @param pSubstring {string} the sequence of one or more characters  to count
     * @returns {number} the number of times the substring appears in the string
     */
    const occurrencesOf = function( pStr, pSubstring )
    {
        let s = asString( pStr );
        let s1 = asString( pSubstring );

        const arr = s.split( s1 );

        return arr.length - 1;
    };

    function reconcileTheString( pString )
    {
        return asString( asString( pString, false ) || ((this instanceof String) ? this.valueOf() : _mt_str) || _resolveInput.call( this, pString ) );
    }

    /**
     * Returns the text to the left of the FIRST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the left
     * @param pOf a string or number specifying the position after which to discard the rest of the string

     * @returns the text to the left of the FIRST occurrence of pOf
     * (or if pOf is a number, the index specified by pOf)
     * If pOf is not included in the specified string, returns the original string
     */
    const leftOf = function( pString, pOf )
    {
        let s = reconcileTheString.call( this, pString );

        const typeOf = typeof pOf;

        const pos = (_str === typeOf) ? s.indexOf( pOf ) : asInt( pOf, s?.length );

        if ( 0 <= pos )
        {
            s = s.substring( 0, pos );
        }

        return s;
    };

    /**
     * Returns the text to the right of the FIRST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the right
     * @param pOf a string or number specifying the position prior to which to discard a portion of the string
     * @returns the text to the right of the FIRST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     */
    const rightOf = function( pString, pOf )
    {
        let s = reconcileTheString.call( this, pString );

        const typeOf = typeof pOf;

        const pos = (_str === typeOf) ? s.indexOf( pOf ) : asInt( pOf, s?.length );

        if ( 0 <= pos )
        {
            s = s.slice( pos + ((_str === typeOf) ? pOf.length : 1), s.length );
        }

        return s;
    };

    /**
     * Returns the text to the left of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the left
     * @param pOf a string or number specifying the position after which to discard the rest of the string
     * @returns the text to the left of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     */
    const leftOfLast = function( pString, pOf )
    {
        let s = reconcileTheString.call( this, pString );

        const typeOf = typeof pOf;

        const pos = (_str === typeOf) ? s.lastIndexOf( pOf ) : asInt( pOf, s?.length );

        if ( 0 <= pos )
        {
            s = s.substring( 0, pos );
        }

        return s;
    };

    /**
     * Returns the text to the right of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the right
     * @param pOf a string or number specifying the position prior to the string to return
     * @returns the text to the right of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     */
    const rightOfLast = function( pString, pOf )
    {
        let s = reconcileTheString.call( this, pString );

        const typeOf = typeof pOf;

        const pos = (_str === typeOf) ? s.lastIndexOf( pOf ) : asInt( pOf, s?.length );

        if ( 0 <= pos )
        {
            s = s.slice( pos + ((_str === typeOf) ? pOf.length : 1), s.length );
        }

        return s;
    };

    const isJson = function( pStr )
    {
        if ( !isString( pStr ) || isBlank( pStr ) )
        {
            return isNumber( pStr );
        }

        const str = tidy( asString( pStr, true ) ).trim().replace( /^[ \n\r]+/, _mt_str ).replace( /[ \n\r]+$/, _mt_str );

        const chars = (str.split( _mt_chr ));

        if ( chars.length > 1 )
        {
            if ( ("[" === chars[0]) && ("]" === chars[chars.length - 1]) )
            {
                return true;
            }

            if ( ("{" === chars[0]) && ("}" === chars[chars.length - 1]) )
            {
                return true;
            }

            if ( _dblqt === chars[0] && _dblqt === chars[chars.length - 1] )
            {
                return true;
            }

            if ( _sglqt === chars[0] && _sglqt === chars[chars.length - 1] )
            {
                return true;
            }

            if ( "null" === str || "void" === str || "undefined" === str || isNumber( str ) || !(/[^0-9-.]+/.test( str )) )
            {
                return true;
            }
        }

        return false;
    };

    /**
     * Returns a string with all leading instances of the specified character removed
     * @param pStr a string from which to remove one or more leading instances of the specified character
     * @param pChar a single character to remove (recursively) from the start of the string,
     *              defaults to "0" to remove leading zeroes from would-be decimal numbers
     * @returns {string} a string with all leading instances of the specified character removed
     */
    const trimLeadingCharacters = function( pStr, pChar = "0" )
    {
        let char = asString( pChar ) || "0";

        let str = asString( pStr, true );

        while ( str.startsWith( char ) && str.length > 1 )
        {
            str = str.slice( 1 );
        }

        return str;
    };

    let DEFAULT_TRIM_MATCHING_OPTIONS = { leading: true, trailing: true, anywhere: false, case_sensitive: true };

    const trimMatchingChars = function( pStr, pRegExpOrChar = _spc, pOptions = DEFAULT_TRIM_MATCHING_OPTIONS )
    {
        const options = Object.assign( Object.assign( {}, DEFAULT_TRIM_MATCHING_OPTIONS ), pOptions || DEFAULT_TRIM_MATCHING_OPTIONS );

        let s = asString( pStr );

        let flags = (options.anywhere ? "g" : _mt_str) + (options.case_sensitive ? _mt_chr : "i");

        let regExp = pRegExpOrChar instanceof RegExp ? new RegExp( pRegExpOrChar, flags ) : new RegExp( asString( pRegExpOrChar ), flags );

        if ( isString( pRegExpOrChar ) && /^\//.test( pRegExpOrChar ) && /\/$/.test( pRegExpOrChar ) )
        {
            regExp = new RegExp( pRegExpOrChar.replace( /\/$/, _mt_str ).replace( /^\//, _mt_str ).replace( /\/$/, _mt_str ), flags );
        }

        if ( regExp && regExp instanceof RegExp )
        {
            if ( options.anywhere )
            {
                s = s.replaceAll( regExp, _mt_str );
            }

            if ( options.leading )
            {
                s = s.replace( new RegExp( "^" + regExp.source, flags ), _mt_str );
            }

            if ( options.trailing )
            {
                s = s.replace( new RegExp( regExp.source + "$", flags ), _mt_str );
            }
        }

        return s;
    };

    const calculateDecimalSymbols = function( pLocale, pCurrency )
    {
        let locale = (pLocale instanceof Intl.Locale) ? (pLocale?.baseName || "en_US") : isNull( pLocale ) || isBlank( pLocale ) ? asString( (((new Intl.NumberFormat()).resolvedOptions())?.locale)?.baseName ) || "en-US" : asString( pLocale );

        let currency = isNull( pCurrency ) || isBlank( pCurrency ) ? "USD" : asString( pCurrency || "USD" );

        const numberFormatter = new Intl.NumberFormat( (asString( locale ) || "en-US"),
                                                       {
                                                           style: "currency",
                                                           currency: currency
                                                       } );

        const parts = numberFormatter.formatToParts( 123_456.789 );

        const symbols = { ...DEFAULT_NUMBER_SYMBOLS };

        parts.forEach( part =>
                       {
                           const type = lcase( asString( part?.type, true ) );
                           const val = asString( part?.value );

                           switch ( type )
                           {
                               case "currency":
                                   symbols.currency_symbol = val || DEFAULT_NUMBER_SYMBOLS.currency_symbol;
                                   break;

                               case "decimal":
                                   symbols.decimal_point = val || DEFAULT_NUMBER_SYMBOLS.decimal_point;
                                   break;

                               case "group":
                                   symbols.grouping_separator = val || DEFAULT_NUMBER_SYMBOLS.grouping_separator;
                                   break;

                               default:
                                   break;
                           }

                       } );

        return lock( symbols ) || DEFAULT_NUMBER_SYMBOLS;
    };

    /**
     * Returns an array of the lengths of the segments of the value separating by the grouping separator
     *
     * @param pFormattedNumber {string|number} the number to use to derive the group sizes
     * @param pGroupingSeparator {string} the character(s) used to separate powers-of-ten groups
     * @returns {[number]} an array of the lengths of the segments of the value separating by the grouping separator
     *
     * Notably, this might return something like [2,2,3] for a value formatted according to the Indian Numbering System
     *
     * @private
     */
    function _deriveGroupingSize( pFormattedNumber, pGroupingSeparator )
    {
        const s = asString( pFormattedNumber );
        const parts = s.split( pGroupingSeparator || _comma );
        return parts.map( e => e?.length || 0 );
    }

    const deriveDecimalSymbols = function( pNumString, pOptions = calculateDecimalSymbols() )
    {
        const options = Object.assign( {}, pOptions || DEFAULT_NUMBER_SYMBOLS );

        let s = asString( pNumString );

        let decimalPoint = options.decimal_point || _dot;
        let groupingSeparator = options.grouping_separator || _comma;

        let decimalCount = occurrencesOf( s, decimalPoint );
        let groupCount = occurrencesOf( s, groupingSeparator );

        let groupingSizes = [].concat( _deriveGroupingSize( s.trim(), groupingSeparator ) || [] );
        let lastGroupSize = groupingSizes?.length > 0 ? groupingSizes[groupingSizes.length - 1] : 0;

        if ( (decimalCount > 1 && groupCount <= 1) || (lastGroupSize > 0 && lastGroupSize < 3) )
        {
            const parts = s.split( decimalPoint );
            s = parts.join( _mt_chr ).replaceAll( groupingSeparator, _dot ).replaceAll( decimalPoint, _dot );

            options.grouping_separator = decimalPoint;
            options.decimal_point = groupingSeparator;
        }

        const obj =
            {
                corrected_value: s,
                decimal_point: options.decimal_point || _dot,
                grouping_separator: options.grouping_separator || _comma,
                currency_symbol: options.currency_symbol || "$",
                original_value: asString( pNumString )
            };

        return lock( obj );
    };

    /**
     * Returns a string representing a numeric value with the grouping separator(s) removed,
     * currency symbol removed,
     * the bigint literal 'n' removed
     * and the decimal symbol replaced with a dot (.)
     *
     * @param pInput {string|number} the string (or number) to clean
     * @param pOptions {Object} (optional) an object identifying the characters used for the grouping separator, decimal point, and currency
     * @returns {string} a string representing a numeric value with the grouping separator(s) removed,
     * currency symbol removed,
     * the bigint literal 'n' removed
     * and the decimal symbol replaced with a dot (.)
     */
    function toCanonicalNumericFormat( pInput, pOptions = calculateDecimalSymbols() )
    {
        const options = populateOptions( pOptions, DEFAULT_NUMBER_SYMBOLS );

        let s = asString( pInput );

        let {
            corrected_value,
            decimal_point,
            grouping_separator,
            currency_symbol
        } = deriveDecimalSymbols( s, options );

        s = asString( corrected_value );

        let groupingSeparator = grouping_separator || options.grouping_separator || _comma;

        if ( asString( groupingSeparator ) === asString( options.grouping_separator || groupingSeparator ) )
        {
            s = s.replaceAll( groupingSeparator, _mt_str );
        }

        let decimalPoint = decimal_point || options.decimal_point || _dot;

        if ( asString( decimalPoint ) === asString( options.decimal_point || decimalPoint ) )
        {
            s = s.replace( decimalPoint, _dot );
        }

        let currencySymbol = currency_symbol || options.currency_symbol || /\$|USD/;

        s = asString( s.replace( /n+$/, _mt_str ).replace( currencySymbol, _mt_str ), true );

        s = s.replaceAll( /\s*[^\dXxOoA-F.,+-]/gi, _mt_str );

        s = startsWithAny( s, _dot, _comma ) ? ("0" + s) : s;

        s = s.replace( /^0{2,}/, "0" );

        return asString( s, true );
    }

    function _calculateRadix( pNum )
    {
        let input = asString( pNum, true );

        if ( input.startsWith( "0" ) || includesAny( lcase( input ), "b", "o", "x" ) || /\D/.test( input ) )
        {
            return (isHex( input ) ? 16 : ((isOctal( input ) ? 8 : (isBinary( input ) ? 2 : 10))));
        }

        return 10;
    }

    /**
     * Returns an integer value represented or implied by the value provided
     * @param {any} pValue a number or string representing a number
     * @param {number} pDefault a number to return if the value cannot be interpreted as a number
     *
     * NOTE: when converting floating point number to an integer, we round using half_even rounding
     *
     * @param pOptions
     * @returns {number} an integer value represented by or implied by the value provided
     */
    const asInt = function( pValue, pDefault = 0, pOptions = calculateDecimalSymbols() )
    {
        const zero = 0;

        const input = _resolveInput.call( this, pValue );

        const dflt = isNumber( pDefault ) || isString( pDefault ) ? pDefault : 0;

        const options = populateOptions( (isObject( pDefault ) ? pDefault : pOptions), DEFAULT_NUMBER_SYMBOLS );

        const type = typeof input;

        if ( isNull( input ) )
        {
            return asInt( dflt, zero, options );
        }

        function warnValueOutOfRange( pInput, pSource = AS_INT )
        {
            const msg = ["asInt cannot return values greater than", Number.MAX_SAFE_INTEGER, "or less than", Number.MIN_SAFE_INTEGER, _dot, _spc, (pInput || input || "the specified value"), "cannot be converted to an Integer"].join( _spc );

            modulePrototype.reportError( new IllegalArgumentError( msg ), msg, S_WARN, (modName + _colon + _colon + (pSource || AS_INT)) );
        }

        let radix = _calculateRadix( input );

        if ( [_num, _big].includes( type ) )
        {
            if ( isNanOrInfinite( input ) )
            {
                return asInt( dflt, zero, options );
            }

            if ( _big === type && (input > Number.MAX_SAFE_INTEGER || input < Number.MIN_SAFE_INTEGER) )
            {
                warnValueOutOfRange( input );

                return asInt( dflt, zero, options );
            }

            const val = parseInt( (input).toFixed( 0 ) );

            if ( isNanOrInfinite( val ) )
            {
                return asInt( dflt, zero, options );
            }

            return val;
        }

        if ( _bool === type )
        {
            return input ? 1 : zero;
        }

        let val = zero;

        let canonical = toCanonicalNumericFormat( input, options );

        if ( 10 === radix )
        {
            canonical = trimLeadingCharacters( input, "0" );
            canonical = startsWithAny( canonical, _dot, _comma ) ? "0" + canonical : canonical;
        }

        try
        {
            val = parseInt( canonical.replace( /^0[box]/i, _mt_str ), radix );

            if ( isNanOrInfinite( val ) )
            {
                val = asInt( dflt, zero, options );
            }

            try
            {
                const asBig = 10 === radix ? BigInt( canonical ) : BigInt( val );

                if ( asBig < val || asBig > val )
                {
                    warnValueOutOfRange( input );

                    return asInt( dflt, zero, options );
                }
            }
            catch( ex2 )
            {
                // ignore this one
            }
        }
        catch( ex )
        {
            modulePrototype.reportError( ex, "trying to interpret '" + asString( pValue || input ) + "' as a number", S_WARN, (modName + _colon + _colon + AS_INT) );
        }

        return val || zero;
    };

    String.prototype.asInt = asInt;
    Number.prototype.asInt = asInt;
    Boolean.prototype.asInt = asInt;

    /**
     * Returns a floating-point value represented or implied by the value provided
     * @param {any} pValue a value we expect to convertible to a float
     * @param {number} pDefault a value to return if pValue cannot be converted to a valid float
     * @param pOptions
     * @returns {number} an floating-point value represented or implied by the value provided
     */
    const asFloat = function( pValue, pDefault = 0, pOptions = calculateDecimalSymbols() )
    {
        const zero = 0.0;
        const one = 1.0;

        const input = _resolveInput.call( this, pValue );

        const dflt = isNumber( pDefault ) || isString( pDefault ) ? pDefault : 0;

        const options = Object.assign( {}, (isNonNullObject( pOptions ) ? pOptions : (isNonNullObject( pDefault ) ? pDefault : pOptions)) || calculateDecimalSymbols() );

        const type = typeof input;

        if ( isNull( input ) )
        {
            return asFloat( dflt, zero, options );
        }

        let radix = _calculateRadix( input );

        let canonical = toCanonicalNumericFormat( input, options );

        if ( canonical.startsWith( "0" ) && 10 === radix )
        {
            canonical = trimLeadingCharacters( input, "0" );
            canonical = startsWithAny( canonical, _dot, _comma ) ? "0" + canonical : canonical;
        }

        if ( _big === type )
        {
            return asInt( canonical, dflt, options );
        }

        if ( _num === type )
        {
            const val = parseFloat( canonical );

            if ( isNanOrInfinite( val ) )
            {
                return asFloat( dflt, zero, options );
            }

            return val;
        }

        if ( _bool === type )
        {
            return input ? one : zero;
        }

        let val = zero;

        try
        {
            if ( 10 === radix )
            {
                val = parseFloat( canonical );
            }
            else
            {
                let parts = canonical.split( _dot );

                let intPart = (parts?.length || 0) > 0 ? parts[0] : input;

                let decPart = (parts?.length || 0) > 1 ? parts[1] : _mt_str;

                val = asInt( intPart, 0, options );

                if ( !isBlank( decPart ) )
                {
                    let digits = decPart.split( _mt_chr );
                    val = digits.reduce( ( sum, digit, index ) => sum + parseInt( digit, radix ) * Math.pow( radix, -(index + 1) ), val );
                }
            }

            if ( isNanOrInfinite( val ) )
            {
                val = asFloat( dflt, zero, options );
            }
        }
        catch( ex )
        {
            modulePrototype.reportError( ex, "trying to interpret '" + asString( pValue || input ) + "' as a number", S_WARN, (modName + _colon + _colon + AS_INT) );
        }

        return val || zero;
    };

    String.prototype.asFloat = asFloat;
    Number.prototype.asFloat = asFloat;
    Boolean.prototype.asFloat = asFloat;

    const asPositiveInt = function( pStr )
    {
        return Math.max( 0, asInt( pStr ) );
    };

    const asPositiveFloat = function( pStr )
    {
        return Math.max( 0.0, asFloat( pStr ) );
    };

    const toIntWithinRange = function( pStr, pMin, pMax, pOptions = calculateDecimalSymbols() )
    {
        const options = Object.assign( {}, pOptions || calculateDecimalSymbols() );

        const value = asInt( pStr, 0, options );

        const minimum = asInt( pMin, 0, options );
        const maximum = asInt( pMax, 0, options );

        const greatest = Math.max( minimum, maximum );
        const smallest = Math.min( minimum, maximum );


        return Math.min( greatest, Math.max( smallest, value ) );
    };

    const toFloatWithinRange = function( pStr, pMin, pMax, pOptions = calculateDecimalSymbols() )
    {
        const options = Object.assign( {}, pOptions || calculateDecimalSymbols() );

        const value = asFloat( pStr, 0, options );

        const minimum = asFloat( pMin, 0, options );
        const maximum = asFloat( pMax, 0, options );

        const greatest = Math.max( minimum, maximum );
        const smallest = Math.min( minimum, maximum );

        return Math.min( greatest, Math.max( smallest, value ) );
    };

    /**
     * Returns the specified value if it is >= 0 and < the length of the specified indexed object
     *                                                               (such as an Array or String)
     * @param {number} pIndex - candidate value to return
     * @param {*} pIndexed - an object with a length property that represents an ability to address its properties via a numeric value for which pIndex will be used
     * @param {Object} pOptions - a set of options to control subtle behaviors of the function, such as whether 0 or the last valid index is returned when the provided index is invalid
     * @returns {number} a number between 0 and one less than the length of the indexed object (i.e., Array or String)
     */
    const safeIndex = function( pIndex, pIndexed, pOptions = { defaultToEnd: false } )
    {
        const zero = 0;
        const one = 1;

        const arr = pIndexed || [];

        const maxIdx = Math.max( zero, (Math.min( (pOptions?.max || (arr?.length || zero)), ((arr?.length || zero) - one) )) );

        const minIdx = Math.max( zero, (pOptions?.min || -(one)) );

        const idx = asInt( (isNumber( pIndex ) ? pIndex : asInt( pIndex )), (pOptions?.defaultToEnd ? maxIdx : minIdx) );

        if ( (arr?.length || zero) > idx )
        {
            return Math.max( minIdx, Math.min( idx, maxIdx ) );
        }

        if ( pOptions?.defaultToEnd )
        {
            return Math.min( arr?.length || 0, maxIdx );
        }

        return Math.max( minIdx, Math.min( (pOptions?.defaultToEnd ? maxIdx : zero) ) );
    };

    /**
     * Returns true if the string ends with any of the character sequences in the array
     * @param {string} pStr - a string to check for endings (the caller is responsible for removing whitespace if desired)
     * @param {[string]} pArr - one or more strings with which the string might end
     * @returns true if the string ends with any of the character sequences in the array
     */
    const endsWithAny = function( pStr, ...pArr )
    {
        const s = asString( pStr, false );

        const arr = [].concat( ...(pArr || []) );

        return arr?.length > 0 ? arr.some( e => s.endsWith( e ) ) : isEmpty( s );
    };

    /**
     * Returns true if the string starts with any of the character sequences in the array
     * @param {string} pStr - a string to evaluate (the caller is responsible for removing whitespace if desired)
     * @param {...string} pArr - one or more strings with which the string might begin or regular expressions against which to test the string
     * @returns true if the string begins with any of the character sequences in the array
     */
    const startsWithAny = function( pStr, ...pArr )
    {
        const s = asString( pStr, true );

        const arr = [].concat( ...(pArr || []) );

        return arr?.length > 0 ? arr.some( e => (e instanceof RegExp) ? e.test( s ) : s.startsWith( e ) ) : isEmpty( s );
    };

    /**
     * Returns true if the string contains any of the character sequences in the array
     * @param {string} pStr - a string to check for substrings (the caller is responsible for removing whitespace if desired)
     * @param {...string} pArr - one or more strings that the string might include
     * @returns true if the string includes any of the character sequences in the array
     */
    const includesAny = function( pStr, ...pArr )
    {
        const s = asString( pStr, false );

        const arr = [].concat( ...(pArr || []) );

        return arr?.length > 0 ? arr.some( e => s.includes( e ) ) : isEmpty( s );
    };

    /**
     * Returns true if the string includes ALL the character sequences in the array
     * @param {string} pStr - a string to check for substrings (the caller is responsible for removing whitespace if desired)
     * @param {[string]} pArr - one or more strings that the string must include
     * @returns true if the string includes ALL the character sequences in the array
     */
    const includesAll = function( pStr, ...pArr )
    {
        const s = asString( pStr, false );

        const arr = [].concat( ...(pArr || []) );

        return arr?.length > 0 ? arr.every( e => s.includes( e ) ) : isEmpty( s );
    };

    /**
     * Returns true if the value specified can be interpreted as an affirmative.
     * Used to allow configuration properties to be specified or obtained as strings, numbers, or even functions that return a truthy value
     * If the value specified is a function, the second parameter allows the caller to pass arguments to that function.
     *
     * @param {any} pValue the value or object to evaluate as a boolean (often a string)
     * @param  {...any} pFunctionArgs arguments to pass to the value being evaluated, if that value is a "function"
     * @returns {boolean} true if the value specified can be interpreted as an affirmative (or is a function that when called returns a "truthy" value)
     */
    const evaluateBoolean = function( pValue, ...pFunctionArgs )
    {
        let val = pValue;

        if ( _ud === typeof pValue )
        {
            if ( ((this instanceof Boolean || Boolean === this?.constructor || this === Boolean.prototype)) )
            {
                val = this.valueOf();
            }
        }

        // missing values are always interpreted as negatives (false)
        if ( (_ud === typeof val) || (undefined === val) || (null == val) || (_z === val) || false === val )
        {
            return false;
        }

        // boolean values are already true or false, so just return the value
        if ( _bool === typeof val || true === val )
        {
            return val;
        }

        // if the value is a string, we check to see if it is one of the strings defined to represent an affirmative (truthy) value
        if ( isString( val ) )
        {
            const value = lcase( tidy( val, {} ) );

            return !isBlank( value ) && _affirmatives.includes( value );
        }

        // if the value is a number, we consider any value > 0 to be a truthy value; note that NaN is considered false
        if ( _num === typeof val )
        {
            const value = parseFloat( val );

            if ( !isNaN( value ) )
            {
                return value > 0;
            }

            return false;
        }

        // if the value is a function, we try to invoke it with any arguments passed and return the result of evaluating its return value
        if ( _fun === (typeof val) )
        {
            try
            {
                return evaluateBoolean( val( ...(pFunctionArgs || []) ), ...(pFunctionArgs || []) );
            }
            catch( ex )
            {
                const msg = "trying to determine the verity of '" + (val?.name || asString( val )) + "' with arguments " + (pFunctionArgs || []).join( _comma );
                modulePrototype.reportError( ex, msg, S_ERROR, (modName + _colon + _colon + "evaluateBoolean") );
                return false;
            }
        }

        // if the value is an object, we return true if any of its properties evaluate to true;
        // note that this is an unexpected case at present, but exists to catch all argument types the function may encounter
        if ( _obj === typeof val )
        {
            if ( Array.isArray( val ) )
            {
                for( let i = val.length; i--; )
                {
                    if ( evaluateBoolean( val[i] ) )
                    {
                        return true;
                    }
                }
            }
            else
            {
                for( const prop in val )
                {
                    if ( Object.hasOwn( val, prop ) )
                    {
                        if ( evaluateBoolean( val[prop] ) )
                        {
                            return true;
                        }
                    }
                }
            }
        }

        return false;
    };

    const isTrue = evaluateBoolean;
    const toBool = evaluateBoolean;

    Boolean.prototype.evaluate = evaluateBoolean;

    /**
     * This function converts all (carriage return + line feed) sequences to line feed only sequences
     * @returns {string} a string where new lines are delimited by line feed characters only (without an extraneous carriage return character)
     * @param {String} s a string representing a path or path-like value whose line feeds will be converted
     */
    const toUnixLinebreaks = function( s )
    {
        let val = asString( s );

        let out = (asString( val )).replace( /(\r\n)/g, _lf );

        out = out.replaceAll( /(\n\r)/g, _lf );

        out = out.replaceAll( /[\n\r]/g, _lf );

        return out;
    };

    /**
     * This function converts all line-feed only sequences to (carriage return + line feed) sequences
     * @returns {string} a string where new lines are delimited by (carriage return + line feed) characters
     * @param {string} s - a string representing a path or path-like value whose line feeds will be converted
     */
    const toWindowsLinebreaks = function( s )
    {
        let val = asString( s );

        val = toUnixLinebreaks( val );

        return (asString( val )).replace( /\n/g, _crlf );
    };

    /**
     * Returns a filepath formatted for Linux or Unix
     * @param pPath a filepath, possibly in Windows format, to be transformed to a Unix-compatible filepath
     * @returns {string} a filepath formatted for Linux or Unix
     */
    const toUnixPath = function( pPath )
    {
        // trim any leading or trailing whitespace
        let path = asString( pPath, true );

        // replace any newline characters with a space character
        path = path.replace( /(\r\n)|(\n)/g, _spc );

        // replace backslash with forward slash
        // and replace any duplicated path separators with a single separator
        path = path.replace( /[\\\/]/g, "/" ).replace( /\/\//g, "/" );

        // escape any spaces in the path name
        path = path.replace( / /g, "\ " );

        // replace any duplicated path separators with a single separator
        path = path.replace( /\/\//g, "/" );

        return path.trim();
    };

    /**
     * Returns true if the specified path is expressed as relative to another path.
     * That is, this returns true if the path includes ./ or ../
     * @param {string} pPath a string representing a filepath that may or may not be relative to another path
     * @returns {boolean} true if the path includes ./ or ../
     */
    const isRelativePath = function( pPath )
    {
        let filepath = toUnixPath( pPath );

        return filepath.includes( _unixThisDir ) || filepath.includes( _unixPrevDir ) || filepath.startsWith( _dot );
    };

    /**
     * Returns an absolute filepath to the file or directory specified by pPath.
     * NOTE: This is equivalent to the node::path join or normalize functions,
     * but takes only 2 arguments and the second is assumed to represent an absolute path to the root directory
     *
     * @param {string} pPath a filepath relative to the root path
     * @param {string} pRootPath an absolute filepath to the root directory of the device on which this code is running
     * @returns {string|*} an absolute path to the file or directory specified by pPath
     */
    const toAbsolutePath = function( pPath, pRootPath )
    {
        let rootPath = toUnixPath( asString( pRootPath, true ) ) || __dirname;
        let filepath = toUnixPath( asString( pPath, true ) ) || __dirname;

        let root = rootPath.split( _slash );
        let path = filepath.split( _slash );

        let filePathParts = [];

        for( let i = path.length; i--; )
        {
            const s = path[i];

            if ( !root.includes( s ) )
            {
                filePathParts.unshift( s );
            }
            else
            {
                filePathParts.unshift( _dot + _dot );
            }
        }

        filepath = filePathParts.join( _slash );

        if ( filepath.startsWith( rootPath ) )
        {
            filepath = toUnixPath( filepath.replace( rootPath, _mt_str ) );
        }

        if ( !isRelativePath( filepath ) )
        {
            return toUnixPath( rootPath + "/" + filepath.replace( new RegExp( "^" + rootPath ), _mt_str ) );
        }

        const thisDir = _unixThisDir;

        // replace relative reference to the current directory
        while ( filepath.startsWith( thisDir ) && filepath.length >= thisDir.length )
        {
            // just remove the current directory reference, because we are going to prepend the base directory it represents
            filepath = filepath.length > thisDir.length ? filepath.slice( thisDir.length ) : _mt_str;
        }

        let dirs = [].concat( (rootPath.split( _unixPathSep ) || []) ).concat( (filepath.split( _unixPathSep ) || []) ).filter( e => !isBlank( e ) );

        // the ".." sequence means the directory one level prior, so...
        // every time we find this, we will remove that array element and the previous array element
        // unless there is no previous array element, which means we have reached the root
        let idx = dirs.indexOf( _dot + _dot );

        function moreDirectoriesToProcess( idx, dirs )
        {
            return idx >= 0 && (idx < dirs.length) && (dirs.length > 1);
        }

        while ( moreDirectoriesToProcess( idx, dirs ) )
        {
            dirs = dirs.slice( 0, Math.max( 0, idx - 1 ) ).concat( dirs.slice( Math.min( dirs.length - 1, idx + 1 ) ) );

            // look for the next previous directory token
            idx = dirs.indexOf( _dot + _dot );
        }

        // rebuild the path for the array of directories
        filepath = dirs.join( _unixPathSep );

        return toUnixPath( filepath );
    };

    /**
     * Returns true if the specified value is a string and is not the empty string (unless the third argument is true)
     * or a string containing the text "undefined", "null", or "void" (as can be the result of type coercion),
     * (unless the second argument is false or missing)
     *
     * @param {any} pString - a value that may or may not be a valid string as per our criteria
     *
     * @param {boolean} pRemoveCoercionArtifacts when true, the function will replace the literal text,
     * "void", "null", or "undefined" with the empty string.
     * This is sometimes necessary to compensate for APIs that return that text when coercing values to a string.
     *
     * @param {boolean} pAcceptEmptyString when true, this function returns true even if the string is the empty string
     *
     * @returns {boolean} true if the value specified is a string
     * and is not the empty string (unless the third argument is true)
     * or a string containing the text "undefined", "null", or "void" (as can be the result of type coercion),
     * (unless the second argument is false or missing)
     */
    const isValidString = function( pString, pRemoveCoercionArtifacts, pAcceptEmptyString )
    {
        if ( pString && (isString( pString )) )
        {
            let s = (_mt_str + (pRemoveCoercionArtifacts ? (_mt_str + pString).replace( /null|undefined|void/gi, _mt_str ) : pString));

            return pAcceptEmptyString || !isEmpty( s );
        }

        return false;
    };

    /**
     * Returns true if the specified string appears to be a JSON expression representing an Object.
     * This function does not attempt to parse the JSON.  Rather this just checks to see if the string begins with { and ends with }
     * @param pString a string that might be a JSON expression representing an Object
     * @param pTest
     * @returns {boolean} true if the string appears to be a JSON expression representing an Object
     * @throws Error if the argument passed is already an Object,
     * if we encounter an Error when trying to stringify that Object,
     * that Error will be thrown from this function
     */
    const isValidJsonObject = function( pString, pTest = false )
    {
        const s = isString( pString ) ? tidy( pString ) : _obj === typeof pString ? JSON.stringify( pString ) : _mt_str;

        let rx = new RegExp( _rxValidJson, "s" ); // the 's' flag means to enable dot (.) to match newline characters (\n)

        let matches = rx.exec( s );

        if ( !isNull( matches ) && matches.length > 3 && ("{" === matches[1] && "}" === matches[3]) )
        {
            try
            {
                return !pTest || isObject( JSON.parse( s ) );
            }
            catch( ex )
            {
                // ignore
            }
        }
        return false;
    };

    /**
     * Returns true if the specified string appears to be a JSON expression representing an Array.
     * This function does not attempt to parse the JSON.  Rather this just checks to see if the string begins with [ and ends with ]
     * @param pString a string that might be a JSON expression representing an Array
     * @param pTest
     * @returns {boolean} true if the string appears to be a JSON expression representing an Array
     * @throws Error if the argument passed is already an Array or Object,
     * if we encounter an Error when trying to stringify that Array or Object,
     * that Error will be thrown from this function
     */
    const isValidJsonArray = function( pString, pTest = false )
    {
        const s = isString( pString ) ? tidy( pString ) : _obj === typeof pString ? JSON.stringify( pString ) : _mt_str;

        let rx = new RegExp( _rxValidJson, "s" ); // the 's' flag means to enable dot (.) to match newline characters (\n)

        let matches = rx.exec( s );

        if ( matches && matches.length > 3 && ("[" === matches[1] && "]" === matches[3]) )
        {
            try
            {
                return !pTest || isArray( JSON.parse( s ) );
            }
            catch( ex )
            {
                // ignore
            }
        }
        return false;
    };

    const JSON_VALIDATION_OPTIONS =
        {
            jsonObjectsOnly: false,
            jsonArraysOnly: false,
            acceptPrimitives: false,
            jsonOptions: { objectsOnly: false, arraysOnly: false, test: false },
            testJson: false
        };

    /**
     * Returns true if the specified string appears to be a JSON expression representing an Object or Array.
     * This function does not attempt to parse the JSON.  Rather this just checks to see if the string begins with { and ends with } or begins with [ and ends with ]
     * @param pString a string that might be a JSON expression representing an Object
     * @param pOptions an object defining whether to return true only for Arrays or Objects
     * @returns {boolean} true if the string appears to be a JSON expression representing an Object or Array
     * @throws Error if the argument passed is already an Object or Array,
     * if we encounter an Error when trying to stringify that Object or Array,
     * that Error will be thrown from this function
     */
    const isValidJson = function( pString, pOptions = JSON_VALIDATION_OPTIONS )
    {
        const s = isString( pString ) ? tidy( pString ) : _obj === typeof pString ? JSON.stringify( pString ) : _mt_str;

        let testJson = pOptions?.testJson || pOptions?.jsonOptions?.test;

        if ( pOptions?.jsonObjectsOnly || pOptions?.jsonOptions?.objectsOnly )
        {
            return isValidJsonObject( s, testJson );
        }

        if ( pOptions?.jsonArraysOnly || pOptions?.jsonOptions?.arraysOnly )
        {
            return isValidJsonArray( s, testJson );
        }

        if ( pOptions?.acceptPrimitives )
        {
            if ( (s.startsWith( "\"" ) && s.endsWith( "\"" )) || (/\d+/g).test( s ) || "null" === s || "void" === s || S_TRUE === s || S_FALSE === s )
            {
                try
                {
                    return !testJson || !isNull( JSON.parse( s ) );
                }
                catch( ex )
                {
                    //ignore
                }
            }
        }

        let rx = new RegExp( _rxValidJson, "s" ); // the 's' flag means to enable dot (.) to match newline characters (\n)

        let matches = rx.exec( s );

        if ( matches && matches.length > 3 &&
             (("[" === matches[1] && "]" === matches[3]) || ("{" === matches[1] && "}" === matches[3])) )
        {
            try
            {
                return !testJson || !isNull( JSON.parse( s ) );
            }
            catch( ex )
            {
                // ignore
            }
        }

        return false;
    };

    const DEFAULT_VALID_NUMBER_OPTIONS = lock(
        {
            minimumValue: Number.NEGATIVE_INFINITY,
            maximumValue: Number.POSITIVE_INFINITY,
            ...DEFAULT_NUMBER_SYMBOLS
        } );

    /**
     * Returns true if the argument is a number
     * (and optionally, if it is in the valid range defined in the pOptions argument)
     *
     * @param {number} pNum a value to check for numeric validity
     *
     * @param {Object} pOptions (optional) an object defining the minimum and maximum valid values accepted
     *
     * @returns true if the argument is a number (and optionally, if it is in the valid range defined in the pOptions argument)
     */
    const isValidNumber = function( pNum, pOptions = DEFAULT_VALID_NUMBER_OPTIONS )
    {
        const options = populateOptions( pOptions, DEFAULT_VALID_NUMBER_OPTIONS );

        const minValue = Math.max( Number.NEGATIVE_INFINITY, (0 === pOptions?.minimumValue ? 0 : options.minimumValue) );

        const maxValue = Math.min( Number.POSITIVE_INFINITY, (0 === pOptions?.maximumValue ? 0 : options.maximumValue) );

        // if the argument isn't defined, is null, or is not a numeric type or instance of Number, it is not valid, return false
        if ( _ud === typeof pNum || null == pNum || !([_num, _big].includes( typeof pNum ) || (_obj === typeof pNum && pNum instanceof Number)) )
        {
            return false;
        }

        let num = pNum;

        // we attempt to parse the value as a float and reject NaN or Infinity
        try
        {
            num = parseFloat( asString( pNum, true ) );

            if ( isNanOrInfinite( num ) )
            {
                return false;
            }
        }
        catch( ex )
        {
            modulePrototype.reportError( ex, "trying to interpret " + asString( pNum ) + " as a number", S_WARN, (modName + _colon + _colon + "isValidNumber") );
        }

        // create a local variable to control the rest of the logic
        // initialize it according to what we know so far
        let valid = !((isNanOrInfinite( pNum ) || isNanOrInfinite( num )));

        // if the argument is a number, is it in the valid range specified
        if ( valid )
        {
            valid = num >= minValue && num <= maxValue;
        }

        // return the results
        return valid;
    };

    const isValidNumeric = function( pStr, pOptions = DEFAULT_VALID_NUMBER_OPTIONS )
    {
        const options = Object.assign( {}, pOptions || DEFAULT_VALID_NUMBER_OPTIONS );

        if ( isValidNumber( pStr, options ) )
        {
            return true;
        }

        switch ( typeof pStr )
        {
            case _str:

                let s = toCanonicalNumericFormat( pStr, options );

                let num = parseFloat( s ) || Number( s );

                return isValidNumber( num, options );

            case _obj:
                if ( pStr instanceof Number || pStr instanceof BigInt )
                {
                    return isValidNumber( parseFloat( pStr ) );
                }
                break;

            case _fun:

                try
                {
                    let n = pStr.call( $scope(), pStr );
                    return isValidNumber( n, pOptions );
                }
                catch( ex )
                {
                    // ignore
                }
                break;

            default:
                break;
        }
        return false;
    };

    /**
     * Returns the string representation of the specified argument in all lowercase characters.
     * Shorthand for asString( pStr, false ).toLowerCase();
     * @param pStr a string or value that can be converted to a string using asString
     * @returns {string} the string representation of the specified argument in all lowercase characters
     */
    const lcase = function( pStr )
    {
        return asString( pStr, false ).toLowerCase();
    };

    /**
     * Returns the string representation of the specified argument in all uppercase characters.
     * Shorthand for asString( pStr, false ).toUpperCase();
     * @param pStr a string or value that can be converted to a string using asString
     * @returns {string} the string representation of the specified argument in all uppercase characters
     */
    const ucase = function( pStr )
    {
        return asString( pStr, false ).toUpperCase();
    };

    const MC_OPTIONS =
        {
            prefixes: ["Mc", "Mac", "O'"],
        };

    /**
     * Used by other methods to handle surnames with mix capitalization
     * @param pString a string that might represent a mixed cased surname
     * @param pOptions an object specifying additional surname prefixes to handle
     * @returns {string} a string with proper capitalization of the name
     */
    const handleMc = function handleMc( pString, pOptions = MC_OPTIONS )
    {
        const options = Object.assign( Object.assign( {}, MC_OPTIONS ), pOptions || {} );

        let s = asString( pString, false ) || _mt_str;

        if ( !includesAny( s, options?.prefixes ) )
        {
            return s;
        }

        let out = _mt_str;

        let tokens = s.split( " " );

        for( let i = 0, n = tokens.length; i < n; i++ )
        {
            let t = tokens[i];

            let prefixes = ["Mc", "Mac", "O'"].concat( options?.prefixes || [] );

            let Mc = -1;
            let len = 0;

            while ( Mc !== 0 && prefixes.length > 0 )
            {
                let prefix = prefixes.shift();

                Mc = t.indexOf( prefix );

                len = prefix.length;

                if ( Mc === 0 && len > 0 )
                {
                    break;
                }
            }

            if ( Mc === 0 && t.length > len )
            {
                t = t.substring( 0, len ) + t.substring( len, len + 1 ).toUpperCase() + t.substring( len + 1, t.length );
            }

            out += (t + _spc);
        }

        return out.trim();
    };

    const DEFAULT_PROPERCASE_OPTIONS =
        {
            separator: _spc,
            surnamePrefixes: ["Mc", "Mac"]
        };

    /**
     * Returns a string with the first letter capitalized,
     * also handling common surnames that include an apostrophe, Mc, or Mac
     * @param pStr the string to convert to ProperCase
     * @param pOptions an object defining the separator to use to split the string into 'words' as well as other behaviors
     * @returns {string}
     */
    const toProperCase = function( pStr, pOptions = DEFAULT_PROPERCASE_OPTIONS )
    {
        const options = populateOptions( pOptions, DEFAULT_PROPERCASE_OPTIONS );

        let s = asString( pStr, false ) || _mt_str;

        let out = _mt_str;

        let sep = (options?.separator || _spc);

        let words = s.split( sep ).filter( e => !isEmpty( e ) );

        let word = _mt_str;

        let temp = _mt_str;

        for( let i = 0; i < words.length; i++ )
        {
            temp = _mt_str;

            // reset
            word = words[i];

            out += word.substring( 0, 1 ).toUpperCase();

            temp = word.substring( 1, word.length ).toLowerCase();

            if ( temp.indexOf( "'" ) >= 0 )
            {
                //handle O'Leary
                temp = "'" + toProperCase( temp, Object.assign( { ...DEFAULT_PROPERCASE_OPTIONS }, { separator: "'" } ) );
            }

            let pos = temp.indexOf( "-" );

            if ( pos >= 0 )
            {
                //handle Thorne-Smith (temp = horne-smith )
                temp = temp.substring( 0, pos ) + "-" + handleMc( temp.substring( pos + 1, pos + 2 ).toUpperCase() + temp.substring( pos + 2, temp.length ) );
            }

            out += temp;

            if ( i < (words.length - 1) )
            {
                out += sep;
            }
            else
            {
                if ( s.substring( s.length - 1 ) === _spc )
                {
                    out += _spc;
                }
            }
        }

        out = handleMc( out ) || out;

        return out;
    };

    /**
     * Converts a string in "snake case" ( some_variable_name ) into "camel case" ( someVariableName )
     * @param pStr a string to convert to camel case
     * @returns {string} the specified string formatted in "camel case"
     */
    const toCamelCase = function( pStr )
    {
        let s = asString( pStr, false ) || _mt_str;

        s = lcase( s.slice( 0, 1 ) ) + s.slice( 1 );

        let re = /_+(\w)/gi;

        function lambda( pMatch )
        {
            let match = pMatch.replace( /^_+/, _mt_str );

            return match.substring( 0 ).toUpperCase() + match.substring( 1 ).toLowerCase();
        }

        return s.replace( re, lambda );
    };

    /**
     * Converts a string in camelCase (or other format) ( someVariableName ) into "snake case" ( some_variable_name )
     * @param pStr a string to convert to camel case
     * @returns {string} the specified string formatted in "snake case"
     */
    const toSnakeCase = function( pStr )
    {
        let s = (asString( pStr, false ) || _mt_str);

        s = lcase( s.slice( 0, 1 ) ) + s.slice( 1 );

        let re = /[A-Z]/g;

        function lambda( pMatch )
        {
            return (_underscore + lcase( (pMatch.substring( 0 )) ));
        }

        return lcase( s.replace( re, lambda ) ).replaceAll( /_{2,}/g, _underscore );
    };

    /**
     * This is an extremely 'paranoid' function for producing a copy of a string that cannot possibly be pointing to the original string in memory
     * @param pStr  a string to copy
     * @returns {string} a string with the same characters as the string specified, but not identical to that string
     */
    const copyString = function( pStr )
    {
        const s = asString( pStr, false );

        return (_mt_str + ([].concat( ...(asString( s, false ).split( _mt_chr )) ) || []).join( _mt_chr ));
    };

    /**
     * Returns true if the argument is not a string or if the string contains only whitespace
     * @param pStr a value to test
     * @returns {boolean} true if the argument is not a string or if the string contains only whitespace
     */
    const isUnpopulated = function( pStr )
    {
        return (_ud === typeof pStr || null == pStr || ( !isString( pStr ) || isBlank( pStr )));
    };

    const reverseString = function( pStr )
    {
        let arr = [].concat( pStr );

        if ( null == pStr || _ud === typeof pStr )
        {
            return _mt_str;
        }

        switch ( typeof pStr )
        {
            case _ud:
                arr = [];
                break;

            case _str:
                arr = pStr.split( _mt_chr );
                break;

            case _num:
            case _big:
                let s = asString( pStr );
                arr = s.split( _mt_chr );
                break;

            case _fun:
                arr = [];
                break;

            case _obj:

                if ( isArray( pStr ) )
                {
                    arr = [].concat( pStr );
                }

                break;

            default:
                break;
        }

        arr = arr.reverse();

        return asString( arr.join( _mt_chr ) );
    };

    const DEFAULT_TIDY_OPTIONS =
        {
            trim: true,
            removeRedundantSpaces: true,
            replaceTabsWithSpaces: false,
            replaceSpacesWithTabs: false,
            spacesPerTab: 4,
            functions: [],
            lowercase: false,
            uppercase: false,
            camelCase: false,
            snakeCase: false,
            properCase: false
        };

    /**
     * A null-safe, type-safe, alternative to the String method, trim
     * Trims and returns a string or a char[] or a string representation
     * of the value passed
     *
     * Tidy performs optional transformations specified in the optional second argument, pOptions.
     * This function can be used as a sort of 'swiss army knife' for strings, based on the options passed,
     * especially the ability to pass one or more functions to transform the result
     *
     * @param {string} pString - the value to trim and return as a String
     * @param {Object} pOptions - optional operations or transformations to perform on the string,
     *                            such as toLowerCase, toUpperCase, removeRedundantSpaces, replaceSpacesWithTabs, replaceTabsWithSpaces, etc.
     *                            It is also possible to pass one or more functions to apply to the string before it is returned.
     *
     * @returns {string} a string or char[] or a string representation
     * of the value passed with whitespace removed
     * and any optional transformations applied
     */
    const tidy = function( pString, pOptions = DEFAULT_TIDY_OPTIONS )
    {
        if ( _ud === typeof pString || null === pString )
        {
            // note that we code this in such a way that it can be bound to the String.prototype as a member function (a.k.a. method)
            if ( (this instanceof String || String === this?.constructor) && isFunction( this.tidy ) )
            {
                return tidy( String( this ).valueOf() || asString( this, pOptions?.trim ), pOptions );
            }

            return _mt_str;
        }

        const options = populateOptions( pOptions, DEFAULT_TIDY_OPTIONS );

        let str = asString( pString, options?.trim );

        if ( options?.trim )
        {
            str = str.replaceAll( /[\r\n]+/g, _spc ).trim();
        }

        if ( options.replaceTabsWithSpaces )
        {
            str = str.replaceAll( /\t/g, _spc.repeat( Math.max( 1, asInt( options?.spacesPerTab || 1 ) ) ) );
        }

        if ( options.replaceSpacesWithTabs )
        {
            str = str.replaceAll( new RegExp( _spc.repeat( Math.max( 1, asInt( options?.spacesPerTab || 1 ) ) ), "g" ), _tab );
        }

        if ( options.removeRedundantSpaces )
        {
            str = str.replaceAll( / {2,}/g, _spc );
        }

        let operations = [];

        if ( options?.functions )
        {
            operations = operations.concat( ...(options?.functions || []) ).filter( e => isFunction( e ) && e.length > 0 );
        }

        if ( options?.toLowerCase || options?.lowercase )
        {
            str = lcase( str );
        }
        else if ( options?.toUpperCase || options?.uppercase )
        {
            str = ucase( str );
        }
        else if ( options?.capitalize )
        {
            str = str.length > 1 ? ucase( str.slice( 0, 1 ) ) + lcase( str.slice( 1 ) ) : ucase( str );
        }
        else if ( options?.camelCase || options?.toCamelCase )
        {
            str = toCamelCase( str );
        }
        else if ( options?.snakeCase || options?.toSnakeCase )
        {
            str = toSnakeCase( str );
        }
        else if ( options?.properCase || options?.toProperCase )
        {
            str = toProperCase( str, Object.assign( { ...DEFAULT_PROPERCASE_OPTIONS }, options || {} ) );
        }

        let temp = (_mt_str + asString( str ));

        if ( operations.length )
        {
            for( let i = 0, n = operations.length; i < n; i++ )
            {
                const func = operations[i];

                if ( isFunction( func ) )
                {
                    try
                    {
                        str = func.apply( $scope, [str, options] );
                    }
                    catch( ex )
                    {
                        modulePrototype.reportError( ex, "trying to execute " + asString( func?.name || funcToString.call() ) + " as a number", S_WARN, (modName + _colon + _colon + "tidy") );
                    }
                }

                str = str || temp;
            }
        }

        str = (asString( str, options?.trim ));

        return str;
    };

    String.prototype.tidy = tidy;

    class StringComparatorFactory extends ComparatorFactory
    {
        constructor( pOptions )
        {
            super( _str, pOptions );
        }

        _compare( pA, pB, pOptions )
        {
            let comp = super._compare( pA, pB, pOptions );

            if ( 0 === comp )
            {
                let a = asString( pA, this.trimStrings );
                let b = asString( pB, this.trimStrings );

                if ( !this.caseSensitive )
                {
                    a = ucase( a );
                    b = ucase( b );
                }

                comp = a > b ? 1 : a < b ? -1 : 0;

                if ( 0 === comp )
                {
                    a = asString( pA, this.trimStrings );
                    b = asString( pB, this.trimStrings );

                    comp = a > b ? 1 : a < b ? -1 : 0;
                }

                if ( this.reverse )
                {
                    comp = -comp;
                }
            }

            return comp;
        }
    }

    function toggleCaps( pStr, pFirstLetterCase, pRestCase )
    {
        let str = asString( pStr );
        return (str?.length || 0) > 1 ? (pFirstLetterCase( str.slice( 0, 1 ) ) + pRestCase( str.slice( 1 ) )) : pFirstLetterCase( str );
    }

    function capitalize( pStr, pPreserve = false )
    {
        let str = asString( pStr );
        return toggleCaps( str, ucase, (pPreserve ? asString : lcase) );
    }

    function uncapitalize( pStr )
    {
        let str = asString( pStr );
        return toggleCaps( str, lcase, asString );
    }

    function cartesian( pStrA, pStrB )
    {
        let a = asString( pStrA );
        let b = asString( pStrB );

        let s = _mt_str;

        for( let i = 0, n = a.length; i < n; i++ )
        {
            for( let j = 0, m = b.length; j < m; j++ )
            {
                s += a.charAt( i ) + b.charAt( j );
            }
        }

        return s;
    }

    function repeat( pStr, pCount )
    {
        if ( isNumber( pCount ) )
        {
            return asString( pStr ).repeat( pCount );
        }
        if ( isString( pCount ) )
        {
            return asString( pStr ).repeat( asString( pCount ).length );
        }
        if ( isFunction( pCount ) )
        {
            let s = pStr;
            try
            {
                s = pCount.call( asString( pStr ) );
            }
            catch( ex )
            {
                modulePrototype.reportError( ex, ex.message, S_WARN, (modName + _colon + _colon + "repeat") );
            }
            return s;
        }
    }

    let mod =
        {
            dependencies,
            DEFAULT_AS_STRING_OPTIONS,
            asString,
            isEmpty,
            isBlank,
            isUnpopulated,
            isAllCaps,
            isNoCaps,
            isMixedCase,
            tidy,
            occurrencesOf,
            leftOf,
            leftOfLast,
            rightOf,
            rightOfLast,
            trimLeadingCharacters,
            trimMatchingChars,
            DEFAULT_NUMBER_SYMBOLS,
            calculateDecimalSymbols,
            deriveDecimalSymbols,
            toCanonicalNumericFormat,
            asInt,
            asFloat,
            asPositiveInt,
            asPositiveFloat,
            toIntWithinRange,
            toFloatWithinRange,
            safeIndex,
            validIdentifier,
            asKey,
            endsWithAny,
            startsWithAny,
            includesAny,
            includesAll,
            evaluateBoolean,
            isTrue,
            toBool,
            toUnixLinebreaks,
            toWindowsLinebreaks,
            isValidString,
            isValidNumber,
            isValidNumeric,
            isValidJsonObject,
            isValidJsonArray,
            isValidJson,
            isJson,
            lcase,
            ucase,
            toCamelCase,
            toSnakeCase,
            toProperCase,
            copyString,
            reverseString,
            capitalize,
            uncapitalize,
            cartesian,
            repeat,
            toUnixPath,
            isRelativePath,
            toAbsolutePath,
            toCString,
            fromCString,
            formatMessage,
            interpolate,
            getFunctionSource,
            asUtf8ByteArray,
            fromUtf8ByteArray,
            classes: { StringComparatorFactory, ModuleEvent, ModulePrototype, CustomEvent },
            StringComparatorFactory
        };

    mod = modulePrototype.extend( mod );

    return mod.expose( mod, INTERNAL_NAME, (_ud !== typeof module ? module : mod) ) || mod;

}());
