/**
 * @fileOverview
 * This module defines several utility functions for testing the typeof a value,<br>
 * converting between types, and finding elements based on their type.<br>
 * <br>
 * The original motivation for this module<br>
 * is that is a common source of bugs to type something like:<br>
 * <code>
 *     if( "string" === someVariable )
 * </code>
 * <br>
 * when what is intended is:<br>
 * <code>
 *     if( "string" === typeof someVariable )
 * </code>
 * <br>
 * This module also defines and exports the commonly-used quasi-functional programming constructs,<br>
 * <br>
 * {@Link Option}, {@link TypedOption}, and {@link Result}<br>
 * <br>
 * as well as functions for converting numbers to and from hexadecimal, octal, binary, and decimal forms.<br>
 * <br>
 *
 *
 * @module TypeUtils
 *
 * @author Scott Bockelman
 * @license MIT
 */

/* import the Constants.cjs we depend upon, using require for maximum compatibility with Node versions */
const constants = require( "./Constants.cjs" );

/**
 * Defines a string to represent the type, undefined
 */
const { _ud = "undefined" } = constants;

/**
 * This function returns the host environment scope (Browser window, Node.js global, or Worker self)
 */
const $scope = constants?.$scope || function()
{
    return (_ud === typeof self ? ((_ud === typeof global) ? ((_ud === typeof globalThis ? {} : globalThis)) : (global || {})) : (self || {}));
};

/**
 * This module is constructed by an Immediately Invoked Function Expression (IIFE).
 * see: <a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE">MDN: IIFE</a> for more information on this design pattern
 */
(function exposeModule()
{
    /**
     * Defines a string key which is unlikely to collide with other libraries or properties.
     * We use this to store the module generated by this function in global scope.
     * We can avoid re-executing the rest of this function if the module is already defined.
     */
    const INTERNAL_NAME = "__BOCK__TYPE_UTILS__";

    /**
     * Checks to see if this module is already defines and available in the global scope
     * Returns the existing module instead of recreating it, if it is already present.
     */
    if ( $scope() && (null != $scope()[INTERNAL_NAME]) )
    {
        return $scope()[INTERNAL_NAME];
    }

    /**
     * This is a dictionary of this module's dependencies.
     * <br>
     * It is exported as a property of this module,
     * allowing us to just import this module<br>
     * and then import or use the other utilities<br>
     * as properties of this module.
     * <br>
     * @dict
     * @type {Object}
     * @alias module:TypeUtils#dependencies
     */
    const dependencies =
        {
            constants
        };

    const
        {
            _mt_str,
            _dot,
            _str,
            _fun,
            _num,
            _big,
            _bool,
            _obj,
            _symbol,
            _minus,
            DIGITS,
            DIGITS_MAP,
            HEX_DIGITS,
            HEX_DIGITS_MAP,
            OCT_DIGITS,
            OCT_DIGITS_MAP,
            BIN_DIGITS,
            BIN_DIGITS_MAP,
            S_ERROR,
            S_WARN,
            S_ERR_PREFIX,
            TYPED_ARRAYS,
            ERROR_TYPES,
            PRIMITIVE_WRAPPER_TYPES,
            GLOBAL_TYPES,
            BUILTIN_TYPES,
            BUILTIN_TYPE_NAMES,
            SERIALIZABLE_TYPES,
            AsyncFunction,
            IllegalArgumentError,
            populateOptions,
            no_op,
            lock,
            classes
        } = constants;

    const { ModulePrototype } = classes;

    /**
     * Represents the name of the module<br>
     * This name is used when error events are emitted to indicate the source of the error.
     * @type {string}
     */
    const modName = "TypeUtils";

    /**
     * This is the object that is returned from this function.
     * <br>
     * This object is the TypeUtils module<br>
     * <br>
     * The variables and functions defined in this file are added to the module before it is exported and returned.
     * <br>
     * @type {ModulePrototype}
     */
    let modulePrototype = new ModulePrototype( modName, INTERNAL_NAME );

    /**
     * This is an array of the 'valid' JavaScript primitive types.<br>
     * Note that 'undefined' is not considered to be a 'valid' type<br>
     * @namespace VALID_TYPES
     * @const
     * @readonly
     * @type {Array<string>}
     * @alias module:TypeUtils#VALID_TYPES
     */
    const VALID_TYPES = lock( [_str, _num, _big, _symbol, _bool, _obj, _fun] );

    /**
     * This is an array of all JavaScript primitive types.<br>
     * This includes all the 'valid' types AND 'undefined'<br>
     * @namespace JS_TYPES
     * @const
     * @readonly
     * @type {Array<string>}
     * @alias module:TypeUtils#JS_TYPES
     */
    const JS_TYPES = lock( [_ud].concat( VALID_TYPES ) );

    /**
     * This object is a dictionary of the default values for each primitive type<br>
     * @namespace TYPE_DEFAULTS
     * @dict
     * @const
     * @readonly
     * @type {Object}
     * @alias module:TypeUtils#TYPE_DEFAULTS
     */
    const TYPE_DEFAULTS = lock(
        {
            [_str]: _mt_str,
            [_big]: 0n,
            [_num]: 0,
            [_bool]: false,
            [_fun]: null,
            [_obj]: null,
            [_symbol]: null,
            [_ud]: undefined
        } );

    /**
     * A map of the JavaScript data types to their respective sort order.<br>
     * <br>
     * This object provides a standardized order for sorting or categorizing types.<br>
     * Each key corresponds to a specific data type, with an associated
     * numerical value indicating its order in comparison to others.<br>
     * <br>
     * <br>
     * Keys/Values:<br>
     * <ul>
     *
     *   <li>"number": The lowest sort order (0).</li>
     *   <li>"bigint": The next lowest sort order (1)</li>
     *   <li>"boolean": The next lowest sort order (2)</li>
     *   <li>"string": The next lowest sort order (3)</li>
     *   <li>"object": The next lowest sort order (4)</li>
     *   <li>"function": The next lowest sort order (5)</li>
     *   <li>"symbol": The next lowest sort order (6)</li>
     *   <li>"undefined": The highest sort order (7)</li>
     *
     *  </ul>
     *
     * @namespace TYPE_SORT_ORDER
     * @dict
     * @const
     * @readonly
     * @type {Object}
     * @alias module:TypeUtils#TYPE_SORT_ORDER
     */
    const TYPE_SORT_ORDER = lock(
        {
            [_num]: 0,
            [_big]: 1,
            [_bool]: 2,
            [_str]: 3,
            [_obj]: 4,
            [_fun]: 5,
            [_symbol]: 6,
            [_ud]: 7
        } );

    class VisitedSet extends Set
    {
        constructor( ...pValues )
        {
            super( pValues );
        }

        static get [Symbol.species]()
        {
            return this;
        }

        has( pValue )
        {
            if ( super.has( pValue ) )
            {
                return true;
            }

            for( let v of this.values() )
            {
                if ( isObject( v ) && v === pValue )
                {
                    return true;
                }
            }
        }
    }

    /**
     * Returns the estimated number of bytes required to represent the specified data type.
     * <br>
     * <br>
     * Note that these values are <i>estimates</i> only<br>
     * and that the types, symbol, object, and function<br>
     * cannot be estimated; they must be calculated at runtime.<br>
     * <br>
     * Finally, the estimated number of bytes for the string type is actually 'bytes per character'
     * <br>
     *
     * @param {string} pType - The JavaScript data type to estimate memory usage for.
     *
     * @returns {number} - The estimated number of bytes for the given type.<br>
     *                     <br>
     *                     Returns:<br>
     *                     2 (bytes per character) for strings (assuming UTF-16 encoding),<br>
     *                     8 for numbers (IEEE 754 double-precision),<br>
     *                     16 for big integers (an arbitrary assumption),<br>
     *                     1 for booleans,<br>
     *                     0 for symbols and functions (size indeterminable),<br>
     *                     0 for objects (dynamic size, indeterminable),<br>
     *                     and -1 for unsupported or unknown types.<br>
     */
    const estimateBytesForType = function( pType )
    {
        const type = (_mt_str + pType).toLowerCase();

        if ( JS_TYPES.includes( pType ) )
        {
            switch ( type )
            {
                case _str:
                    return 2; // Assumes string as UTF-16, 2 bytes per character
                case _num:
                    return 8; // Number (IEEE 754 double-precision floating point)
                case _big:
                    return 16; // Arbitrary assumption for BigInt size
                case _bool:
                    return 1; // Boolean (1 byte)
                case _symbol:
                    return 0; // Symbol size cannot be determined
                case _fun:
                    return 0; // Functions don't have a measurable byte size
                case _obj:
                    return 0; // Objects' sizes are dynamic and can't be determined simply
                default:
                    return -1; // For unsupported or unknown types
            }
        }
    };

    /**
     * An object that maps data types to their estimated size in bytes.
     * <br>
     * Note that these values are estimates only<br>
     * and that the types, symbol, object, and function<br>
     * cannot be estimated; they must be calculated at runtime.<br>
     * <br>
     * Finally, the estimated number of bytes for the String type is actually 'bytes per character'<br>
     * <br>
     * @namespace BYTES_PER_TYPE
     * @dict
     * @const
     * @readonly
     * @type {Object}
     * @alias module:TypeUtils#BYTES_PER_TYPE
     */
    const BYTES_PER_TYPE = lock(
        {
            [_str]: estimateBytesForType( _str ),
            [_big]: estimateBytesForType( _big ),
            [_num]: estimateBytesForType( _num ),
            [_bool]: estimateBytesForType( _bool ),
            [_fun]: estimateBytesForType( _fun ),
            [_obj]: estimateBytesForType( _obj ),
            [_symbol]: estimateBytesForType( _symbol ),
            [_ud]: estimateBytesForType( _ud )
        }
    );

    /**
     * This oddly named function, so as not to collide with 'isArray',<br>
     * is used to polyfill Array for ancient browsers or non-spec execution environments<br>
     *
     * @function doesBeArray
     *
     * @param {*} pArg a value to evaluate
     *
     * @returns {boolean} true if the specified argument is an Array
     *
     * @private
     */
    function doesBeArray( pArg )
    {
        return !(_ud === typeof pArg || null == pArg) && "[object Array]" === {}.toString.call( pArg );
    }

    // poly-fill for isArray; probably obsolete with modern environments
    if ( _fun !== typeof Array.isArray )
    {
        try
        {
            Array.isArray = doesBeArray;
        }
        catch( ex )
        {
            modulePrototype.reportError( ex, "extending the built-in Array class", S_WARN, modName + "::Array::isArray" );
        }
    }

    /**
     * Returns true if the specified value is undefined<br>
     *
     * @function isUndefined
     *
     * @param {*} pObject A value to evaluate
     *
     * @returns {boolean} true if the specified value is undefined
     *
     * @alias module:TypeUtils.isUndefined
     */
    const isUndefined = function( pObject )
    {
        return (_ud === typeof pObject || undefined === pObject);
    };

    /**
     * Returns true if the specified value IS defined.<br>
     * This is just an inversion of {@link isUndefined}
     *
     * @function isDefined
     *
     * @param {*} pObject A value to evaluate
     *
     * @returns {boolean} true if the specified value is defined
     *
     * @see {@link isUndefined}
     *
     * @alias module:TypeUtils.isDefined
     */
    const isDefined = function( pObject )
    {
        return !isUndefined( pObject );
    };

    /**
     * Returns true if the specified value is an empty string.<br>
     * <br>
     * A value is considered to be an empty string<br>
     * if it is strictly of type "string"<br>
     * and either has a length of 0 or matches the pre-defined empty string constant.<br>
     * <br>
     *
     * @function isEmptyString
     *
     * @param {*} pObject - The value to be evaluated.
     *
     * @returns {boolean} Returns true if the input is an empty string; otherwise, returns false.
     *
     * @alias module:TypeUtils.isEmptyString
     */
    const isEmptyString = function( pObject )
    {
        return _str === typeof (pObject) && (_mt_str === pObject || _str.length === 0);
    };

    /**
     * Returns true if the specified value is null<br>
     * (or, when not <i>strict</i>, undefined or an empty string)<br>
     * <br>
     * The default behavior is non-strict<br>
     * and will return true for any value that is null, undefined, or an empty string.<br>
     * <br>
     *
     * @function isNull
     *
     * @param {*} pObject The value to evaluate
     * @param {boolean} pStrict Specify true to treat any value that is not <b>identical<b> to null as not-null<br>
     *
     * @returns {boolean} if the specified value is null (or, when not strict, undefined or an empty string)
     *
     * @alias module:TypeUtils.isNull
     */
    const isNull = function( pObject, pStrict = false )
    {
        return pStrict ? (null === pObject) : (isUndefined( pObject ) || null == pObject || isEmptyString( pObject ));
    };

    /**
     * Returns true if the specified value is <i>NOT</i> null<br>
     * (or, when not <i>strict</i>, NOT undefined and NOT an empty string)<br>
     * <br>
     * The default behavior is non-strict and will return true<br>
     * for any value that is not null, undefined, or an empty string.<br>
     * <br>
     * This is just an inversion of {@link isNull}<br>
     *
     * @function isNotNull
     *
     * @param {*} pObject The value to evaluate
     * @param  {boolean} pStrict Specify true to treat any value that is not identical to null as not-null
     *
     * @returns {boolean} true if the specified value is NOT null (or, when not strict, NOT undefined and NOT an empty string)
     *
     * @see isNull
     *
     * @alias module:TypeUtils.isNotNull
     */
    const isNotNull = function( pObject, pStrict = false )
    {
        return !isNull( pObject, pStrict );
    };

    /**
     * Returns true if the specified value is a Function.<br>
     * Or, if invoked with false as the second argument,<br>
     * the specified value is callable (via call() or apply())
     *
     * @function isFunction
     *
     * @param {*} pObj A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to return true for objects that define 'call' and 'apply' methods<br>
     *
     * @returns {boolean} true if the specified value is a Function<br>
     * (or when not invoked with strict, any object defining both a call and apply method)
     *
     * @alias module:TypeUtils.isFunction
     */
    const isFunction = function( pObj, pStrict = true )
    {
        return !isNull( pObj ) && (_fun === typeof pObj || ( !pStrict && (_fun === typeof pObj.call) && (_fun === typeof pObj.apply)));
    };

    /**
     * Returns true if the specified value is an <i>asynchronous</i> Function<br>
     *
     * @function isAsyncFunction
     *
     * @param {*} pObject A value to evaluate
     * @returns {boolean} true if the specified value is an asynchronous Function
     *
     * @alias module:TypeUtils.isAsyncFunction
     */
    const isAsyncFunction = function( pObject )
    {
        return isFunction( pObject, true ) && (pObject.constructor === AsyncFunction || pObject === AsyncFunction);
    };

    /**
     * Returns true if the specified value is a function that creates a generator<br>
     *
     * @function isGeneratorFunction
     *
     * @param {*} pObject A value to evaluate
     *
     * @returns {boolean} true if the specified value is a function that creates a generator
     *
     * @alias module:TypeUtils.isGeneratorFunction
     */
    function isGeneratorFunction( pObject )
    {
        return (isFunction( pObject ) && "[object Generator]" === {}.toString.call( pObject.prototype, pObject.prototype ));
    }

    /**
     * @typedef {Object} ObjectEvaluationOptions
     *
     * @property [rejectPrimitiveWrappers=true] When true, instances of the Boolean, String, Number, and BigInt classes are not considered to be objects.<br>
     * @property [rejectArrays=false] When true, arrays are not considered to be objects<br>
     * @property [rejectNull=false] When true, null is not considered to be an object, even though typeof null === "object"
     * @property [allowEmptyObjects=true] When false, objects with no properties, i.e., Object.keys(obj).length === 0, are not considered objects
     */

    /**
     * This object defines the default options for the {@link isObject} function.<br>
     * @type {ObjectEvaluationOptions}
     * @alias module:TypeUtils#DEFAULT_IS_OBJECT_OPTIONS
     */
    const DEFAULT_IS_OBJECT_OPTIONS =
        {
            rejectPrimitiveWrappers: true,
            rejectArrays: false,
            rejectNull: false,
            allowEmptyObjects: true
        };

    /**
     * Returns true if the specified value is an instance of String, Number, Boolean, or BigInt<br>
     *
     * @function isPrimitiveWrapper
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an instance of String, Number, Boolean, or BigInt
     *
     * @alias module:TypeUtils.isPrimitiveWrapper
     */
    function isPrimitiveWrapper( pObj )
    {
        return !isNull( pObj ) && ([].concat( PRIMITIVE_WRAPPER_TYPES )).filter( e => pObj instanceof e ).length > 0; // (pObj instanceof String || pObj instanceof Number || pObj instanceof Boolean || pObj instanceof BigInt);
    }

    /**
     * Returns true if the specified value is an object.<br>
     * Use the options to clarify how to treat primitive wrappers, arrays, and nulls<br>
     *
     * @function isObject
     *
     * @see {@link DEFAULT_IS_OBJECT_OPTIONS}
     * @see {@link isPrimitiveWrapper}
     *
     * @param {*} pObj A value to evaluate
     * @param {ObjectEvaluationOptions} pOptions An object specifying how to handle arrays, null values, or primitive value wrappers<br>
     *
     * @returns {boolean} true if the specified value is an object according to the options specified
     *
     * @alias module:TypeUtils.isObject
     */
    const isObject = function( pObj, pOptions = DEFAULT_IS_OBJECT_OPTIONS )
    {
        if ( (_obj === typeof pObj) || pObj instanceof Object )
        {
            const options = populateOptions( pOptions, DEFAULT_IS_OBJECT_OPTIONS );

            if ( options.rejectNull && isNull( pObj ) )
            {
                return false;
            }

            if ( options.rejectPrimitiveWrappers && isPrimitiveWrapper( pObj ) )
            {
                return false;
            }

            return !(options.rejectArrays && doesBeArray( pObj ));
        }
        return false;
    };

    /**
     * Returns true if the specified value is an object that does not derive from the JavaScript {@link Object} type<br>
     *
     * @function isCustomObject
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an object that does not derive from the JavaScript Object type
     *
     * @alias module:TypeUtils.isCustomObject
     */
    const isCustomObject = function( pObj )
    {
        return isObject( pObj ) && pObj.prototype !== null && pObj.prototype !== Object && (pObj.constructor === null || pObj.constructor !== Object);
    };

    const isError = function( pObj )
    {
        return isObject( pObj ) && pObj instanceof Error;
    };

    const firstError = function( ...pObj )
    {
        let arr = !isNull( pObj ) ? isArray( pObj ) ? pObj : [pObj] : [];
        return arr.filter( e => isError( e ) ).shift();
    };

    /**
     * Returns true if the specified value is a string or a {@link String} object<br>
     *
     * @function isString
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is a string or a String
     *
     * @alias module:TypeUtils.isString
     */
    const isString = function( pObj )
    {
        return (_str === typeof pObj) || pObj instanceof String;
    };

    /**
     * Attempts to convert a value to a string<br>
     *
     * @param {*} pObj
     *
     * @returns {string} A string representation of the specified value, if possible
     *
     * @private
     */
    function _toString( pObj )
    {
        if ( isString( pObj ) )
        {
            return pObj;
        }
        return (0 === pObj || "0" === pObj || false === pObj) ? "0" : ((_mt_str + String( pObj ) + _mt_str).trim()).replaceAll( /[,_]/g, _mt_str ).trim();
    }

    /**
     * Returns true if the specified value is a number or Number (and NOT a Date)<br>
     *
     * @function isNumber
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is a number or Number (and NOT a Date)
     *
     * @alias module:TypeUtils.isNumber
     */
    const isNumber = function( pObj )
    {
        return ([_num, _big].includes( typeof pObj ) || pObj instanceof Number || pObj instanceof BigInt) && !(isObject( pObj ) && pObj instanceof Date);
    };

    /**
     * Returns true if the specified value is a BigInt.<br>
     *
     * @function isBigInt
     *
     * @param {*} pNum A value to evaluate
     *
     * @returns {boolean} true if the input is a BigInt and valid, otherwise false.
     *
     * @alias module:TypeUtils.isBigInt
     */
    const isBigInt = function( pNum )
    {
        return isNumber( pNum ) && _big === typeof pNum;
    };

    /**
     * Returns true if the value is NaN or is not Finite<br>
     * This combines the commonly used conditions,<br>
     * <code>isNaN( num ) || !isFinite( num )</code>
     * <br>
     *
     * @function isNanOrInfinite
     *
     * @param {*} pNum A value to evaluate
     *
     * @returns {boolean} true if the specified value is not a number or is NaN or is not Finite
     *
     * @alias module:TypeUtils.isNanOrInfinite
     */
    const isNanOrInfinite = function( pNum )
    {
        if ( !([_num, _big, _str].includes( typeof pNum ) || pNum instanceof Number) )
        {
            return true;
        }
        const num = parseFloat( pNum );
        return isNaN( num ) || !isFinite( num );
    };

    /**
     * Returns true if the specified value can be expressed as an integer (or zero).<br>
     * That is, the value is a natural number, a.k.a. "whole number" and contains no powers of a base less than 1<br>
     * <br>
     *
     * @function isInteger
     *
     * @param {number|string} pObj A value to evaluate
     * @param {boolean} pStrict If true, the specified value must be a number; strings will not be parsed
     *
     * @returns {boolean} true if the specified value can be expressed as an integer (or zero) without any loss of precision
     *
     * @alias module:TypeUtils.isInteger
     */
    const isInteger = function( pObj, pStrict = true )
    {
        let is = 0 === pObj || (isNumber( pObj ) && parseInt( pObj ) === pObj);

        if ( !is && !pStrict && isString( pObj ) && isNumeric( pObj ) )
        {
            let n = parseFloat( pObj );

            if ( isInteger( n, true ) )
            {
                let s = _mt_str + String( n );

                return s === pObj;
            }
        }

        return is;
    };

    /**
     * Returns true if the specified value cannot be expressed as an integer (or zero).<br>
     * That is, if isInteger( n ) would return true, this function would return false,<br>
     * unless the value is 0, which we treat as a special case and also consider to be a float.<br>
     *
     * @function isFloat
     *
     * @param {number|string} pObj A value to evaluate
     * @param {boolean} pStrict  If true, the specified value must be a number; strings will not be parsed
     *
     * @returns {boolean} true if the specified value cannot be expressed as an integer (or zero)
     *
     * @alias module:TypeUtils.isFloat
     */
    const isFloat = function( pObj, pStrict = true )
    {
        if ( 0 === pObj )
        {
            return true;
        }

        let is = isNumber( pObj ) && (parseFloat( pObj ) !== parseInt( pObj ));

        if ( !is && !pStrict && isString( pObj ) && isNumeric( pObj ) )
        {
            let n = parseFloat( pObj );

            if ( isFloat( n, true ) )
            {
                let s = _mt_str + String( n );

                return s === pObj;
            }
        }

        return is;
    };

    /**
     * Returns true if the specified value represents a hexadecimal number (base 16)<br>
     * The value can either be a hexadecimal literal, such a 0xFF, <br>
     * or a string starting with "0x" and containing only the hexadecimal digits, a minus sign, or a decimal point<br>
     *
     * @function isHex
     *
     * @param {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents a hexadecimal number
     *
     * @alias module:TypeUtils.isHex
     */
    function isHex( pObj )
    {
        const s = _toString( pObj );
        return ("0" !== s) && /^(-)?(0x)([\dA-Fa-f]+)?(([.,])([\dA-Fa-f]+))?$/i.test( s ) && !/[G-Wg-w\s]|[yzYZ]/.test( s );
    }

    /**
     * Returns true if the specified value represents an octal number (base 8)<br>
     * The value can either be an octal literal, such a 0o07, <br>
     * or a string starting with "0o" and containing only the octal digits, a minus sign, or a decimal point<br>
     *
     * @function isOctal
     *
     * @param {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents an octal number
     *
     * @alias module:TypeUtils.isOctal
     */
    function isOctal( pObj )
    {
        const s = _toString( pObj );
        return ("0" !== s) && /^(-)?(0o)([0-7]+)?(([.,])([0-7]+))?$/i.test( s ) && !/[A-Za-np-z\s]/.test( s );
    }

    /**
     * Returns true if the specified value represents an octal number (base 8)<br>
     * The value can either be an octal literal, such a 0o07, <br>
     * or a string starting with "0o" and containing only the octal digits, a minus sign, or a decimal point<br>
     *
     * @function isBinary
     *
     * @param {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents an octal number
     *
     * @alias module:TypeUtils.isBinary
     */
    function isBinary( pObj )
    {
        const s = _toString( pObj );
        return ("0" !== s) && /^(-)?(0b)([0-1]+)?(([.,])([0-1]+))?$/i.test( s ) && !/[AC-Z]|[ac-z]|\s/.test( s );
    }

    /**
     * Returns true if the specified value represents a decimal number (base 10)<br>
     *
     * @function isDecimal
     *
     * @param  {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents a decimal number
     *
     * @alias module:TypeUtils.isDecimal
     */
    function isDecimal( pObj )
    {
        const s = _toString( pObj );
        return ("0" === s || "-0" === s || ( !(isHex( s ) || isOctal( s ) || isBinary( s )) && !/[^\d.+-]/.test( s )));
    }

    /**
     * Returns the base for the numeric value specified (i.e., 16 for hexadecimal values, 8 for octal values, or 10 for decimal values)<br>
     * <br>
     * This is used to determine the proper second argument to pass to {@link parseInt}
     *
     * @param pObj {string|number}
     *
     * @returns {number} the base for the numeric value specified (16, 8, or 10)
     */
    function calculateRadix( pObj )
    {
        return isDecimal( pObj ) ? 10 : isHex( pObj ) ? 16 : isOctal( pObj ) ? 8 : isBinary( pObj ) ? 2 : 0;
    }

    /**
     * Returns true if the specified value is, or can be converted to, a number<br>
     * <br>
     * @param  {string|number} pObj A value to evaluate
     * @param {boolean} [pAllowLeadingZeroForBase10=false] Specify true to allow decimal values with leading zeroes
     *
     * @returns {boolean} true if the specified value is, or can be converted to, a number
     *
     * @alias module:TypeUtils.isNumeric
     */
    const isNumeric = function( pObj, pAllowLeadingZeroForBase10 = false )
    {
        if ( isNumber( pObj ) || "0" === pObj )
        {
            return true;
        }

        if ( !([_num, _big, _str].includes( typeof pObj ) || (pObj instanceof Number || pObj instanceof String)) )
        {
            return false;
        }

        let value = ((_mt_str + _toString( pObj )).replace( /n+$/, _mt_str )).trim();

        if ( "0" === pObj || isDecimal( value ) || isHex( value ) || isOctal( value ) || isBinary( value ) )
        {
            if ( isDecimal( value ) && !!pAllowLeadingZeroForBase10 )
            {
                while ( /^0/.test( value ) )
                {
                    value = value.slice( 1 );
                }
            }

            if ( _mt_str === value )
            {
                return false;
            }

            let integer = parseInt( value, calculateRadix( pObj ) );

            return !isNanOrInfinite( integer );
        }

        return false;
    };

    /**
     * Returns true if the specified value === 0 <br>
     * <br>
     * This can be useful if you might normally test for truthiness and you want 0 to be considered true.<br>
     * <br>
     *
     * @param  {string|number} pValue A value to evaluate
     * @param {boolean} [pStrict=true] specify false to accept numeric values (i.e., strings that represent numbers)
     *
     * @returns {boolean} true if the specified value === 0
     *
     * @alias module:TypeUtils.isZero
     */
    const isZero = function( pValue, pStrict = true )
    {
        const valid = pStrict ? isNumber( pValue ) : isNumeric( pValue );

        return valid && ((0 === pValue || /^0+$/.test( _toString( pValue ) )) || (Math.round( parseFloat( pValue ) ) === 0 && Math.abs( parseFloat( pValue ) ) < 0.000000000000001));
    };

    /**
     * Returns a mapping of digit characters to their respective numerical values based on the specified base.<br>
     * <br>
     * @param {number|string} pBase - The numerical base or its string representation (e.g., 2, 8, 10, 16 or "binary", "octal", "decimal", "hex").<br>
     *                                If the value is null, not a number, or an unrecognized string, a default base of 10 is assumed.<br>
     * @return {Map<string, number>} A map where each key is a digit character and its corresponding value is the numerical value of that digit<br>
     *                               <br>
     *                               Predefined maps are returned for bases 2 (binary), 8 (octal), 10 (decimal), and 16 (hexadecimal).<br>
     *                               For other bases, a custom map is dynamically created using the range of available characters.
     *
     * @private
     */
    function getDigitsMap( pBase )
    {
        let base = !isNull( pBase ) && (isNumber( pBase ) || isString( pBase )) ? parseInt( pBase ) : 10;

        base = (isNanOrInfinite( base ) ? (isString( pBase ) ? ({
                                                                    "hex": 16,
                                                                    "octal": 8,
                                                                    "binary": 2,
                                                                    "decimal": 10
                                                                }[(pBase.trim().toLowerCase())] || 10) : 10) : 10);

        switch ( base )
        {
            case 0:
            case 10:
                return DIGITS_MAP;

            case 2:
                return BIN_DIGITS_MAP;

            case 8:
                return OCT_DIGITS_MAP;

            case 16:
                return HEX_DIGITS_MAP;

            default:
                const digits = DIGITS.slice( 0, pBase );
                return new Map( digits.map( ( e, i ) => [e, i] ) );
        }
    }

    /**
     * Returns the decimal representation of the specified value<br>
     * <br>
     * If the specified value is not numeric, returns 0<br>
     * <br>
     * If the specified value is an array, a new array is returned with each element in the array mapped to a decimal representation<br>
     *
     * @param {number|string|Array<(number|string)>} pObj A value or an array of values to convert to a decimal representation<br>
     *
     * @returns {number|Array<number>} a decimal representation of the specified value
     *
     * @alias module:TypeUtils.toDecimal
     */
    const toDecimal = function( pObj )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toDecimal );
        }

        if ( !isNumeric( pObj ) )
        {
            return 0;
        }

        let value = 0;

        if ( isDecimal( pObj ) )
        {
            try
            {
                value = parseFloat( pObj );
            }
            catch( ex )
            {
                modulePrototype.reportError( ex, "parsing " + _toString( pObj ), S_WARN, modName + "::toDecimal" );
                value = 0;
            }

            return value;
        }

        if ( isNumber( pObj ) )
        {
            let num = Number( pObj );
            return parseFloat( num.toString( 10 ) );
        }

        let s = _toString( pObj ).trim();

        let sign = s.startsWith( _minus ) ? -1 : 1;

        let power = calculateRadix( s );

        s = s.replace( _minus, _mt_str );

        s = s.replace( /^0([box])/i, _mt_str );

        let parts = s.split( _dot );

        let integer = (parts[0] || "0");
        let fraction = (parts[1] || "0");

        if ( /^0+$/.test( fraction ) )
        {
            return parseInt( s, power ) * sign;
        }

        let digitsMap = getDigitsMap( power );

        let intDigits = [].concat( ...(integer.split( _mt_str ).reverse()) );

        for( let i = 0, n = intDigits.length; i < n; i++ )
        {
            let digit = intDigits[i];

            value += Math.pow( digitsMap[digit], i );
        }

        let fractionDigits = fraction.split( _mt_str );

        for( let i = 0, n = fractionDigits.length; i < n; i++ )
        {
            let digit = fractionDigits[i];

            value += Math.pow( digitsMap[digit], -(i + 1) );
        }

        return value * sign;
    };

    /**
     * Returns a string representation of the specified value as a hexadecimal number<br>
     * <br>
     * If the specified value is an array, a new array is returned with each element in the array mapped to a hexadecimal representation<br>
     *
     * @param {number|string|Array<(number|string)>} pObj A value or an array of values to convert to a base 16 (hexadecimal) representation
     *
     * @returns {string|Array<string>} A string representation of the specified value as a hexadecimal (base 16) number
     *
     * @alias module:TypeUtils.toHex
     */
    const toHex = function( pObj )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toHex );
        }

        let decimalValue = toDecimal( pObj );

        const s = decimalValue.toString( 16 );

        return (s.startsWith( "-" ) ? "-0x" : "0x") + s.replace( /^-/, _mt_str ).trim();
    };

    /**
     * Returns a string representation of the specified value as an octal number<br>
     * <br>
     * If the specified value is an array, a new array is returned with each element in the array mapped to an octal representation
     * <br>
     *
     * @param {number|string|Array<(number|string)>} pObj A value to convert to base 8 (octal)
     *
     * @returns {string|Array<string>} A string representation of the specified value as an octal (base 8) number
     *
     * @alias module:TypeUtils.toOctal
     */
    const toOctal = function( pObj )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toOctal );
        }

        let decimalValue = toDecimal( pObj );

        const s = decimalValue.toString( 8 );

        return (s.startsWith( "-" ) ? "-0o" : "0o") + s.replace( /^-/, _mt_str ).trim();
    };

    /**
     * Returns a string representation of the specified value as a binary number
     * <br>
     * If the specified value is an array, a new array is returned with each element in the array mapped to a binary representation
     * <br>
     *
     * @param {number|string|Array<(number|string)>} pValue A value or an array of values to convert to base 2 (binary)
     *
     * @param {number} [pPrecision=0] The number of decimal places to include
     *                                if the value is not a whole number (integer)
     *
     * @returns {string|Array<string>} A string representation of the specified value as a binary (base 2) number
     *
     * @alias module:TypeUtils.toBinary
     */
    const toBinary = function( pValue, pPrecision = 0 )
    {
        if ( isArray( pValue ) )
        {
            return [...pValue].map( ( e ) => toBinary( e, pPrecision ) );
        }

        let decimalValue = toDecimal( pValue );

        let s = decimalValue.toString( 2 );

        if ( s.includes( _dot ) )
        {
            let maxPrecision = Math.max( 0, Math.min( 15, parseInt( _toString( pPrecision || _mt_str ), 10 ) ) );

            if ( (isNanOrInfinite( maxPrecision ) || maxPrecision <= 0) && isNull( pPrecision ) )
            {
                const msg = `Non-Integer value passed to ${modName}::toBinary to specify precision; value will be truncated`;

                modulePrototype.reportError( new IllegalArgumentError( msg, { value: pValue } ), msg, S_WARN, modName + "::toBinary", { value: pValue } );

                s = s.replace( /\.\d+$/, _mt_str );
            }
        }

        return (s.startsWith( "-" ) ? "-0b" : "0b") + s.replace( /^-/, _mt_str ).trim();
    };

    /**
     * Returns true if the specified value is a boolean or Boolean object<br>
     *
     * @param {*} pValue A value to evaluate
     *
     * @returns {boolean} true if the specified value is a boolean or Boolean object
     *
     * @alias module:TypeUtils.isBoolean
     */
    const isBoolean = function( pValue )
    {
        return ((_bool === typeof pValue) && ((false === pValue) || true === pValue)) || pValue instanceof Boolean;
    };

    /**
     * Returns true if the specified value is an object and is not null.<br>
     * <br>
     * Optionally, you can pass options to consider objects with no properties as 'null objects'<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} pStrict Specify true to treat any value that is not identical to null as not-null
     * @param pOptions {ObjectEvaluationOptions} An object to clarify how to handle objects that are not null, but have no properties, i.e., {}
     *
     * @returns {boolean} true if the specified value is an object and is not null
     *
     * @alias module:TypeUtils.isNonNullObject
     */
    const isNonNullObject = function( pObject, pStrict = false, pOptions = DEFAULT_IS_OBJECT_OPTIONS )
    {
        const options = populateOptions( pOptions, DEFAULT_IS_OBJECT_OPTIONS );

        if ( !isNull( pObject, pStrict ) && isObject( pObject, options ) )
        {
            return options.allowEmptyObjects || (Object.entries( pObject )?.length > 0 && !isNull( Object.entries( pObject )[0][1], pStrict ));
        }
        return false;
    };

    /**
     * Returns true if the specified value,<br>
     * which might otherwise evaluate to 'falsey',<br>
     * is actually a non-null value, such as 0, false, or an empty string<br>
     *
     * @param {*} pObject A value to evaluate
     * @returns {boolean} true if the specified value is actually a non-null value,
     * even when it might otherwise evaluate to 'falsey', (such as 0, false, or an empty string)
     *
     * @alias module:TypeUtils.isNonNullValue
     */
    const isNonNullValue = function( pObject )
    {
        return (false === pObject || 0 === pObject || _mt_str === pObject || isNotNull( pObject, false ));
    };

    /**
     * Returns true if the specified value is an array
     * <br>
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an array
     *
     * @alias module:TypeUtils.isArray
     */
    const isArray = function( pObj )
    {
        return isObject( pObj ) && ((isFunction( Array.isArray )) ? Array.isArray( pObj ) : doesBeArray( pObj ));
    };

    /**
     * Returns true if the specified value is an instance of a {@link TypedArray}.
     *
     * @function isTypedArray
     *
     * @param {Object} pObj - The object to be evaluated.
     * @returns {boolean} Returns true if the object is an instance of any typed array<br>
     *                    (e.g., Int8Array, Uint8Array, Float32Array, etc.),<br>
     *                    otherwise false.
     *
     * @alias module:TypeUtils.isTypedArray
     */
    const isTypedArray = function( pObj )
    {
        return (([...TYPED_ARRAYS].filter( e => isObject( pObj ) && pObj instanceof e ))?.length || 0) > 0;
    };

    /**
     * Returns true if the specified value is iterable.<br>
     * That is, the value can be used in a "for...of" loop<br>
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is iterable
     *
     * @alias module:TypeUtils.isIterable
     */
    const isIterable = function( pObj )
    {
        return !isNull( pObj ) && (isFunction( pObj[Symbol.iterator] ) || isArray( pObj ) || isTypedArray( pObj ));
    };

    /**
     * Returns true if the specified value is spreadable.<br>
     * That is, the value can be expanded by use of the ... operator<br>
     *
     * @param {*} pObj A value to evaluate
     * @param {boolean} [pMustBeIterable=true] Specify true to require that the value also be iterable.<br>
     *                                         This can distinguish between objects that can be copied via {...object}<br>
     *                                          versus truly spreadable values<br>
     *
     * @returns {boolean} true if the specified value is spreadable
     *
     * @alias module:TypeUtils.isSpreadable
     */
    const isSpreadable = function( pObj, pMustBeIterable = true )
    {
        let is = !isNull( pObj ) && (isArray( pObj ) || isString( pObj ) || isNonNullObject( pObj ) || isDefined( pObj[Symbol.isConcatSpreadable] ));
        return is && (pMustBeIterable ? isIterable( pObj ) : is);
    };

    /**
     * Returns true if the specified value is asynchronously iterable.<br>
     * That is, the value can be used in a "for await ... of" loop<br>
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is asynchronously iterable
     *
     * @alias module:TypeUtils.isAsyncIterable
     */
    const isAsyncIterable = function( pObj )
    {
        return !isNull( pObj ) && isFunction( pObj[Symbol.asyncIterator] );
    };

    /**
     * Returns true if the specified value is array-like<br>
     *
     * @see (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects)
     *
     * @param {*} pArg A value to evaluate
     * @param {boolean} [pMustBeIterable=false] Specify true if the value must also define [Symbol.iterator]
     *
     * @returns {boolean} true if the specified value is array-like<br>
     *                    (that is, has a length property and one or more numeric keys)
     *
     * @alias module:TypeUtils.isLikeArray
     */
    const isLikeArray = function( pArg, pMustBeIterable = false )
    {
        if ( isArray( pArg ) || isString( pArg ) || isTypedArray( pArg ) )
        {
            return true;
        }

        if ( !isNull( pArg ) && !isNull( pArg?.length ) )
        {
            const keys = Object.keys( pArg );

            if ( keys.some( key => isNumeric( key ) ) )
            {
                return !pMustBeIterable || isIterable( pArg );
            }
        }

        return false;
    };

    /**
     * Returns true of the specified value is a Symbol<br>
     *
     * @param {*} pValue A value to evaluate
     *
     * @returns {boolean} true of the specified value is a Symbol
     *
     * @alias module:TypeUtils.isSymbol
     */
    const isSymbol = function( pValue )
    {
        return _symbol === typeof pValue || pValue instanceof Symbol;
    };

    /**
     * Returns true if the specified value cannot be modified<br>
     *
     * @function isReadOnly
     *
     * @see {@link constants.isReadOnly}
     *
     * @param {*} A value to evaluate
     *
     * @return {boolean} true if the value is immutable
     *
     * @alias module:TypeUtils.isReadOnly
     */
    const isReadOnly = constants?.isReadOnly || function( pObject )
    {
        return isObject( pObject ) && (isNull( pObject ) || Object.isFrozen( pObject ) || Object.isSealed( pObject ));
    };

    /**
     * Returns true if the specified value is of the type specified<br>
     * (or is an instance of the class specified)<br>
     *
     * @param {*} pValue A value to evaluate
     * @param {string|Function} pType The type to which to compare the type of the specified value<br>
     *                                (or a class of which the specified value is an instance)
     *
     * @returns {boolean} true if the specified value is of the type specified
     *                    (or is an instance of the class specified)
     *
     * @alias module:TypeUtils.isType
     */
    const isType = function( pValue, pType )
    {
        const typeName = (isString( pType ) && JS_TYPES.includes( pType )) ?
                         (pType).trim().toLowerCase() :
                         typeof pType;

        if ( JS_TYPES.includes( typeName ) && (typeof pValue) === typeName )
        {
            return true;
        }

        if ( isObject( pValue ) && isFunction( pType ) )
        {
            return pValue instanceof pType;
        }

        return false;
    };

    /**
     * Returns true if the specified values are of the same type<br>
     *
     * @param  {...any} pValues Two or more values to compare by type
     *
     * @returns {boolean} true if the specified values are of the same type
     *
     * @alias module:TypeUtils.areSameType
     */
    const areSameType = function( ...pValues )
    {
        let areSame = true;

        if ( !isNull( pValues ) )
        {
            const values = isLikeArray( pValues, true ) ? [...pValues] : [pValues || _mt_str];

            let first = values[0];

            let types = [typeof first];

            if ( [_num, _big].includes( typeof first ) )
            {
                types.push( _num, _big );
            }

            for( let i = 1, n = values.length; i < n; i++ )
            {
                let value = values[i];

                if ( !types.includes( typeof value ) )
                {
                    areSame = false;
                    break;
                }
            }
        }

        return areSame;
    };

    /**
     * Returns true if the provided values are of compatible types.<br>
     * <br>
     * The function first checks if all the values are of the same type using the `areSameType` function.<br>
     * <br>
     * If the types are the same, it returns true.<br>
     * If the types are not the same,<br>
     * the function further evaluates whether the values are not null,<br>
     * and whether their types can be reasonably coerced to a compatible type, such as number, bigint, or string.
     *
     * @param {...*} pValues - The values to be evaluated
     *
     * @returns {boolean} true if the values are of the same type or are all strings, numbers, or bigint values
     *
     * @alias module:TypeUtils.areCompatibleTypes
     */
    const areCompatibleTypes = function( ...pValues )
    {
        if ( areSameType( ...pValues ) )
        {
            return true;
        }

        if ( !isNull( pValues ) )
        {
            const values = isLikeArray( pValues, true ) ? [...pValues] : [pValues || _mt_str];

            const types = values.map( e => typeof e );

            return (types.every( e => [_num, _big, _str].includes( typeof e ) ));
        }

        return false;
    };

    /**
     * Returns true if the specified value is an instance of {@link Map}<br>
     * or, if not <i>strict</i>, returns true if the specified value is an object with only string keys<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider string-keyed objects (a.k.a. 'dictionaries') to be Maps
     *
     * @returns {boolean} true if the specified value is an instance of Map
     *
     * @alias module:TypeUtils.isMap
     */
    const isMap = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) || [_str, _num, _big, _bool, _symbol].includes( typeof pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof Map;
        }

        if ( isObject( pObject ) )
        {
            const entries = Object.entries( pObject );

            const strings = entries.filter( entry => isString( entry[0] ) && !(entry[0].startsWith( "[object" )) );

            return (entries.length === strings.length);
        }
        else if ( isFunction( pObject ) && pObject?.length === 1 )
        {
            // perhaps we have a function that takes a key and returns a value...
            return true;
        }

        return false;
    };

    /**
     * Returns true if the specified value is an instance of {@link Set}<br>
     * or, if not <i>strict</i>, returns true if the specified value is an array-like object with unique values<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider array-like objects that have unique values as if they are Sets
     *
     * @returns {boolean} true if the specified value is an instance of Set
     *
     * @alias module:TypeUtils.isSet
     */
    const isSet = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof Set;
        }

        if ( isLikeArray( pObject, true ) || pObject?.length >= 0 )
        {
            const length = pObject.length;
            let set = new Set( [...pObject] );
            return set?.size === length;
        }

        return false;
    };

    /**
     * Returns true if the specified object is an instance of Date<br>
     * or if not <i>strict</i>, if the specified object can be converted into a Date<br>
     *
     * @param {*} pObj A value to evaluate
     * @param {boolean} [pStrict=true] Specify false if you want to consider values that can be converted into a Date as Dates<br>
     * @param {Object|function} [pDateParser=null] An optional parameter used to specify a parser to convert strings into Dates
     *
     * @returns {boolean} true if the specified object is an instance of Date
     *
     * @alias module:TypeUtils.isDate
     */
    const isDate = function( pObj, pStrict = true, pDateParser = null )
    {
        if ( isUndefined( pObj ) || isNull( pObj ) )
        {
            return false;
        }

        let is = (pObj instanceof Date) || ("[object Date]" === {}.toString.call( pObj ) || (pObj.constructor === Date) || (pObj.prototype === Date));

        if ( is || pStrict )
        {
            return is;
        }

        let date = isObject( pObj ) && pObj instanceof Number ? new Date( pObj.valueOf() ) : (isNumber( pObj ) ? new Date( pObj ) : null);

        if ( !isNull( date ) )
        {
            is = isFunction( date.getTime ) && date.getTime() >= -30610202964000 && date.getTime() <= 7258140000000;
        }

        if ( !is && (isString( pObj ) || pObj instanceof String) )
        {
            if ( (isFunction( pDateParser ) || isFunction( pDateParser?.parse || pDateParser?.parseDate )) )
            {
                try
                {
                    date = (pDateParser.parse || pDateParser.parseDate || pDateParser).call( pDateParser, pObj );
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, `formatting ${pObj} as a date`, S_WARN, modName + "::isDate" );
                }
            }

            if ( isNull( date ) )
            {
                try
                {
                    date = new Date( pObj );
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, `evaluating ${pObj} as a Date`, S_ERROR, modName + "::isDate" );
                }
            }
        }
        else
        {
            return is && (date instanceof Date);
        }

        if ( null == date || !isDate( date, true ) )
        {
            switch ( typeof pObj )
            {
                case _str:
                case _num:
                case _big:
                    try
                    {
                        date = new Date( pObj );
                    }
                    catch( ex )
                    {
                        modulePrototype.reportError( ex, `evaluating ${pObj} as a Date`, S_ERROR, modName + "::isDate" );
                    }

                    break;
            }
        }

        return (isDate( date, true ));
    };

    /**
     * Returns true if the specified value is an instance of RegExp<br>
     * or, if not <i>strict</i>, if the specified value is a string representation of a regular expression<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider a string representation of a regular expression to be a RegExp
     *
     * @returns {boolean} true if the specified value is an instance of RegExp
     *
     * @alias module:TypeUtils.isRegExp
     */
    const isRegExp = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof RegExp;
        }

        const s = _mt_str + (isString( pObject ) ? String( pObject ) : (isFunction( pObject.toString ) ? pObject.toString() : {}.toString.call( pObject, pObject )));

        let pattern = s.replace( /\/[gimsuy]+$/, "/" ).trim();

        if ( /^\/.+\/$/.test( pattern ) )
        {
            pattern = pattern.replace( /\/$/, _mt_str ).replace( /^\//, _mt_str );

            try
            {
                let regExp = new RegExp( pattern );
                return isRegExp( regExp );
            }
            catch( ex )
            {
                // ignored
            }
        }

        return false;
    };

    /**
     * Returns true if the value passed represents a JavaScript Class<br>
     * JavaScript classes return "function" for the typeof operator,<br>
     * so this function is necessary to determine the difference<br>
     * between a function and a class definition<br>
     *
     * @param {function} pFunction A function to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider built-in types as classes
     *
     * @returns {boolean} true if the function specified is a class definition
     *
     * @alias module:TypeUtils.isClass
     */
    const isClass = function( pFunction, pStrict = true )
    {
        if ( isFunction( pFunction ) || ( !pStrict && BUILTIN_TYPE_NAMES.includes( pFunction?.name )) )
        {
            if ( /^class\s/.test( (Function.prototype.toString.call( pFunction, pFunction )).trim() ) )
            {
                return true;
            }

            return !pStrict && BUILTIN_TYPE_NAMES.includes( pFunction?.name );
        }

        return false;
    };

    /**
     * Returns true if the specified object is an instance of one (or more) of the specified classes<br>
     *
     * @param {Object} pObject An object to evaluate
     * @param pClasses {...function} One or more classes to which to compare the specified object's prototype<br>
     *
     * @returns {boolean} true if the specified object is an instance of one (or more) of the specified classes<br>
     *
     * @alias module:TypeUtils.instanceOfAny
     */
    const instanceOfAny = function( pObject, ...pClasses )
    {
        const classes = [].concat( ...(pClasses || []) ) || [];

        let is = false;

        while ( !is && classes?.length )
        {
            const cls = classes.shift();

            if ( isClass( cls, !BUILTIN_TYPE_NAMES.includes( cls?.name ) ) )
            {
                try
                {
                    is = (pObject instanceof cls) || pObject.prototype === cls;
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, "attempting to call instanceof without a class or callable", S_WARN, modName + "::instanceOfAny" );
                }
            }
        }

        return is;
    };

    /**
     * Returns true if the specified function is a class that is not a built-in JavaScript type<br>
     *
     * @param {function} pFunction A function to evaluate
     *
     * @returns {boolean} true if the specified function is a class that is not a built-in JavaScript type<br>
     *
     * @alias module:TypeUtils.isUserDefinedClass
     */
    const isUserDefinedClass = function( pFunction )
    {
        return isClass( pFunction );
    };

    /**
     * Returns true if the specified function is one or the specified classes<br>
     *
     * @param {function} pFunction A function to evaluate
     * @param {...function} pListedClasses One or more classes to which to compare the specified function<br>
     *
     * @returns {boolean} true if the specified function is one or the specified classes
     *
     * @alias module:TypeUtils.isListedClass
     */
    const isListedClass = function( pFunction, ...pListedClasses )
    {
        return isClass( pFunction ) && instanceOfAny( new pFunction(), ...pListedClasses );
    };

    /**
     * Returns true if the specified object is an instance of a class that is not a built-in JavaScript type<br>
     *
     * @param {Object} pObject An object to evaluate
     * @param {function} [pClass=null] Specify a specific class to restrict the comparison to a specific user-defined class
     *
     * @returns {boolean} true if the specified object is an instance of a class that is not a built-in JavaScript type
     *
     * @alias module:TypeUtils.isInstanceOfUserDefinedClass
     */
    const isInstanceOfUserDefinedClass = function( pObject, pClass = null )
    {
        let clazz = isClass( pClass ) ? pClass || pObject?.constructor : pObject?.constructor || pObject?.prototype?.constructor || pObject?.prototype;
        return isUserDefinedClass( clazz ) && (null === clazz || instanceOfAny( pObject, clazz ));
    };

    /**
     * Returns true if the specified object is an instance of one or more of the specified classes
     * <br>
     *
     * @param {Object} pObject An object to evaluate
     * @param {...function} pListedClasses One or more classes to which to compare the specified object's prototype
     *
     * @returns {boolean} true if the specified object is an instance of one or more of the specified classes
     *
     * @alias module:TypeUtils.isInstanceOfListedClass
     */
    const isInstanceOfListedClass = function( pObject, ...pListedClasses )
    {
        return instanceOfAny( pObject, ...pListedClasses );
    };

    /**
     * Returns the first of the candidates that is of the specified type<br>
     * (or null if no candidates meet the criterion)<br>
     *
     * @param  {string|function} pType The type an object must match to be returned
     * @param {...*} pCandidates One or more candidates, the first of which that matches the specified type will be returned
     *
     * @returns {*|null} The first of the candidates that is of the specified type (or null if no candidates meet the criterion)
     *
     * @alias module:TypeUtils.firstMatchingType
     */
    const firstMatchingType = function( pType, ...pCandidates )
    {
        let arr = !isNull( pCandidates ) ? (isArray( pCandidates ) ? [].concat( ...pCandidates ) : (isSpreadable( pCandidates ) ? [...pCandidates] : [])) : [];

        if ( isString( pType ) )
        {
            const type = pType.trim().toLowerCase();
            arr = VALID_TYPES.includes( type ) ? arr.filter( e => type === typeof e && !isNull( e ) ) : [];
        }
        else if ( isClass( pType, false ) )
        {
            arr = arr.filter( e => e instanceof pType );
        }
        else if ( isFunction( pType ) )
        {
            const scope = $scope();

            try
            {
                arr = arr.filter( e => pType.call( scope, e ) );
            }
            catch( ex )
            {
                modulePrototype.reportError( ex, "attempting to call a function to filter an array", S_WARN, modName + "::firstMatchingType", pType?.name );
            }
        }
        else
        {
            arr = [];
        }

        return arr.length > 0 ? arr[0] : null;
    };

    /**
     * Returns the class (function) of which the specified object is an instance
     * <br>
     * or the class itself if the specified value <i>is</i> a class (function)
     * <br>
     * @param {Object|function} pObject An instance of some class or a function that is a class
     * @param {Object} pOptions An object to pass options to the isClass method of TypeUtils
     *
     * @returns {function} The class of which the object is an instance
     *                     or the class itself if the object is a class function
     *
     * @alias module:TypeUtils.getClass
     */
    const getClass = function( pObject, pOptions = { strict: true } )
    {
        const options = Object.assign( { strict: true }, pOptions || {} );

        const obj = isObject( pObject, { rejectPrimitiveWrappers: false } ) || isFunction( pObject ) ? pObject || function() {} : null;

        if ( isNull( obj, true ) )
        {
            return null;
        }

        const strict = options?.strict;

        let clazz = isClass( obj, strict ) ? obj : obj?.constructor || obj?.prototype?.constructor || obj?.prototype || obj?.__proto__;

        if ( isClass( clazz, strict ) )
        {
            return clazz;
        }

        if ( obj )
        {
            if ( isClass( obj, strict ) )
            {
                clazz = obj;
            }

            if ( isClass( clazz, strict ) )
            {
                return clazz;
            }

            let _class = clazz;

            const iterationLimit = 5;
            let iterations = 0;

            // the IterationCap object will return reached when iterations exceed the cap,
            // so ignore the linter warnings
            // noinspection LoopStatementThatDoesntLoopJS
            while ( !isClass( _class, strict ) && (iterations++ <= iterationLimit) )
            {
                switch ( iterations )
                {
                    case 0:
                    case 1:
                        _class = (obj.constructor || obj?.prototype?.constructor) || _class;
                        break;

                    case 2:
                        _class = (obj?.prototype?.constructor || isClass( obj?.prototype, strict ) ? obj?.prototype : _class);
                        break;

                    case 3:
                        _class = isClass( obj?.prototype, strict ) ? obj?.prototype : _class;
                        break;

                    case 4:
                        _class = isClass( obj?.__proto__, strict ) ? obj?.__proto__ : _class;
                        break;

                    default:
                        break;
                }
            }

            clazz = (isClass( _class, strict ) ? _class : (isClass( clazz, strict ) ? clazz : (isClass( clazz ) ? clazz : Object))) || Object;

            if ( clazz && Object === clazz )
            {
                if ( obj instanceof Date )
                {
                    clazz = Date;
                }
                else if ( obj instanceof RegExp )
                {
                    clazz = RegExp;
                }
                else if ( obj instanceof Boolean )
                {
                    clazz = Boolean;
                }
                else if ( obj instanceof String )
                {
                    clazz = String;
                }
                else if ( obj instanceof Number )
                {
                    clazz = Number;
                }
            }
        }

        return clazz;
    };

    /**
     * Returns the name of the class of which the specified object is an instance
     * <br>
     * or the name of the class if the specified value <i>is</i> a class (function)
     * <br>
     * @param {Object|function} pObject An instance of some class or a function that is a class
     *
     * @returns {string} The name of the class of which the object is an instance
     * or the name of the class if the object is a class function
     *
     * @alias module:TypeUtils.getClassName
     */
    const getClassName = function( pObject )
    {
        const obj = isObject( pObject, { rejectPrimitiveWrappers: false } ) || isFunction( pObject ) ? pObject || function() {} : null;

        if ( isNull( obj, true ) )
        {
            return _mt_str;
        }

        let name = _mt_str;

        if ( obj )
        {
            if ( isClass( obj, false ) )
            {
                name = String( obj.name || (obj.constructor?.name) );
            }
            else if ( isObject( obj ) )
            {
                const clazz = getClass( obj, { strict: false } );
                if ( clazz )
                {
                    name = getClassName( clazz );
                }
            }

            if ( (_mt_str === name.trim()) )
            {
                name = String( obj?.constructor?.name || obj?.prototype?.constructor?.name || obj?.prototype?.name );
            }
        }

        return name;
    };

    /**
     * Returns the default value for the type specified
     *
     * @param {string} pType The type for which to return a default value
     * @see {@link TYPE_DEFAULTS}
     * @returns {*}
     *
     * @alias module:TypeUtils.defaultFor
     */
    const defaultFor = function( pType )
    {
        let type = isString( pType ) ? (_mt_str + pType).trim().toLowerCase() : typeof (pType);

        if ( isString( type ) && JS_TYPES.includes( type ) )
        {
            return TYPE_DEFAULTS[type];
        }

        return defaultFor( typeof type );
    };

    /**
     * Returns a new value converted to the specified type, if possible
     * <br>
     * @param {*} pValue A value to convert to the specified type
     * @param {string} pType The type to which to convert the specified value, if possible
     *
     * @returns {*} a new value converted to the specified type, if possible
     *
     * @alias module:TypeUtils.castTo
     */
    const castTo = function( pValue, pType )
    {
        let type = isString( pType ) ? (_mt_str + pType).trim().toLowerCase() : typeof (pType);

        type = isString( type ) && VALID_TYPES.includes( type ) ? type : _str;

        let value = !isNull( pValue, true ) ? pValue : pValue || null;

        switch ( type )
        {
            case _str:
                value = (isFunction( value?.asString )) ? value.asString() : (_mt_str + value);
                break;

            case _num:
            case _big:
                try
                {
                    value = (isFunction( value?.asFloat )) ? value.asFloat() : parseFloat( value );
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, `casting ${value} to number`, S_WARN, modName + "::castTo" );
                }
                break;

            case _bool:
                value = Boolean( value );
                break;

            case _obj:
                switch ( typeof value )
                {
                    case _obj:
                        break;

                    case _str:
                        value = new String( value );
                        break;

                    case _num:
                        value = new Number( value );
                        break;

                    case _big:
                        value = new Number( BigInt( value ) );
                        break;

                    case _bool:
                        value = new Boolean( value );
                        break;

                    default:
                        break;
                }
                break;

            default:
                break;
        }
        return value;
    };

    const NVL = function( ...pValue )
    {
        let arr = [].concat( ...pValue );
        arr = arr.filter( e => !isNull( e ) );
        return arr.length > 0 ? arr[0] : null;
    };

    /**
     * This class can be used to convert any non-null value into an iterable.
     * <br>
     * Unlike JavScript's built-in iterators, this class's iterator can be traversed in reverse and/or reset
     * <br>
     *
     * alias module:TypeUtils._Iterable
     *
     * @class
     *
     * @protected
     */
    class _Iterable
    {
        #iterable;
        #arrayLike;
        #iterator;
        #index = 0;

        #iterated = [];

        /**
         * @constructor
         *
         * @param {*} pIterable Any value to be treated as an iterable
         *
         * @return {_Iterable} A new iterable that can be used to iterate the value(s) with which it was constructed
         */
        constructor( pIterable )
        {
            this.#iterable = isIterable( pIterable ) ? pIterable : [pIterable];
            this.#iterable = isString( this.#iterable ) ? [].concat( this.#iterable.split( _mt_str ) ) : this.#iterable;

            if ( isLikeArray( this.#iterable ) )
            {
                this.#arrayLike = [...this.#iterable];
            }
            else if ( isMap( this.#iterable ) || isSet( this.#iterable ) )
            {
                this.#arrayLike = [...this.#iterable.values()];
            }

            if ( isIterable( this.#iterable ) )
            {
                this.#iterator = this.#iterable[Symbol.iterator]();
            }
        }

        [Symbol.species]()
        {
            return this;
        }

        [Symbol.iterator]()
        {
            return this;
        }

        next()
        {
            if ( this.#arrayLike?.length )
            {
                if ( this.#index >= this.#iterable.length )
                {
                    return { done: true };
                }

                const value = this.#iterable[this.#index++];

                this.#iterated.push( value );

                return { value, done: false };
            }

            return this.#iterator?.next();
        }

        previous()
        {
            if ( this.#index > 0 )
            {
                if ( this.#arrayLike?.length )
                {
                    const value = this.#iterable[--this.#index];
                    return { value, done: false };
                }
                return this.#iterated[--this.#index];
            }
            return { done: true };
        }

        reset()
        {
            this.#index = 0;
        }

        reverseIterator()
        {
            if ( this.#arrayLike?.length )
            {
                let newIterable = [...this.#iterable].reverse();
                return new this.constructor( newIterable );
            }
            modulePrototype.reportError( new Error( "cannot reverse this iterator" ), "attempting to reverse an iterator", S_ERROR, modName + "::_Iterable::reverseIterator" );
            return this.#iterated.reverse();
        }
    }

    /**
     * This subclass of _Iterable just returns done immediately
     * @class
     * @extends _Iterable
     *
     * alias module:TypeUtils.NullIterator
     *
     *
     * @protected
     *
     *
     */
    class NullIterator extends _Iterable
    {
        constructor()
        {
            super( [] );
        }

        next()
        {
            return { done: true };
        }

        previous()
        {
            return { done: true };
        }
    }

    /**
     * Returns an _Iterable for the specified value
     *
     * @param pArrayLike almost any kind of value,
     *                   but generally expected to be an "indexable" collection of values
     *                   strings are converted into an array of characters,
     *                   scalar values are converted into a 1-element array containing the value
     *
     * @returns {_Iterable} an instance of _Iterable
     */
    const toIterable = function( pArrayLike )
    {
        switch ( typeof pArrayLike )
        {
            case _ud:
                return new NullIterator();

            case _str:
                return new _Iterable( pArrayLike.split( _mt_str ) );

            case _num:
            case _big:
            case _bool:
                return new _Iterable( [pArrayLike] );

            case _fun:
                if ( isGeneratorFunction( pArrayLike ) )
                {
                    return pArrayLike();
                }

                return new _Iterable( [pArrayLike] );

            case _obj:
                if ( isArray( pArrayLike ) )
                {
                    return new _Iterable( pArrayLike );
                }

                if ( pArrayLike instanceof Map )
                {
                    return new _Iterable( [...pArrayLike.entries()] );
                }

                if ( pArrayLike instanceof Set )
                {
                    return new _Iterable( [...pArrayLike] );
                }

                if ( isDate( pArrayLike ) )
                {
                    return new _Iterable( [pArrayLike] );
                }

                if ( isIterable( pArrayLike ) )
                {
                    return new _Iterable( pArrayLike );
                }

                const newObject = {};

                const entries = Object.entries( pArrayLike );

                for( let entry of entries )
                {
                    const key = entry[0];

                    const value = entry[1];

                    newObject[key] = toIterable( value );
                }

                return new _Iterable( Object.entries( newObject ) );

            default:
                return new NullIterator();
        }
    };

    /**
     * This class represents the common, functional programming inspired, Option or Maybe type<br>
     * @see https://en.wikipedia.org/wiki/Option_type
     *
     * @class
     *
     * @alias module:TypeUtils#classes#Option
     *
     */
    class Option
    {
        #value;

        constructor( pValue )
        {
            this.#value = (pValue instanceof this.constructor) ? pValue.#value : pValue;
        }

        get value()
        {
            return lock( this.#value );
        }

        static Some( pValue )
        {
            return new Option( pValue );
        }

        static None()
        {
            return new Option( null );
        }

        isSome()
        {
            return (null !== this.#value);
        }

        isNone()
        {
            return isUndefined( this.#value ) || null === this.#value;
        }

        map( pFunction )
        {
            const func = isFunction( pFunction ) ? pFunction : ( e ) => e;
            return this.isSome() ? Option.Some( func( this.#value ) ) : Option.None();
        }

        flatMap( pFunction )
        {
            const func = isFunction( pFunction ) ? pFunction : ( e ) => e;
            return this.map( func ).getOrElse( Option.None() );
        }

        getOrElse( pDefault )
        {
            return this.isSome() ? this.value : pDefault;
        }
    }

    /**
     * This class extends Option and requires that the 'Some' value be of the type specified<br>
     *
     * @class
     * @extends Option
     *
     * @alias module:TypeUtils#classes#TypedOption
     */
    class TypedOption extends Option
    {
        #type;

        constructor( pValue, pType )
        {
            super( pValue );

            this.#type = pType;
        }

        get type()
        {
            return this.#type || _obj;
        }

        static Some( pValue, pType )
        {
            return new TypedOption( pValue, pType );
        }

        static None()
        {
            return new Option( null );
        }

        isSome()
        {
            return super.isSome() && isType( this.value, this.type );
        }

        isNone()
        {
            return super.isNone() || !isType( this.value, this.type );
        }

        map( pFunction )
        {
            const type = this.type;

            const func = isFunction( pFunction ) ? pFunction : ( e ) => castTo( e, type );

            return super.map( func );
        }

        flatMap( pFunction )
        {
            const type = this.type;

            const func = isFunction( pFunction ) ? pFunction : ( e ) => castTo( e, type );

            return super.flatMap( func );
        }

        getOrElse( pDefault )
        {
            const value = super.getOrElse( pDefault );

            if ( this.type === typeof (value) )
            {
                return value;
            }

            if ( this.type === typeof (pDefault) )
            {
                return pDefault;
            }
        }
    }

    /**
     * This class extends TypedOption and requires that the 'Some' value be a string<br>
     *
     * @class
     *
     * @extends TypedOption
     *
     * @alias module:TypeUtils#classes#StringOption
     */
    class StringOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _str );
        }
    }

    /**
     * This class extends TypedOption and requires that the 'Some' value be a number
     * <br>
     * @class
     * @extends TypedOption
     * @alias module:TypeUtils#classes#NumericOption
     */
    class NumericOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _num );
        }
    }

    /**
     * This class extends TypedOption and requires that the 'Some' value be a boolean
     * <br>
     * @class
     * @extends TypedOption
     * @alias module:TypeUtils#classes#BooleanOption
     */
    class BooleanOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _bool );
        }
    }

    /**
     * This class represents the return value of a function<br>
     * that might return null or throw exceptions<br>
     * <br>
     * This class extends Option,<br>
     * so you can use getOrElse or check for isSome or isNone,<br>
     * as well as check for whether the function has thrown an error
     * <br>
     * <br>
     * Functions that return a Result<br>
     * should catch errors and then add them to the Result before returning,<br>
     * rather than throw an Error<br>
     * <br>
     * This style of programming can reduce the effort of checking for null
     * <br>
     * or of wrapping function calls in try/catch blocks
     * <br>
     *
     * @class
     * @extends Option
     * @alias module:TypeUtils#classes#Result
     */
    class Result extends Option
    {
        #exceptions = [];

        constructor( pValue, pErrors = [] )
        {
            super( pValue );

            this.#exceptions = [].concat( pErrors || [] ).flat();
        }

        get returnValue()
        {
            return super.getOrElse( null );
        }

        get exceptions()
        {
            return [].concat( this.#exceptions ).flat();
        }

        addErrors( ...pError )
        {
            this.#exceptions.push( ...pError );
            this.#exceptions = this.#exceptions.flat();
        }

        hasErrors()
        {
            return (this.#exceptions?.length || 0) > 0;
        }
    }

    /**
     * This is the module itself, exported from this function
     */
    let mod =
        {
            dependencies,
            JS_TYPES,
            VALID_TYPES,
            TYPE_DEFAULTS,
            TYPE_SORT_ORDER,
            BYTES_PER_TYPE,
            isUndefined,
            isDefined,
            isNull,
            isNotNull,
            isNonNullValue,
            isPrimitiveWrapper,
            isObject,
            isCustomObject,
            isNonNullObject,
            isError,
            firstError,
            isFunction,
            isAsyncFunction,
            isGeneratorFunction,
            isString,
            isEmptyString,
            isNumber,
            isInteger,
            isFloat,
            isBigInt,
            isNumeric,
            isZero,
            isBinary,
            isOctal,
            isHex,
            isDecimal,
            isNanOrInfinite,
            toDecimal,
            toHex,
            toOctal,
            toBinary,
            isBoolean,
            isArray,
            isTypedArray,
            isIterable,
            isAsyncIterable,
            isLikeArray,
            isSpreadable,
            isMap,
            isSet,
            isDate,
            isRegExp,
            isClass,
            isUserDefinedClass,
            isListedClass,
            isInstanceOfUserDefinedClass,
            isInstanceOfListedClass,
            isSymbol,
            isType,
            areSameType,
            areCompatibleTypes,
            instanceOfAny,
            getClass,
            getClassName,
            defaultFor,
            castTo,
            toIterable,
            firstMatchingType,
            estimateBytesForType,
            NVL,
            isReadOnly,
            /**
             * The classes exported with this module.<br>
             * <br>
             * Classes:<br>
             * <ul>
             * <li><i></i>: </li>
             * </ul>
             * @alias module:TypeUtils#classes
             */
            classes: { VisitedSet, Option, TypedOption, StringOption, NumericOption, BooleanOption, Result },
            VisitedSet,
            Option,
            TypedOption,
            StringOption,
            NumericOption,
            BooleanOption,
            Result
        };

    mod = modulePrototype.extend( mod );

    return mod.expose( mod, INTERNAL_NAME, (_ud !== typeof module ? module : mod) ) || mod;

}());
