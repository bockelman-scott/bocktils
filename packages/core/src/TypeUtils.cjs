/**
 * @fileOverview
 * This module defines several utility functions for testing the typeof a value,<br>
 * converting between types, and finding elements based on their type.<br>
 * <br>
 * The original motivation for this module<br>
 * is that is a common source of bugs to type something like:<br>
 * <code>
 *     if( "string" === someVariable )
 * </code>
 * <br>
 * when what is intended is:<br>
 * <code>
 *     if( "string" === typeof someVariable )
 * </code>
 * <br>
 * This module also defines and exports the commonly-used quasi-functional programming constructs,<br>
 * <br>
 * {@Link Option}, {@link TypedOption}, and {@link Result}<br>
 * <br>
 * as well as functions for converting numbers to and from hexadecimal, octal, binary, and decimal forms.<br>
 * <br>
 *
 *
 * @module TypeUtils
 *
 * @author Scott Bockelman
 * @license MIT
 */

const moduleUtils = require( "./_ToolBocksModule.cjs" );

/* import the Constants.cjs we depend upon, using "require" for maximum compatibility with Node versions */
const constants = require( "./Constants.cjs" );

/**
 * Defines a string to represent the type, undefined
 */
const { _ud = "undefined", $scope } = constants;

// noinspection FunctionTooLongJS,JSUnresolvedReference
/**
 * This module is constructed by an Immediately Invoked Function Expression (IIFE).
 * see: <a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE">MDN: IIFE</a> for more information on this design pattern
 */
(function exposeModule()
{
    /**
     * Defines a string key which is unlikely to collide with other libraries or properties.
     * We use this to store the module generated by this function in global scope.
     * We can avoid re-executing the rest of this function if the module is already defined.
     */
    const INTERNAL_NAME = "__BOCK__TYPE_UTILS__";

    /**
     * Checks to see if this module is already defines and available in the global scope
     * Returns the existing module instead of recreating it, if it is already present.
     */
    if ( $scope() && (null != $scope()[INTERNAL_NAME]) )
    {
        return $scope()[INTERNAL_NAME];
    }

    const
        {
            ToolBocksModule,
            ModuleEvent,
            IterationCap,

            $ln,
            $nth,
            $last,

            functionToString,
            objectToString,
            errorToString,

            TYPES_CHECKS,

            propertyDescriptors,

            AsyncFunction,
            ObjectEntry,
            IllegalArgumentError,

            TRANSIENT_PROPERTIES,

            resolveVisitor,
            resolveError,
            resolveEvent,
            resolveObject,
            resolveLogLevel,
            resolveMethod,
            resolveTransientProperties,

            canBind,

            attempt,
            asyncAttempt,
            attemptSilent,
            detectCycles,

            isObjectLiteral,
            toNodePathArray,
            getProperty,
            setProperty,
            hasProperty,
            populateOptions,

            lock,

            OBJECT_REGISTRY = $scope()["__BOCK_OBJECT_REGISTRY__"],
            objectEntries,
            objectKeys,
            objectValues,
            objectMethods,

            isPromise = ( pArg ) => (pArg && (pArg.constructor === Promise || pArg === Promise || pArg instanceof Promise)),
            isThenable = ( pArg ) => (pArg && (pArg.then && ("function" === typeof pArg.then)))

        } = moduleUtils;

    const
        {
            _str,
            _fun,
            _num,
            _big,
            _bool,
            _obj,
            _symbol,

            _mt_str,
            _mt = _mt_str,

            _dblqt,
            _sglqt,

            _dot,
            _comma,
            _minus,
            _zero,

            _underscore,
            _hash,

            _tilde,
            _pipe,

            _affirmatives,

            DIGITS,
            DIGITS_MAP,
            HEX_DIGITS_MAP,
            OCT_DIGITS_MAP,
            BIN_DIGITS_MAP,

            S_ERROR,
            S_WARN,

            TYPED_ARRAYS,
            PRIMITIVE_WRAPPER_TYPES,
            BUILTIN_TYPES,
            BUILTIN_TYPE_NAMES,

            RX_BIG_INT = /^[\d_]+n$/
        } = constants;


    /**
     * This is a dictionary of this module's dependencies.
     * <br>
     * It is exported as a property of this module,
     * allowing us to just import this module<br>
     * and then import or use the other utilities<br>
     * as properties of this module.
     * <br>
     * @dict
     * @type {Object}
     * @alias module:TypeUtils#dependencies
     */
    const dependencies =
        {
            moduleUtils,
            constants
        };

    /**
     * Represents the name of the module<br>
     * This name is used when error events are emitted to indicate the source of the error.
     * @type {string}
     */
    const modName = "TypeUtils";

    /**
     * This is the object that is returned from this function.
     * <br>
     * This object is the TypeUtils module<br>
     * <br>
     * The variables and functions defined in this file are added to the module before it is exported and returned.
     * <br>
     * @type {ToolBocksModule}
     */
    let toolBocksModule = new ToolBocksModule( modName, INTERNAL_NAME );

    /**
     * This is an array of the 'valid' JavaScript primitive types.<br>
     * Note that 'undefined' is not considered to be a 'valid' type<br>
     * @namespace VALID_TYPES
     * @const
     * @readonly
     * @type {Array<string>}
     * @alias module:TypeUtils#VALID_TYPES
     */
    const VALID_TYPES = lock( [_str, _num, _big, _symbol, _bool, _obj, _fun] );

    /**
     * This is an array of all JavaScript primitive types.<br>
     * This includes all the 'valid' types AND 'undefined'<br>
     * @namespace JS_TYPES
     * @const
     * @readonly
     * @type {Array<string>}
     * @alias module:TypeUtils#JS_TYPES
     */
    const JS_TYPES = lock( [_ud].concat( VALID_TYPES ) );

    /**
     * This is an immutable array of the primitive types defined in JavaScript.<br>
     * These are the string, number, BigInt, symbol, and boolean types.<br>
     * <br>
     * @namespace PRIMITIVE_TYPES
     * @const
     * @readonly
     * @type {Array<string>}
     * @alias module:TypeUtils#PRIMITIVE_TYPES
     */
    const PRIMITIVE_TYPES = lock( [_str, _num, _big, _symbol, _bool] );

    /**
     * Returns true if the type of the specified value is a primitive data type.<br>
     * That is, it is not an object, function, or custom type.<br>
     * <br>
     *
     * @param {*} value - The value to evaluate
     * @returns {boolean} Returns true if the value is a primitive type, otherwise false.
     *
     * @function isPrimitive
     *
     * @alias module:TypeUtils.isPrimitive
     */
    const isPrimitive = ( value ) => PRIMITIVE_TYPES.includes( typeof value );

    /**
     * This object is a dictionary of the default values for each primitive type<br>
     * @namespace TYPE_DEFAULTS
     * @dict
     * @const
     * @readonly
     * @type {Object}
     * @alias module:TypeUtils#TYPE_DEFAULTS
     */
    const TYPE_DEFAULTS = lock(
        {
            [_str]: _mt_str,
            [_big]: 0n,
            [_num]: 0,
            [_bool]: false,
            [_fun]: null,
            [_obj]: null,
            [_symbol]: null,
            [_ud]: undefined
        } );

    /**
     * A map of the JavaScript data types to their respective sort order.<br>
     * <br>
     * This object provides a standardized order for sorting or categorizing types.<br>
     * Each key corresponds to a specific data type, with an associated
     * numerical value indicating its order in comparison to others.<br>
     * <br>
     * <br>
     * Keys/Values:<br>
     * <ul>
     *
     *   <li>"number": The lowest sort order (0).</li>
     *   <li>"bigint": The next lowest sort order (1)</li>
     *   <li>"boolean": The next lowest sort order (2)</li>
     *   <li>"string": The next lowest sort order (3)</li>
     *   <li>"object": The next lowest sort order (4)</li>
     *   <li>"function": The next lowest sort order (5)</li>
     *   <li>"symbol": The next lowest sort order (6)</li>
     *   <li>"undefined": The highest sort order (7)</li>
     *
     *  </ul>
     *
     * @namespace TYPE_SORT_ORDER
     * @dict
     * @const
     * @readonly
     * @type {Object}
     * @alias module:TypeUtils#TYPE_SORT_ORDER
     */
    const TYPE_SORT_ORDER = lock(
        {
            [_num]: 0,
            [_big]: 1,
            [_bool]: 2,
            [_str]: 3,
            [_obj]: 4,
            [_fun]: 5,
            [_symbol]: 6,
            [_ud]: 7
        } );

    /**
     * An object that maps data types to their estimated size in bytes.
     * <br>
     * Note that these values are estimates only<br>
     * and that the types, symbol, object, and function<br>
     * cannot be estimated; they must be calculated at runtime.<br>
     * <br>
     * Finally, the estimated number of bytes for the String type is actually 'bytes per character'<br>
     * <br>
     * @namespace BYTES_PER_TYPE
     * @dict
     * @const
     * @readonly
     * @type {Object}
     * @alias module:TypeUtils#BYTES_PER_TYPE
     */
    const BYTES_PER_TYPE = lock(
        {
            [_str]: 2,
            [_big]: 16,
            [_num]: 8,
            [_bool]: 1,
            [_fun]: 0,
            [_obj]: 0,
            [_symbol]: 0,
            [_ud]: 0
        }
    );

    /**
     * Returns the estimated number of bytes required to represent the specified data type.
     * <br>
     * <br>
     * Note that these values are <i>estimates</i> only<br>
     * and that the types, symbol, object, and function<br>
     * cannot be estimated; they must be calculated at runtime.<br>
     * <br>
     * Finally, the estimated number of bytes for the string type is actually 'bytes per character'
     * <br>
     *
     * @function estimateBytesForType
     *
     * @param {string} pType - The JavaScript data type to estimate memory usage for.
     *
     * @returns {number} - The estimated number of bytes for the given type.<br>
     *                     <br>
     *                     Returns:<br>
     *                     2 (bytes per character) for strings (assuming UTF-16 encoding),<br>
     *                     8 for numbers (IEEE 754 double-precision),<br>
     *                     16 for big integers (an arbitrary assumption),<br>
     *                     1 for booleans,<br>
     *                     0 for symbols and functions (size indeterminable),<br>
     *                     0 for objects (dynamic size, indeterminable),<br>
     *                     and -1 for unsupported or unknown types.<br>
     *
     *  @alias module:TypeUtils.estimateBytesForType
     */
    const estimateBytesForType = function( pType )
    {
        const type = (_mt_str + pType).toLowerCase();
        return (BYTES_PER_TYPE[type] || ([0, 2, 8, 16, 0, 1, 0, 0][Math.max( 0, JS_TYPES.indexOf( type ) )]) || 0);
    };

    /**
     * This oddly named function, so as not to collide with 'isArray',<br>
     * is used to polyfill Array for ancient browsers or non-spec execution environments<br>
     *
     * @function _isArr
     *
     * @param {*} pArg a value to evaluate
     *
     * @returns {boolean} true if the specified argument is an Array
     *
     * @private
     */
    let _isArr = ( pArg ) => !(_ud === typeof pArg || null == pArg) && ((_fun === typeof Array.isArray ? Array.isArray( pArg ) : "[object Array]" === objectToString.call( pArg, pArg )));

    if ( _fun === typeof Array.isArray )
    {
        _isArr = ( pVal ) => Array.isArray( pVal );
    }
    else
    {
        // poly-fill for isArray; probably obsolete with modern environments
        if ( _fun !== typeof Array.isArray )
        {
            toolBocksModule.attempt( () => Array.isArray = _isArr );
        }
    }

    /**
     * Returns true if the specified value is undefined<br>
     *
     * @function isUndefined
     *
     * @param {*} pObject A value to evaluate
     *
     * @returns {boolean} true if the specified value is undefined
     *
     * @alias module:TypeUtils.isUndefined
     */
    const isUndefined = ( pObject ) => (_ud === typeof pObject || undefined === pObject);

    /**
     * Returns true if the specified value IS defined.<br>
     * This is just an inversion of {@link isUndefined}
     *
     * @function isDefined
     *
     * @param {*} pObject A value to evaluate
     *
     * @returns {boolean} true if the specified value is defined
     *
     * @see {@link isUndefined}
     *
     * @alias module:TypeUtils.isDefined
     */
    const isDefined = ( pObject ) => !isUndefined( pObject );

    /**
     * Returns true if the specified value is a string or a {@link String} object<br>
     *
     * @function isString
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is a string or a String
     *
     * @alias module:TypeUtils.isString
     */
    const isString = ( pObj ) => (_str === typeof pObj) || pObj instanceof String;

    const isUUID = ( pVal ) => (isString( pVal ) && (/^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/i).test( String( pVal ) ));

    /**
     * Returns true if the specified value is an empty string.<br>
     * <br>
     * A value is considered to be an empty string<br>
     * if it is strictly of type "string"<br>
     * and either has a length of 0 or matches the pre-defined empty string constant.<br>
     * <br>
     *
     * @function isEmptyString
     *
     * @param {*} pObject - The value to be evaluated.
     *
     * @returns {boolean} Returns true if the input is an empty string; otherwise, returns false.
     *
     * @alias module:TypeUtils.isEmptyString
     */
    const isEmptyString = ( pObject ) => isString( pObject ) && (_mt_str === pObject || 0 === $ln( pObject ));

    /**
     * Returns true if the specified value is a string consisting of only whitespace.<br>
     * <br>
     * A value is considered to be a blank string<br>
     * if it is strictly of type "string"<br>
     * and if when trimmed has a length of 0.<br>
     * <br>
     *
     * @function isBlankString
     *
     * @param {*} pObject - The value to be evaluated.
     *
     * @returns {boolean} Returns true if the input is string containing only whitespace; otherwise, returns false.
     *
     * @alias module:TypeUtils.isBlankString
     */
    const isBlankString = ( pObject ) => isString( pObject ) && (_mt_str === pObject.trim() || 0 === $ln( pObject.trim() ));

    /**
     * Returns true if the specified value is null<br>
     * (or, when not <i>strict</i>, undefined or an empty string)<br>
     * <br>
     * The default behavior is non-strict<br>
     * and will return true for any value that is null, undefined, or an empty string.<br>
     * <br>
     *
     * @function isNull
     *
     * @param {*} pObject The value to evaluate
     * @param {boolean} pStrict Specify true to treat any value that is not <b>identical<b> to null as not-null<br>
     *
     * @returns {boolean} if the specified value is null (or, when not strict, undefined or an empty string)
     *
     * @alias module:TypeUtils.isNull
     */
    const isNull = ( pObject, pStrict = false ) => pStrict ? (null === pObject) : (isUndefined( pObject ) || null == pObject || isEmptyString( pObject ));

    /**
     * Returns true if the specified value is <i>NOT</i> null<br>
     * (or, when not <i>strict</i>, NOT undefined and NOT an empty string)<br>
     * <br>
     * The default behavior is non-strict and will return true<br>
     * for any value that is not null, undefined, or an empty string.<br>
     * <br>
     * This is just an inversion of {@link isNull}<br>
     *
     * @function isNotNull
     *
     * @param {*} pObject The value to evaluate
     * @param  {boolean} pStrict Specify true to treat any value that is not identical to null as not-null
     *
     * @returns {boolean} true if the specified value is NOT null (or, when not strict, NOT undefined and NOT an empty string)
     *
     * @see isNull
     *
     * @alias module:TypeUtils.isNotNull
     */
    const isNotNull = ( pObject, pStrict = false ) => !isNull( pObject, pStrict );

    /**
     * Returns true if the specified value is a Function.<br>
     * Or, if invoked with false as the second argument,<br>
     * the specified value is callable (via call() or apply())
     *
     * @function isFunction
     *
     * @param {*} pObj A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to return true for objects that define 'call' and 'apply' methods<br>
     *
     * @returns {boolean} true if the specified value is a Function<br>
     * (or when not invoked with strict, any object defining both a call and apply method)
     *
     * @alias module:TypeUtils.isFunction
     */
    const isFunction = ( pObj, pStrict = true ) => !isNull( pObj ) && (_fun === typeof pObj || ( !pStrict && (_fun === typeof pObj.call) && (_fun === typeof pObj.apply)));

    /**
     * Returns true if the specified value is an <i>asynchronous</i> Function<br>
     *
     * @function isAsyncFunction
     *
     * @param {*} pObject A value to evaluate
     * @returns {boolean} true if the specified value is an asynchronous Function
     *
     * @alias module:TypeUtils.isAsyncFunction
     */
    const isAsyncFunction = ( pObject ) => isFunction( pObject, true ) && (pObject.constructor === AsyncFunction || pObject === AsyncFunction);

    /**
     * Returns true if the specified value is a function that creates a generator<br>
     *
     * @function isGeneratorFunction
     *
     * @param {*} pObject A value to evaluate
     *
     * @returns {boolean} true if the specified value is a function that creates a generator
     *
     * @alias module:TypeUtils.isGeneratorFunction
     */
    const isGeneratorFunction = ( pObject ) => (isFunction( pObject ) && "[object Generator]" === objectToString.call( pObject.prototype, pObject.prototype ));

    const isPrivateMethod = ( pMethod, pPrivatePropertyPrefixes = [_hash] ) => isFunction( pMethod ) && [...pPrivatePropertyPrefixes || []].some( e => _toString( pMethod?.name ).startsWith( e ) );

    const isPrivateProperty = ( pProperty, pPrivatePropertyPrefixes = [_hash] ) => isString( pProperty ) && [...pPrivatePropertyPrefixes || []].some( e => _toString( pProperty ).trim().startsWith( e ) );

    const rxUrl = /((?<protocol>\w+):\/\/\/?)?((?<username>[^:@\s]+):(?<password>[^@\s]+)@)?(?<host>[^\/:]+)(:(?<port>(\d+)))?(\/(?<path>[^?#]+))?(?:\?(?<queryString>[^#]*))?(?:#(?<hash>[^#]*))?/;

    const isUrl = ( pUrl ) => (_ud !== typeof URL && isFunction( URL ) && pUrl instanceof URL) || (isString( pUrl ) && rxUrl.test( pUrl ));

    /**
     * Returns true if the specified value is an instance of String, Number, Boolean, or BigInt<br>
     *
     * @function isPrimitiveWrapper
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an instance of String, Number, Boolean, or BigInt
     *
     * @alias module:TypeUtils.isPrimitiveWrapper
     */
    const isPrimitiveWrapper = ( pObj ) => !isNull( pObj ) && [...PRIMITIVE_WRAPPER_TYPES].some( e => pObj instanceof e );

    /**
     * Returns the primitive type value of the specified object.<br>
     *
     * @param {*} pValue
     */
    const toPrimitive = function( pValue )
    {
        if ( _ud === typeof pValue || null === pValue )
        {
            return 0;
        }

        let value = isPrimitive( pValue ) ? pValue : (isPrimitiveWrapper( pValue ) ? pValue?.valueOf() : isDate( pValue ) ? pValue.getTime() : pValue);

        value = isPrimitive( value ) ? value : attempt( () => isFunction( value?.toString ) ? value.toString() : functionToString.call( value, value ) );

        return value;
    };

    /**
     * Attempts to convert a value to a string<br>
     *
     * @param {*} pObj
     *
     * @returns {string} A string representation of the specified value, if possible
     *
     * @private
     */
    function _toString( pObj )
    {
        if ( isString( pObj ) )
        {
            return String( isPrimitiveWrapper( pObj ) ? (pObj.valueOf() || toPrimitive( pObj ) || String( _mt + pObj )) : pObj );
        }
        return (0 === pObj || _zero === pObj || false === pObj) ? _zero : ((_mt + String( pObj ) + _mt).trim());
    }

    /**
     * @typedef {Object} ObjectEvaluationOptions
     *
     * @property [rejectPrimitiveWrappers=true] When true, instances of the Boolean, String, Number, and BigInt classes are not considered to be objects.<br>
     * @property [rejectArrays=false] When true, arrays are not considered to be objects<br>
     * @property [rejectNull=false] When true, null is not considered to be an object, even though typeof null === "object"
     * @property [allowEmptyObjects=true] When false, objects with no properties, i.e., Object.keys(obj).length === 0, are not considered objects
     */

    /**
     * This object defines the default options for the {@link isObject} function.<br>
     * @type {ObjectEvaluationOptions}
     * @alias module:TypeUtils#DEFAULT_IS_OBJECT_OPTIONS
     */
    const DEFAULT_IS_OBJECT_OPTIONS =
        lock( {
                  rejectPrimitiveWrappers: true,
                  rejectArrays: false,
                  rejectNull: false,
                  allowEmptyObjects: true
              } );

    /**
     * This object defines the default options for the {@link isNonNullObject} function.<br>
     * @type {ObjectEvaluationOptions}
     * @alias module:TypeUtils#IS_NON_NULL_OBJECT_OPTIONS
     */
    const IS_NON_NULL_OBJECT_OPTIONS = lock( { ...DEFAULT_IS_OBJECT_OPTIONS, rejectNull: true } );

    /**
     * Returns true if the specified value is an object.<br>
     * Use the options to clarify how to treat primitive wrappers, arrays, and nulls<br>
     *
     * @function isObject
     *
     * @see {@link DEFAULT_IS_OBJECT_OPTIONS}
     * @see {@link isPrimitiveWrapper}
     *
     * @param {*} pObject A value to evaluate
     * @param {ObjectEvaluationOptions} pOptions An object specifying how to handle arrays, null values, or primitive value wrappers<br>
     *
     * @returns {boolean} true if the specified value is an object according to the options specified
     *
     * @alias module:TypeUtils.isObject
     */
    const isObject = function( pObject, pOptions = DEFAULT_IS_OBJECT_OPTIONS )
    {
        if ( _obj === typeof pObject )
        {
            const options = { ...DEFAULT_IS_OBJECT_OPTIONS, ...(pOptions || {}) };

            const isEmpty = (pObject instanceof Map || pObject instanceof Set ? 0 === $ln( pObject ) : (null === pObject || 0 === $ln( Object.keys( pObject ) )));

            return !((options.rejectNull && isNull( pObject )) ||
                     (options.rejectArrays && _isArr( pObject )) ||
                     (options.rejectPrimitiveWrappers && isPrimitiveWrapper( pObject )) ||
                     ( !options.allowEmptyObjects && isEmpty));
        }

        return false;
    };

    /**
     * Returns true if the specified value is an object and is not null.<br>
     * <br>
     * Optionally, you can pass options to consider objects with no properties as 'null objects'<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} pStrict Specify true to treat any value that is not identical to null as not-null
     * @param pOptions {ObjectEvaluationOptions} An object to clarify how to handle objects that are not null, but have no properties, i.e., {}
     *
     * @param {Array.<string>} pStack
     *
     * @returns {boolean} true if the specified value is an object and is not null
     *
     * @alias module:TypeUtils.isNonNullObject
     */
    const isNonNullObject = function( pObject, pStrict = false, pOptions = IS_NON_NULL_OBJECT_OPTIONS, pStack = [] )
    {
        const options = { ...IS_NON_NULL_OBJECT_OPTIONS, ...(pOptions || {}) };

        if ( !isNull( pObject, pStrict ) && isObject( pObject, options ) )
        {
            if ( options.allowEmptyObjects )
            {
                return true;
            }

            const entries = objectEntries( pObject );

            const populatedEntry = ( entry ) =>
            {
                const val = entry.value || entry[1];
                return isNonNullValue( val ) &&
                       ( !isObject( val ) ||
                         isNonNullObject( val, pStrict, options, [...(pStack || []), entry.key] ));
            };

            const populated = ( entries ) => !isNull( entries.find( populatedEntry ) );

            return (entries?.length > 0) && ((detectCycles( pStack, 6, 3 )) || populated( entries ));
        }

        return false;
    };

    /**
     * Returns true if the specified value is an object that does not derive from the JavaScript {@link Object} type<br>
     *
     * @function isCustomObject
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an object that does not derive from the JavaScript Object type
     *
     * @alias module:TypeUtils.isCustomObject
     */
    const isCustomObject = ( pObj ) => isNonNullObject( pObj ) && pObj.prototype !== null && pObj.prototype !== Object && (pObj.constructor === null || pObj.constructor !== Object) && !isPrimitiveWrapper( pObj );

    const isWeakRef = ( pObj ) => isNonNullObject( pObj ) && (pObj instanceof WeakRef || isFunction( pObj?.deref ));

    /**
     * Returns true if the specified value is an object that represents an Error.<br>
     * That is, if the object is an instance of Error or a subclass of Error.<br>
     *
     * @function isError
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an object representing a runtime error
     *
     * @alias module:TypeUtils.isError
     */
    const isError = Error.isError || (( pObj ) => isObject( pObj ) && pObj instanceof Error);

    /**
     * Returns true if the specified value is an object that represents an Event<br>
     * That is, the object is an instance of Event, CustomEvent, or a subclass of Event or CustomEven
     *
     * @function isEvent
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an Event or CustomEvent or a subclass of either
     *
     * @alias module:TypeUtils.isCustomObject
     */
    const isEvent = ( pObj ) => isObject( pObj ) && (pObj instanceof Event || pObj instanceof CustomEvent || pObj instanceof ModuleEvent);

    /**
     * Returns true if the specified value is an array
     * <br>
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an array
     *
     * @alias module:TypeUtils.isArray
     */
    const isArray = ( pObj ) => !isNull( pObj ) && isObject( pObj ) && _isArr( pObj );

    /**
     * Returns true if the specified value is an instance of a {@link TypedArray}.
     *
     * @function isTypedArray
     *
     * @param {Object} pObj - The object to be evaluated.
     * @returns {boolean} Returns true if the object is an instance of any typed array<br>
     *                    (e.g., Int8Array, Uint8Array, Float32Array, etc.),<br>
     *                    otherwise false.
     *
     * @alias module:TypeUtils.isTypedArray
     */
    const isTypedArray = ( pObj ) => [...TYPED_ARRAYS].some( e => isObject( pObj ) && pObj instanceof e );

    /**
     * Returns true if the value passed represents a JavaScript Class<br>
     * JavaScript classes return "function" for the typeof operator,<br>
     * so this function is necessary to determine the difference<br>
     * between a function and a class definition<br>
     *
     * @param {function} pFunction A function to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider built-in types as classes
     *
     * @returns {boolean} true if the function specified is a class definition
     *
     * @alias module:TypeUtils.isClass
     */
    const isClass = function( pFunction, pStrict = true )
    {
        if ( isNull( pFunction ) || !isFunction( pFunction ) )
        {
            return false;
        }

        if ( !pStrict )
        {
            // Use the non-writable nature of class prototypes as a heuristic
            const descriptor = Object.getOwnPropertyDescriptor( pFunction, "prototype" );
            const isNativeClass = descriptor && !descriptor.writable;

            if ( isNativeClass )
            {
                return true;
            }
        }

        // Fallback for non-strict/transpiled environments
        if ( !pStrict )
        {
            return BUILTIN_TYPE_NAMES.includes( pFunction?.name ) || BUILTIN_TYPES.includes( pFunction );
        }

        return functionToString.call( pFunction ).startsWith( "class " );
    };

    function toNumericString( pObj, pDecimalSeparator = _dot, pGroupSeparator = _comma )
    {
        if ( isString( pObj ) )
        {
            let s = _toString( pObj ).trim().replaceAll( /_/g, _mt_str ).trim();

            s = s.replace( /n$/, _mt_str ).replace( /(n\s*\)\s*)$/, ")" );

            if ( _comma !== pGroupSeparator )
            {
                s = s.replaceAll( pGroupSeparator, _tilde );
                s = s.replaceAll( (_tilde + _tilde), _tilde );
            }

            if ( _dot !== pDecimalSeparator )
            {
                s = s.replaceAll( pDecimalSeparator, _pipe );
                s = s.replaceAll( (_pipe + _pipe), _pipe );
            }

            s = s.replaceAll( _tilde, _comma );
            s = s.replaceAll( _pipe, _dot );

            return s.replaceAll( /[,_]/g, _mt_str ).trim();
        }

        return pObj;
    }

    /**
     * Returns true if the specified value is a number or Number (and NOT a Date)<br>
     *
     * @function isNumber
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is a number or Number (and NOT a Date)
     *
     * @alias module:TypeUtils.isNumber
     */
    const isNumber = ( pObj ) => ([_num, _big].includes( typeof pObj ) || pObj instanceof Number || pObj instanceof BigInt) && !(isObject( pObj ) && pObj instanceof Date);

    /**
     * Returns true if the specified value is a BigInt.<br>
     *
     * @function isBigInt
     *
     * @param {*} pNum A value to evaluate
     *
     * @returns {boolean} true if the input is a BigInt and valid, otherwise false.
     *
     * @alias module:TypeUtils.isBigInt
     */
    const isBigInt = ( pNum ) => isNumber( pNum ) && (_big === typeof pNum || pNum instanceof BigInt);

    /**
     * Returns true if the value is NaN or is not Finite<br>
     * This combines the commonly used conditions,<br>
     * <code>isNaN( num ) || !isFinite( num )</code>
     * <br>
     *
     * @function isNanOrInfinite
     *
     * @param {*} pNum A value to evaluate
     *
     * @returns {boolean} true if the specified value is not a number or is NaN or is not Finite
     *
     * @alias module:TypeUtils.isNanOrInfinite
     */
    const isNanOrInfinite = function( pNum )
    {
        if ( !([_num, _big, _str].includes( typeof pNum ) || pNum instanceof Number) )
        {
            return true;
        }
        const num = parseFloat( pNum );
        return isNaN( num ) || !isFinite( num );
    };

    /**
     * Returns true if the specified value can be expressed as an integer (or zero).<br>
     * That is, the value is a natural number, a.k.a. "whole number" and contains no powers of a base less than 1<br>
     * <br>
     *
     * @function isInteger
     *
     * @param {number|string} pObj A value to evaluate
     * @param {boolean} pStrict If true, the specified value must be a number; strings will not be parsed
     *
     * @returns {boolean} true if the specified value can be expressed as an integer (or zero) without any loss of precision
     *
     * @alias module:TypeUtils.isInteger
     */
    const isInteger = function( pObj, pStrict = true )
    {
        let is = (0 === pObj) || (isNumber( pObj ) && !isNanOrInfinite( pObj ) && (parseInt( pObj ) === pObj));

        if ( !is && !pStrict && isString( pObj ) && isNumeric( pObj ) )
        {
            let n = parseFloat( pObj );

            if ( !isNanOrInfinite( n ) && isInteger( n, true ) )
            {
                let s = (_mt_str + String( n )).trim();

                return s === (_mt_str + String( pObj )).trim();
            }
        }

        return is;
    };

    /**
     * Returns true if the specified value cannot be expressed as an integer (or zero).<br>
     * That is, if isInteger( n ) would return true, this function would return false,<br>
     * unless the value is 0, which we treat as a special case and also consider to be a float.<br>
     *
     * @function isFloat
     *
     * @param {number|string} pObj A value to evaluate
     *
     * @param {boolean} pStrict  If true, the specified value must be a number; strings will not be parsed
     *
     * @param {boolean} pZeroIsFloat indicates whether to consider zero a float or an integer, Defaults to true
     *
     * @returns {boolean} true if the specified value cannot be expressed as an integer (or zero)
     *
     * @alias module:TypeUtils.isFloat
     */
    const isFloat = function( pObj, pStrict = true, pZeroIsFloat = true )
    {
        if ( 0 === pObj )
        {
            return !!pZeroIsFloat;
        }

        let is = isNumber( pObj ) && !isNaN( parseFloat( pObj ) ) && ((parseFloat( pObj ) !== parseInt( pObj )) || parseFloat( pObj ) % 1 !== 0);

        if ( !is && !pStrict && isString( pObj ) && isNumeric( pObj ) )
        {
            let n = parseFloat( pObj );

            if ( isFloat( n, true ) )
            {
                let s = _mt_str + String( n );

                return s === pObj;
            }
        }

        return is;
    };

    /**
     * Returns true if the specified object is either null, undefined, or a number that is not valid or not finite.
     * If the second argument is true, will also return true for empty or whitespace-only strings
     * @param {*} pObject the value to evaluate
     * @param {boolean} pTreatStringsAsObjects a boolean value that indicates whether to return true for empty strings
     * @returns {boolean} true if the value is null, undefined, or NaN (or one of the Infinity values)
     *
     * @function isNullOrNaN
     *
     * @alias module:TypeUtils.isNullOrNaN
     *
     */
    const isNullOrNaN = function( pObject, pTreatStringsAsObjects = false )
    {
        return isNull( pObject, !pTreatStringsAsObjects ) || (isNumber( pObject ) && isNanOrInfinite( pObject ));
    };

    /**
     * Returns true if the specified value represents a hexadecimal number (base 16)<br>
     * The value can either be a hexadecimal literal, such a 0xFF, <br>
     * or a string starting with "0x" and containing only the hexadecimal digits, a minus sign, or a decimal point<br>
     *
     * @function isHex
     *
     * @param {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents a hexadecimal number
     *
     * @alias module:TypeUtils.isHex
     */
    function isHex( pObj )
    {
        if ( !isString( pObj ) || !pObj.includes( "0x" ) )
        {
            return false;
        }

        const s = toNumericString( pObj );

        return (_zero !== s) && /^(-)?(0x)([\dA-Fa-f]+)?(([.,])([\dA-Fa-f]+))?$/i.test( s ) && !/[G-Wg-w\s]|[yzYZ]/.test( s );
    }

    /**
     * Returns true if the specified value represents an octal number (base 8)<br>
     * The value can either be an octal literal, such a 0o07, <br>
     * or a string starting with "0o" and containing only the octal digits, a minus sign, or a decimal point<br>
     *
     * @function isOctal
     *
     * @param {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents an octal number
     *
     * @alias module:TypeUtils.isOctal
     */
    function isOctal( pObj )
    {
        if ( !isString( pObj ) || !pObj.includes( "0o" ) || pObj.includes( "8" ) )
        {
            return false;
        }

        const s = toNumericString( pObj );

        return (_zero !== s) && /^(-)?(0o)([0-7]+)?(([.,])([0-7]+))?$/i.test( s ) && !/[A-Za-np-z\s]/.test( s );
    }

    /**
     * Returns true if the specified value represents an octal number (base 8)<br>
     * The value can either be an octal literal, such a 0o07, <br>
     * or a string starting with "0o" and containing only the octal digits, a minus sign, or a decimal point<br>
     *
     * @function isBinary
     *
     * @param {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents an octal number
     *
     * @alias module:TypeUtils.isBinary
     */
    function isBinary( pObj )
    {
        if ( !isString( pObj ) || !pObj.includes( "0b" ) || pObj.includes( "2" ) )
        {
            return false;
        }

        const s = toNumericString( pObj );

        return (_zero !== s) && /^(-)?(0b)([0-1]+)?(([.,])([0-1]+))?$/i.test( s ) && !/[AC-Z]|[ac-z]|\s/.test( s );
    }

    /**
     * Returns true if the specified value represents a number expressed in scientific notation (i.e., 4e-12)<br>
     *
     * @function isScientificNotation
     *
     * @param {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents a number expressed in scientific notation
     *
     * @alias module:TypeUtils.isScientificNotation
     */
    const isScientificNotation = ( pObj ) => (/^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)$/).test( toNumericString( pObj ) );

    /**
     * Returns true if the specified value represents a decimal number (base 10)<br>
     *
     * @function isDecimal
     *
     * @param  {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents a decimal number
     *
     * @alias module:TypeUtils.isDecimal
     */
    function isDecimal( pObj )
    {
        const s = _toString( pObj ).replaceAll( /_/g, _mt_str ).trim();
        return (_zero === s || "-0" === s || ( !(isHex( s ) || isOctal( s ) || isBinary( s )) && !/[^\dEe.+-]/.test( s )));
    }

    /**
     * Returns the base for the numeric value specified (i.e., 16 for hexadecimal values, 8 for octal values, or 10 for decimal values)<br>
     * <br>
     * This is used to determine the proper second argument to pass to {@link parseInt}
     *
     * @param pObj {string|number}
     *
     * @returns {number} the base for the numeric value specified (16, 8, or 10)
     */
    const calculateRadix = ( pObj ) => isDecimal( pObj ) ? 10 : isHex( pObj ) ? 16 : isOctal( pObj ) ? 8 : isBinary( pObj ) ? 2 : 0;

    /**
     * Returns true if the specified value is, or can be converted to, a number<br>
     * <br>
     * @param  {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is, or can be converted to, a number
     *
     * @alias module:TypeUtils.isNumeric
     */
    const isNumeric = function( pObj )
    {
        if ( (isNumber( pObj ) && !isNanOrInfinite( pObj )) || _zero === pObj )
        {
            return true;
        }

        if ( ([_num, _big, _str].includes( typeof pObj ) || (pObj instanceof Number || pObj instanceof String)) )
        {
            let value = (_mt_str + _toString( pObj )).trim();
            value = value.replace( /^\(/, _mt_str ).replace( /\)$/, _mt_str ).trim();
            value = value.replace( /n+$/, _mt_str ).trim();

            const is_decimal = isDecimal( value );

            if ( _zero === value || is_decimal || isHex( value ) || isOctal( value ) || isBinary( value ) || (/[eE]/i.test( value ) && isScientificNotation( value )) )
            {
                if ( is_decimal )
                {
                    value = (!((/[boxe]/i).test( value )) ? (value.includes( _dot ) ? value.replace( /^0{2,}/, _zero ) : value.replace( /^0+/, _mt_str )) : value).trim();
                }

                if ( _mt_str === value )
                {
                    return false;
                }

                let integer = attempt( () => parseInt( value, calculateRadix( pObj ) ) );

                return isNumber( integer ) && !isNanOrInfinite( integer );
            }
        }

        return false;
    };

    /**
     * Returns true if the specified value === 0 <br>
     * <br>
     * This can be useful if you might normally test for truthiness and you want 0 to be considered true.<br>
     * <br>
     *
     * @param  {string|number} pValue A value to evaluate
     * @param {boolean} [pStrict=true] specify false to accept numeric values (i.e., strings that represent numbers)
     *
     * @returns {boolean} true if the specified value === 0
     *
     * @alias module:TypeUtils.isZero
     */
    const isZero = function( pValue, pStrict = true )
    {
        const valid = pStrict ? isNumber( pValue ) : isNumeric( pValue );

        if ( 0 === pValue || ( !pStrict && "0" === String( pValue ).trim()) )
        {
            return true;
        }

        const value = String( pValue ).trim().replaceAll( /_/g, _mt_str ).replace( /n$/, _mt_str ).trim();

        const float = attempt( () => parseFloat( value ) );

        return valid && (/^-?0+$|^0+$|^[0.-]{1,3}0+$/.test( value ) || ( !isNanOrInfinite( float ) && Math.round( float ) === 0 && Math.abs( float ) < 0.000000000000001));
    };

    /**
     * Returns a mapping of digit characters to their respective numerical values based on the specified base.<br>
     * <br>
     * @param {number|string} pBase - The numerical base or its string representation (e.g., 2, 8, 10, 16 or "binary", "octal", "decimal", "hex").<br>
     *                                If the value is null, not a number, or an unrecognized string, a default base of 10 is assumed.<br>
     * @return {Map<string, number>} A map where each key is a digit character and its corresponding value is the numerical value of that digit<br>
     *                               <br>
     *                               Predefined maps are returned for bases 2 (binary), 8 (octal), 10 (decimal), and 16 (hexadecimal).<br>
     *                               For other bases, a custom map is dynamically created using the range of available characters.
     *
     * @private
     */
    function getDigitsMap( pBase )
    {
        let base = !isNull( pBase ) && isNumeric( pBase ) ? parseInt( pBase ) : 10;

        base = (isNanOrInfinite( base ) ? (isString( pBase ) ? ({
                                                                    "hex": 16,
                                                                    "octal": 8,
                                                                    "binary": 2,
                                                                    "decimal": 10
                                                                }[(pBase.trim().toLowerCase())] || 10) : 10) : base);

        switch ( base )
        {
            case 0:
            case 10:
                return DIGITS_MAP;

            case 2:
                return BIN_DIGITS_MAP;

            case 8:
                return OCT_DIGITS_MAP;

            case 16:
                return HEX_DIGITS_MAP;

            default:
                const digits = DIGITS.slice( 0, pBase );
                return new Map( digits.map( ( e, i ) => [e, i] ) );
        }
    }

    /**
     * Returns a number or an array of numbers constrained to be within the specified minimum and maximum bounds.<br>
     * <br>
     * This is basically shorthand for Math.max( Math.min( n, max ), min )<br>
     * <br>
     * <br>
     * This function operates recursively if the input is an array, clamping each numerical value
     * within the provided bounds.<br>
     * <br>
     * For non-numeric inputs, the value is returned unchanged.<br>
     * <br>
     * @param {number|Array} pNum - The number or array of numbers to be clamped.
     *                              Nested arrays of any depth are supported.
     *
     * @param {number} pMin - The minimum value to which numbers should be clamped.
     *
     * @param {number} pMax - The maximum value to which numbers should be clamped.
     *
     * @returns {number|Array} - The clamped number or an array of clamped numbers.<br>
     *                           Non-numeric input is returned as is.
     *
     * @alias module:TypeUtils.clamp
     */
    const clamp = ( pNum, pMin, pMax ) => isArray( pNum ) ? [...pNum].map( e => clamp( e, pMin, pMax ) ) : isNumeric( pNum ) ? Math.min( Math.max( toDecimal( pNum ), pMin ), pMax ) : pNum;

    /**
     * Converts a string representation of a number (potentially including a fractional part)
     * into its decimal numerical equivalent.
     * This function accommodates various radix notations and handles optional custom decimal separators.
     *
     * @param {Object|string|number} pObj - The input value to convert to a decimal, which can be a string, number, or other object types.
     * @param {string} [pDecimalSeparator=_dot] - The character in the string that represents the decimal separator.
     * @param {string} [pGroupSeparator=_comma] - The character in the string that represents the grouping separator.
     * @returns {number} - The decimal numerical value obtained from the string representation.
     *
     * @private
     */
    const _stringToDecimal = function( pObj, pDecimalSeparator = _dot, pGroupSeparator = _comma )
    {
        let s = toNumericString( pObj, pDecimalSeparator, pGroupSeparator );

        let sign = (s.startsWith( _minus ) || (s.startsWith( "(" ) && s.endsWith( ")" ))) ? -1 : 1;

        s = s.replaceAll( /_/g, _mt_str ).replace( /\(/, _mt_str ).trim().replace( /\)$/, _mt_str ).trim();

        s = s.replace( /n$/, _mt_str ).trim();

        let power = calculateRadix( s );

        s = s.replace( _minus, _mt_str );

        s = s.replace( /^0([box])/i, _mt_str );

        const sep = pDecimalSeparator || _dot;

        let parts = s.split( sep );

        let integer = (parts[0] || _zero);
        let fraction = (parts[1] || _zero);

        if ( /^0+$/.test( fraction ) )
        {
            return parseInt( s, power ) * sign;
        }

        let value = 0;

        let digitsMap = getDigitsMap( power );

        let intDigits = [].concat( ...(integer.split( _mt_str ).reverse()) );

        for( let i = 0, n = intDigits.length; i < n; i++ )
        {
            const digit = intDigits[i];
            const multiple = power ** i;

            const base = digitsMap.get( digit ) || parseInt( digit );
            value += isZero( base ) ? 0 : base * multiple;
        }

        let fractionDigits = fraction.split( _mt_str );

        for( let i = 0, n = fractionDigits.length; i < n; i++ )
        {
            const digit = fractionDigits[i];
            const multiple = power ** -(i + 1);
            const base = digitsMap.get( digit ) || parseInt( digit );
            value += isZero( base ) ? 0 : base * multiple;
        }

        return value * sign;
    };

    /**
     * Returns the decimal representation of the specified value<br>
     * <br>
     * If the specified value is not numeric, returns 0<br>
     * <br>
     * If the specified value is an array, a new array is returned with each element in the array mapped to a decimal representation<br>
     *
     * @param {number|string|Array<(number|string)>} pObj A value or an array of values to convert to a decimal representation<br>
     *
     * @returns {number|Array<number>} a decimal representation of the specified value
     *
     * @alias module:TypeUtils.toDecimal
     */
    const toDecimal = function( pObj )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toDecimal );
        }

        if ( !isNumeric( pObj ) || isBigInt( pObj ) )
        {
            return 0;
        }

        if ( isBigInt( pObj ) )
        {
            return pObj >= Number.MIN_SAFE_INTEGER && pObj <= Number.MAX_SAFE_INTEGER ? parseInt( pObj.toString().replace( /n$/, _mt ) ) : pObj;
        }

        let s = (_mt_str + (String( pObj ).trim())).toLowerCase();

        if ( s.includes( "e" ) && isScientificNotation( pObj ) )
        {
            const rx = /[eE]/i;

            if ( rx.test( s ) )
            {
                const parts = s.split( rx );

                let coefficient = parseFloat( parts[0] );

                let exponent = parseInt( (parts.length > 1 ? parts[1] : 0), 10 );

                coefficient = isBigInt( coefficient ) || isBigInt( exponent ) ? BigInt( coefficient ) : coefficient;
                exponent = isBigInt( coefficient ) || isBigInt( exponent ) ? BigInt( exponent ) : exponent;

                return parseFloat( (coefficient * 10 ** exponent).toFixed( clamp( Math.abs( exponent ), 0, 100 ) ) );
            }
        }

        if ( /^[\d_]+n$/.test( s ) && s.endsWith( "n" ) && isBigInt( BigInt( s ) ) )
        {
            let b = BigInt( s );
            return b >= Number.MIN_SAFE_INTEGER && b <= Number.MAX_SAFE_INTEGER ? parseInt( s.replace( /n$/, _mt ) ) : b;
        }

        if ( isDecimal( pObj ) )
        {
            return attempt( () => parseFloat( pObj ) ) || 0;
        }

        if ( isNumber( pObj ) )
        {
            let num = Number( pObj );
            return parseFloat( num.toString( 10 ) );
        }

        return _stringToDecimal( pObj );
    };

    function prepareValue( pValue, pRadix )
    {
        let decimalValue = toDecimal( pValue );
        return decimalValue.toString( pRadix || calculateRadix( decimalValue ) );
    }

    function _numStr( pStr, pPrefix )
    {
        return ((pStr.startsWith( "-" ) ? "-0" : "0") + (String( pPrefix ).toLowerCase()) + pStr.replace( /^-/, _mt_str ).trim()).trim();
    }

    /**
     * Returns a string representation of the specified value as a hexadecimal number<br>
     * <br>
     * If the specified value is an array, a new array is returned with each element in the array mapped to a hexadecimal representation<br>
     *
     * @param {number|string|Array<(number|string)>} pObj A value or an array of values to convert to a base 16 (hexadecimal) representation
     *
     * @returns {string|Array<string>} A string representation of the specified value as a hexadecimal (base 16) number
     *
     * @alias module:TypeUtils.toHex
     */
    const toHex = function( pObj )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toHex );
        }

        const s = prepareValue( pObj, 16 );

        return _numStr( s, "x" );
    };

    /**
     * Returns a string representation of the specified value as an octal number<br>
     * <br>
     * If the specified value is an array, a new array is returned with each element in the array mapped to an octal representation
     * <br>
     *
     * @param {number|string|Array<(number|string)>} pObj A value to convert to base 8 (octal)
     *
     * @returns {string|Array<string>} A string representation of the specified value as an octal (base 8) number
     *
     * @alias module:TypeUtils.toOctal
     */
    const toOctal = function( pObj )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toOctal );
        }

        const s = prepareValue( pObj, 8 );

        return _numStr( s, "o" );
    };

    /**
     * Returns a string representation of the specified value as a binary number
     * <br>
     * If the specified value is an array,
     * a new array is returned with each element in the array mapped
     * to a binary representation
     * <br>
     *
     * @param {number|string|Array<(number|string)>} pValue A value or an array of values to convert to base 2 (binary)
     *
     * @param {number} [pPrecision=0] The number of decimal places to include
     *                                if the value is not a whole number (integer)
     *
     * @returns {string|Array<string>} A string representation of the specified value as a binary (base 2) number
     *
     * @alias module:TypeUtils.toBinary
     */
    const toBinary = function( pValue, pPrecision = 0 )
    {
        if ( isArray( pValue ) )
        {
            return [...pValue].map( ( e ) => toBinary( e, pPrecision ) );
        }

        let s = prepareValue( pValue, 2 );

        if ( s.includes( _dot ) )
        {
            let maxPrecision = clamp( attempt( () => parseInt( toNumericString( String( pPrecision ), 10 ) ) ), 0, 15 );

            if ( (isNanOrInfinite( maxPrecision ) || maxPrecision <= 0) && isNull( pPrecision ) )
            {
                const msg = `Non-Integer value passed to ${modName}::toBinary to specify precision; value will be truncated`;

                toolBocksModule.reportError( new IllegalArgumentError( msg, { value: pValue } ), msg, S_WARN, modName + "::toBinary", { value: pValue } );

                s = s.replace( /\.\d+$/, _mt_str );
            }
        }

        return _numStr( s, "b" );
    };

    const toUUID = function( pBigInt )
    {
        if ( isUUID( pBigInt ) )
        {
            return pBigInt;
        }

        if ( isNonNullObject( pBigInt ) )
        {
            let obj = asObject( pBigInt );

            let values = objectValues( obj );

            let uuid = obj["uuid"] || obj["guid"] || values.find( e => isUUID( e ) );

            if ( isUUID( uuid ) )
            {
                return uuid;
            }

            uuid = values.find( e => isBigInt( e ) );
            if ( uuid && isBigInt( uuid ) )
            {
                return toUUID( uuid );
            }

            for( let val of values )
            {
                if ( isNonNullObject( val ) )
                {
                    uuid = objectValues( val ).find( e => isUUID( e ) );

                    if ( isUUID( uuid ) )
                    {
                        return uuid;
                    }
                }
            }

            return _mt;
        }

        const formatUUID = function( pHex )
        {
            let hex = _toString( pHex ).replace( /^0x/, _mt );
            hex = hex.padStart( 32, "0" );

            return [
                hex.substring( 0, 8 ),
                hex.substring( 8, 12 ),
                hex.substring( 12, 16 ),
                hex.substring( 16, 20 ),
                hex.substring( 20, 32 )
            ].join( "-" );
        };

        if ( isBigInt( pBigInt ) )
        {
            let hex = BigInt( pBigInt ).toString( 16 ).replace( /^0x/, _mt );
            return formatUUID( hex.padStart( 32, "0" ) );
        }

        if ( isInteger( pBigInt ) )
        {
            let hex = _toString( toHex( pBigInt ) ).replace( /^0x/, _mt );

            const length = $ln( _toString( hex ).replace( /^0x/, _mt ) );

            if ( length < 32 )
            {
                for( let i = 0, n = (32 - length); (i < n && $ln( hex ) < 32); i++ )
                {
                    hex = (Math.floor( Math.random() * 16 ).toString( 16 ) + hex);
                }
            }
            else if ( length > 32 )
            {
                hex = hex.slice( -32 );
            }

            return formatUUID( hex );
        }

        if ( isString( pBigInt ) )
        {
            if ( isUUID( pBigInt ) )
            {
                return pBigInt;
            }

            if ( isHex( pBigInt ) )
            {
                return toUUID( BigInt( "0x" + _toString( pBigInt ) ) );
            }

            if ( isOctal( pBigInt ) )
            {
                return toUUID( BigInt( "0o" + _toString( pBigInt ) ) );
            }

            if ( isBinary( (pBigInt) ) )
            {
                return toUUID( BigInt( "0b" + _toString( pBigInt ) ) );
            }

            if ( isNumeric( pBigInt ) )
            {
                return toUUID( BigInt( toHex( pBigInt ) ) );
            }
        }

        return _mt;
    };

    /**
     * Converts a given value to an integer.
     *
     * This function takes an input value, converts it to a decimal representation,
     * and then converts the result into an integer using `parseInt`.
     *
     * @param {*} pValue - The value to be converted to an integer. It is expected
     *                     that the input can be handled by the `toDecimal` helper function.
     *
     * @returns {number} The integer representation of the input value.
     *
     * @alias module:TypeUtils.toInteger
     */
    const toInteger = ( pValue ) => attempt( () => parseInt( toDecimal( pValue ) ) ) || (isBigInt( pValue ) ? pValue : 0);

    /**
     * Converts the provided value to a floating-point number.
     *
     * This function coverts the input into a decimal representation,
     * using the `toDecimal` function,
     * and then converts it to a floating-point number
     * using `parseFloat`.
     *
     * @param {*} pValue - The value to be converted to a floating-point number.
     * @returns {number} The float representation of the input value.
     *
     * @alias module:TypeUtils.toFloat
     */
    const toFloat = ( pValue ) => attempt( () => parseFloat( toDecimal( pValue ) ) );

    /**
     * Returns true if the specified value is a boolean or Boolean object<br>
     *
     * @param {*} pValue A value to evaluate
     *
     * @returns {boolean} true if the specified value is a boolean or Boolean object
     *
     * @alias module:TypeUtils.isBoolean
     */
    const isBoolean = ( pValue ) => ((_bool === typeof pValue) && ((false === pValue) || true === pValue)) || pValue instanceof Boolean;

    /**
     * Returns true if the specified value,<br>
     * which might otherwise evaluate to 'falsey',<br>
     * is actually a non-null value, such as 0, false, or an empty string<br>
     *
     * @param {*} pValue A value to evaluate
     * @returns {boolean} true if the specified value is actually a non-null value,
     * even when it might otherwise evaluate to 'falsey', (such as 0, false, or an empty string)
     *
     * @alias module:TypeUtils.isNonNullValue
     */
    const isNonNullValue = ( pValue ) => (false === pValue || 0 === pValue || _mt_str === pValue || isNonNullObject( pValue ) || isNotNull( pValue, false ));

    const is2dArray = ( pArray ) => isArray( pArray ) && $ln( pArray ) > 0 && pArray.every( elem => isArray( elem ) );

    const isKeyValueArray = ( pArray ) => is2dArray( pArray ) && pArray.every( elem => $ln( elem ) >= 2 && $ln( elem ) <= 3 && isString( elem[0] ) );

    /**
     * Returns true if the specified value is iterable.<br>
     * That is, the value can be used in a "for...of" loop<br>
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is iterable
     *
     * @alias module:TypeUtils.isIterable
     */
    const isIterable = ( pObj ) => !isNull( pObj ) && (isFunction( pObj[Symbol.iterator] ) || isArray( pObj ) || isTypedArray( pObj ));

    /**
     * Returns true if the specified value is spreadable.<br>
     * That is, the value can be expanded by use of the ... operator<br>
     *
     * @param {*} pObj A value to evaluate
     * @param {boolean} [pMustBeIterable=true] Specify true to require that the value also be iterable.<br>
     *                                         This can distinguish between objects that can be copied via {...object}<br>
     *                                          versus truly spreadable values<br>
     *
     * @returns {boolean} true if the specified value is spreadable
     *
     * @alias module:TypeUtils.isSpreadable
     */
    const isSpreadable = function( pObj, pMustBeIterable = true )
    {
        let is = !isNull( pObj ) && (isArray( pObj ) || isString( pObj ) || isNonNullObject( pObj ) || isDefined( pObj[Symbol.iterator] ));
        return is && (pMustBeIterable ? isIterable( pObj ) : is);
    };

    /**
     * Returns true if the specified value is asynchronously iterable.<br>
     * That is, the value can be used in a "for await ... of" loop<br>
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is asynchronously iterable
     *
     * @alias module:TypeUtils.isAsyncIterable
     */
    const isAsyncIterable = ( pObj ) => !isNull( pObj ) && isFunction( pObj[Symbol.asyncIterator] );

    const isCloneable = ( pObject ) => isNonNullObject( pObject ) && isFunction( pObject.clone );

    /**
     * Returns true if the specified value is array-like<br>
     *
     * @see (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects)
     *
     * @param {*} pArg A value to evaluate
     * @param {boolean} [pMustBeIterable=false] Specify true if the value must also define [Symbol.iterator]
     *
     * @returns {boolean} true if the specified value is array-like<br>
     *                    (that is, has a length property and one or more numeric keys)
     *
     * @alias module:TypeUtils.isLikeArray
     */
    const isLikeArray = function( pArg, pMustBeIterable = false )
    {
        if ( isArray( pArg ) || isString( pArg ) || isTypedArray( pArg ) )
        {
            return true;
        }

        if ( !isNull( pArg ) && isNumeric( pArg?.length ) )
        {
            const keys = Object.keys( pArg || {} ).filter( e => "length" !== e );

            if ( keys.every( key => isNumeric( key ) ) )
            {
                return !pMustBeIterable || isIterable( pArg );
            }
        }

        return false;
    };

    /**
     * Returns true of the specified value is a Symbol<br>
     *
     * @param {*} pValue A value to evaluate
     *
     * @returns {boolean} true of the specified value is a Symbol
     *
     * @alias module:TypeUtils.isSymbol
     */
    const isSymbol = ( pValue ) => _symbol === typeof pValue || pValue instanceof Symbol;


    /**
     * The VisitedSet class extends the native JavaScript Set class,
     * providing additional functionality to handle equality comparison for objects.
     *
     * Instances of this class are useful in recursive algorithms
     * to avoid visiting the same node more than once.
     *
     * @class
     * @alias module:TypeUtils#VisitedSet
     */
    class VisitedSet extends Set
    {
        /**
         * A function used to determine the equality of two objects.
         *
         * This function should accept two parameters representing the objects to be compared
         * and return a boolean value indicating whether the objects are considered equal.
         *
         * Typically, the equality function is used in contexts such as data comparison,
         * filtering, deduplication, or other scenarios that require logic to compare two values.
         *
         * @type {function({object},{object}):boolean}
         *
         * @param {any} element1 - The object to compare to the other.
         *
         * @param {any} element2 - The other object to compare to the first.
         *
         * @returns {boolean} true if the two objects are considered equal, otherwise false.
         */
        #equalityFunction = (( a, b ) => a === b);

        constructor( pEqualityFunction = ( a, b ) => a === b, ...pValues )
        {
            super( pValues );

            this.#equalityFunction = (pEqualityFunction && (_fun === typeof pEqualityFunction) ? pEqualityFunction : (( a, b ) => a === b));
        }

        static get [Symbol.species]()
        {
            return this;
        }

        has( pValue )
        {
            if ( _ud === typeof pValue || null === pValue )
            {
                return false;
            }

            if ( super.has( pValue ) )
            {
                return true;
            }

            for( let v of this.values() )
            {
                if ( (_obj === typeof v) && (v === pValue || this.#equalityFunction( v, pValue )) )
                {
                    return true;
                }
            }

            return false;
        }
    }

    /**
     * ResolvedSet is a class extending VisitedSet, providing additional functionality
     * for storing and resolving values associated with specific objects or paths.
     */
    class ResolvedSet extends VisitedSet
    {
        #map = new Map();
        #mapByNodePath = new Map();

        constructor( pEqualityFunction = ( a, b ) => a === b, ...pValues )
        {
            super( pEqualityFunction, ...pValues );
        }

        static get [Symbol.species]()
        {
            return this;
        }

        resolveForNodePath( pValue, ...pNodePath )
        {
            let paths = toNodePathArray( ...pNodePath );

            if ( isNull( paths ) || $ln( paths ) <= 0 )
            {
                return this.resolve( pValue );
            }

            paths = paths.join( _dot );

            let value = this.#mapByNodePath.get( paths );

            value = isNonNullValue( value ) ? value : pValue;

            if ( isNonNullValue( value ) )
            {
                this.#mapByNodePath.set( paths, value );
            }

            return value;
        }

        resolve( pObject, pValue )
        {
            if ( isNonNullObject( pObject ) )
            {
                if ( isNonNullValue( pValue ) )
                {
                    this.add( pObject );
                    this.#map.set( pObject, pValue );
                    return pValue;
                }
                else
                {
                    return this.has( pObject ) ? this.#map.get( pObject ) : null;
                }
            }

            return isNonNullValue( pValue ) ? pValue : null;
        }
    }

    /**
     * @typedef {object} IsPopulatedOptions
     *
     * @property {Array.<string>} [acceptedTypes=['object']] an array of the types of values to be considered.  Defaults to "object"
     * @property {number} [minimumLength=1] a whole number indicating the fewest properties an object
     *                                      must have to be considered populated.<br>
     *                                      If strings are being considered, this value specifies the fewest characters a string must have.
     *
     * @property {boolean} [acceptArrays=true] a boolean to indicate whether to treat arrays as objects for the purpose of evaluating as populated
     * @property {Array.<string>} [mandatoryKeys=[]] an array of strings specifying the properties an object must have to be considered populated
     * @property {boolean} [countDeadBranches=true] a boolean to indicate whether a property that is an object graph ending in an empty leaf counts toward the minimum length
     *
     *
     */

    /**
     *
     * @type {IsPopulatedOptions}
     */
    const DEFAULT_IS_POPULATED_OPTIONS =
        {
            acceptedTypes: [_obj],
            minimumLength: 1,
            acceptArrays: false,
            mandatoryKeys: [],
            countDeadBranches: true
        };

    const IS_POPULATED_ARRAY_OPTIONS =
        {
            acceptedTypes: [_obj],
            minimumLength: 1,
            acceptArrays: true,
            mandatoryKeys: [],
            countDeadBranches: true
        };

    const STRICT_POPULATED_OPTIONS =
        {
            acceptedTypes: [_obj],
            minimumLength: 1,
            acceptArrays: false,
            mandatoryKeys: [],
            countDeadBranches: false
        };

    const LAX_POPULATED_OPTIONS =
        {
            acceptedTypes: [_obj, _fun],
            minimumLength: 1,
            acceptArrays: true,
            mandatoryKeys: [],
            countDeadBranches: true
        };

    function resolveAcceptedTypes( pOptions )
    {
        const options = { ...DEFAULT_IS_POPULATED_OPTIONS, ...(pOptions || {}) };
        let acceptedTypes = [_obj, ...(options.acceptedTypes || [])].flat();
        acceptedTypes = acceptedTypes.map( e => isString( e ) ? e.trim().toLowerCase() : e );
        return acceptedTypes.filter( e => VALID_TYPES.includes( e ) );
    }

    function resolveMandatoryKeys( pOptions )
    {
        const options = { ...DEFAULT_IS_POPULATED_OPTIONS, ...(pOptions || {}) };
        let mandatoryKeys = [...(options.mandatoryKeys || [])];
        mandatoryKeys = mandatoryKeys.map( e => isString( e ) ? e.trim().toLowerCase() : e );
        return mandatoryKeys.filter( e => isString( e ) && e.length > 0 );
    }

    function resolveIsPopulatedArgs( pOptions = DEFAULT_IS_POPULATED_OPTIONS )
    {
        const options = { ...DEFAULT_IS_POPULATED_OPTIONS, ...(pOptions || {}) };

        const acceptedTypes = resolveAcceptedTypes( options );

        const mandatoryKeys = resolveMandatoryKeys( options );

        const minimumLength = Math.max( 1, ($ln( mandatoryKeys ) || 0), toInteger( options.minimumKeys || options.minimumLength || 1 ) );

        const countDeadBranches = !!options.countDeadBranches;

        return { options, minimumLength, acceptedTypes, mandatoryKeys, countDeadBranches };
    }

    function isPopulatedArray( pObject, pCountEmptyElements, pOptions, pVisited, pStack )
    {
        if ( !isArray( pObject ) )
        {
            return false;
        }

        let arr = [...(pObject || [])].filter( e => isNonNullValue( e ) && ( !isNumeric( e ) || !isNanOrInfinite( toFloat( e ) )) );

        if ( !pCountEmptyElements )
        {
            arr = arr.filter( ( e, i ) => isPopulated( e, pOptions, pVisited, [...(pStack || []), String( i )] ) );
        }

        let minLength = toInteger( pOptions?.minimumLength ) || 1;
        minLength = Math.max( 1, isNanOrInfinite( minLength ) ? 1 : minLength );

        return (arr.length >= minLength);
    }

    function isPopulatedObject( pObject, pOptions = DEFAULT_IS_POPULATED_OPTIONS, pVisited = new ResolvedSet(), pStack = [] )
    {
        const
            {
                options,
                minimumLength,
                acceptedTypes,
                mandatoryKeys,
                countDeadBranches
            } = resolveIsPopulatedArgs( pOptions );

        const mandatory = [...(mandatoryKeys || [])];
        const minLength = Math.max( 1, $ln( mandatory ), toInteger( minimumLength ) );
        const acceptArrays = !!options.acceptArrays;

        let populated = false;

        let nonNull = (isNonNullObject( pObject,
                                        false,
                                        {
                                            rejectNull: true,
                                            allowEmptyObjects: minLength < 1,
                                            rejectPrimitiveWrappers: false,
                                            rejectArrays: !acceptArrays
                                        } ));

        if ( nonNull )
        {
            if ( isArray( pObject ) && acceptArrays )
            {
                populated = isPopulatedArray( pObject, countDeadBranches, options, pVisited, pStack, minLength );
            }
            else if ( isPrimitiveWrapper( pObject ) )
            {
                populated = isPopulated( toPrimitive( pObject ), options, pVisited, [...(pStack || [])] );
            }
            else
            {
                if ( countDeadBranches )
                {
                    const keys = objectKeys( pObject || {} );
                    populated = (keys.length >= minLength);

                    if ( populated )
                    {
                        populated = mandatory.length <= 0 || mandatory.every( key => isDefined( pObject[key] ) );
                    }
                }
                else
                {
                    const entries = objectEntries( pObject || {} );

                    for( const entry of entries )
                    {
                        const value = entry.value;

                        const opts = { ...options };

                        opts.minimumLength = isString( value ) ? value?.length : options.minimumLength;
                        opts.acceptedTypes = isNonNullValue( value ) ? [...acceptedTypes, (typeof value)] : acceptedTypes;

                        if ( isPopulated( value, opts, pVisited, [...(pStack || []), entry.key] ) )
                        {
                            populated = true;
                            break;
                        }
                    }
                }
            }
        }

        return populated;
    }

    function isPopulatedType( pType, pObject, pOptions = DEFAULT_IS_POPULATED_OPTIONS, pVisited = new ResolvedSet(), pStack = [] )
    {
        const {
            options,
            minimumLength,
            acceptedTypes,
            mandatoryKeys,
            countDeadBranches
        } = resolveIsPopulatedArgs( pOptions );

        let populated;

        let minKeys = Math.max( 0, mandatoryKeys.length );
        let minLength = Math.max( minKeys, parseInt( minimumLength || "1" ) );
        let acceptArrays = acceptedTypes.includes( _obj ) && !!options.acceptArrays;

        switch ( pType )
        {
            case _ud:
                populated = false;
                break;

            case _str:
                populated = (isString( pObject ) && pObject.length >= minLength);
                break;

            case _bool:
                populated = (isBoolean( pObject ));
                break;

            case _num:
            case _big:
                populated = (isNumeric( pObject ) && !isNanOrInfinite( toFloat( pObject ) ));
                break;

            case _obj:

                const visited = pVisited || new ResolvedSet();
                const stack = pStack || [];

                populated = (acceptArrays || !isArray( pObject )) && isPopulatedObject( pObject, options, visited, stack );

                break;

            case _symbol:
                populated = !isNull( pObject ) && (isSymbol( pObject ));
                break;

            default:
                populated = false;
                break;
        }

        return populated;
    }

    /**
     * Returns true if the specified value is
     *
     * an object with at least <i>n</i> non-empty properties
     * (where n is the value specified in the options minimumLength argument or 1)
     * and (optionally) having the specified key(s) specified in the options mandatoryKeys property
     *
     * or
     *
     *  DEPENDING ON VALUES PASSED IN THE OPTIONS ARGUMENT:
     *
     *  an array with at least <i>n</i> non-null, non-empty elements
     *  (where n is the value specified in the options minimumLength argument or 1) or
     *
     *
     *  a valid number or
     *  a boolean or
     *  a function or
     *  a non-empty string
     *
     * @param {*} pObject a value to evaluate
     *
     * @param pOptions an object defining optional characteristics the value must satisfy
     *                 acceptedTypes: an array of types to accept (defaults to ["object"])
     *                 minimumKeys: an integer defining how many properties an object must have
     *                              (or elements a pruned array must have)
     *                              defaults to 1
     *                 acceptArrays: whether to return true if the evaluated value is an array
     *                               defaults to false
     * @param pVisited
     * @param pStack
     * @returns {*|boolean}
     */
    const isPopulated = function( pObject, pOptions = DEFAULT_IS_POPULATED_OPTIONS, pVisited = new ResolvedSet(), pStack = [] )
    {
        let { options, minimumLength, acceptedTypes, mandatoryKeys } = resolveIsPopulatedArgs( pOptions );

        if ( !isNonNullValue( pObject ) || !(acceptedTypes.includes( typeof pObject )) )
        {
            return false;
        }

        let populated = false;

        for( const acceptedType of acceptedTypes )
        {
            if ( acceptedType === typeof pObject )
            {
                const visited = pVisited || new ResolvedSet();
                const stack = pStack || [];

                if ( detectCycles( stack, 5, 5 ) )
                {
                    return populated || visited.resolve( pObject );
                }

                populated = !!(visited.resolve( pObject )) || isPopulatedType( acceptedType, pObject, options, visited, stack );

                visited.resolve( pObject, !!populated );

                break;
            }

            if ( populated )
            {
                break;
            }
        }

        return populated;
    };

    /**
     * Returns true if the specified value is a non-null object with at least one key
     * @param pObject
     * @returns {*|boolean}
     */
    const isValidObject = function( pObject )
    {
        return isNonNullObject( pObject,
                                {
                                    rejectPrimitiveWrappers: false,
                                    rejectArrays: false,
                                    rejectNull: true,
                                    allowEmptyObjects: false
                                } );
    };


    /**
     * Determines whether the provided value is a scalar value.
     *
     * A scalar is a primitive data type such as string, number, bigint, boolean, or,
     * conditionally,
     * null, symbol, function, or 'boxed' primitives
     * based on specific options.
     *
     * @function isScalar
     *
     * @param {any} pVal - The value to inspect and determine if it is scalar.
     *
     * @param {Object} [pOptions] - Additional options to influence the scalar determination.
     *
     * @param {boolean} [pOptions.nullIsScalar=false] - Determines if null should be considered a scalar value. Defaults to false.
     * @param {boolean} [pOptions.symbolIsScalar=false] - Determines if a symbol should be considered a scalar value. Defaults to false.
     * @param {boolean} [pOptions.functionIsScalar=false] - Determines if a function should be considered a scalar value. Defaults to false.
     * @param {boolean} [pOptions.dateIsScalar=false] Determines if a Date should be considered a scalar value. Defaults to false.
     * @param {boolean} [pOptions.boxedPrimitiveIsScalar=true] Determines if a function should be considered a scalar value. Defaults to true.
     *
     * @returns {boolean} Returns true if the given value is considered scalar; otherwise, false.
     */
    const isScalar = function( pVal, pOptions = { boxedPrimitiveIsScalar: true } )
    {
        const options = { ...({ boxedPrimitiveIsScalar: true }), ...(pOptions || {}) };

        if ( (_ud === typeof pVal) || isNull( pVal ) )
        {
            return !!options.nullIsScalar;
        }

        if ( isFunction( pVal ) )
        {
            return !!options.functionIsScalar;
        }

        if ( isObject( pVal ) )
        {
            return isPrimitiveWrapper( pVal ) && options.boxedPrimitiveIsScalar;
        }

        switch ( typeof pVal )
        {
            case _str:
            case _num:
            case _big:
            case _bool:
                return true;

            case _symbol:
                return !!options.symbolIsScalar;

            default:
                break;
        }

        return !isObject( pVal ) && isNonNullValue( pVal );
    };

    const asScalar = function( pVal, pTrimStrings )
    {
        let value = _mt;

        if ( !isNull( pVal ) )
        {
            if ( isScalar( pVal ) )
            {
                value = (isString( pVal ) ? pVal : (isPrimitiveWrapper( pVal ) || isFunction( pVal.valueOf ) ? pVal.valueOf() || pVal : pVal));
            }
            else if ( isFunction( pVal.valueOf ) )
            {
                value = (pVal.valueOf() || (isFunction( pVal.toString ) ? pVal.toString() : String( pVal )));
            }
            else if ( isFunction( pVal.toString ) )
            {
                value = pVal.toString();
            }

            return (isString( value ) ? (!!pTrimStrings ? value.trim() : value) : value);
        }

        return null;
    };

    /**
     * Returns true if the specified value cannot be modified<br>
     *
     * @function isReadOnly
     *
     * @see {@link constants.isReadOnly}
     *
     * @param {*} A value to evaluate
     *
     * @return {boolean} true if the value is immutable
     *
     * @alias module:TypeUtils.isReadOnly
     */
    const isReadOnly = moduleUtils?.isReadOnly || function( pObject )
    {
        return isPrimitive( pObject ) ||
               isNull( pObject ) ||
               isPrimitiveWrapper( pObject ) ||
               (isObject( pObject ) && (Object.isFrozen( pObject ) || Object.isSealed( pObject )));
    };

    /**
     * Returns true if the specified value is of the type specified<br>
     * (or is an instance of the class specified)<br>
     *
     * @param {*} pValue A value to evaluate
     * @param {string|Function} pType The type to which to compare the type of the specified value<br>
     *                                (or a class of which the specified value is an instance)
     *
     * @returns {boolean} true if the specified value is of the type specified
     *                    (or is an instance of the class specified)
     *
     * @alias module:TypeUtils.isType
     */
    const isType = function( pValue, pType )
    {
        const typeName = (isString( pType ) && JS_TYPES.includes( pType )) ?
                         (pType).trim().toLowerCase() :
                         ((isFunction( pType ) || isClass( pType, false )) ? _fun : typeof pType);

        if ( JS_TYPES.includes( typeName ) )
        {
            if ( _fun === typeName )
            {
                return isNonNullObject( pValue ) && isClass( pType, false ) ? pValue instanceof pType : isFunction( pValue );
            }
            return ((typeof pValue) === typeName);
        }

        if ( isNonNullObject( pValue ) && isClass( pType ) )
        {
            return pValue instanceof pType;
        }

        return false;
    };

    /**
     * Returns true if the specified values are of the same type<br>
     *
     * @param  {...any} pValues Two or more values to compare by type
     *
     * @returns {boolean} true if the specified values are of the same type
     *
     * @alias module:TypeUtils.areSameType
     */
    const areSameType = function( ...pValues )
    {
        let areSame = true;

        if ( !isNull( pValues ) )
        {
            const values = isLikeArray( pValues, true ) ? [...pValues] : [pValues || _mt_str];

            let first = values[0];

            let types = [typeof first];

            if ( [_num, _big].includes( typeof first ) )
            {
                types.push( _num, _big );
            }

            for( let i = 1, n = values.length; i < n; i++ )
            {
                let value = values[i];

                if ( !types.includes( typeof value ) )
                {
                    areSame = false;
                    break;
                }
            }
        }

        return areSame;
    };

    /**
     * Returns true if the provided values are of compatible types.<br>
     * <br>
     * The function first checks if all the values are of the same type using the `areSameType` function.<br>
     * <br>
     * If the types are the same, it returns true.<br>
     * If the types are not the same,<br>
     * the function further evaluates whether the values are not null,<br>
     * and whether their types can be reasonably coerced to a compatible type, such as number, bigint, or string.
     *
     * @param {...*} pValues - The values to be evaluated
     *
     * @returns {boolean} true if the values are of the same type or are all strings, numbers, or bigint values
     *
     * @alias module:TypeUtils.areCompatibleTypes
     */
    const areCompatibleTypes = function( ...pValues )
    {
        if ( areSameType( ...pValues ) )
        {
            return true;
        }

        if ( !isNull( pValues ) )
        {
            const values = (isLikeArray( pValues, true ) ? [...pValues] : [pValues || _mt_str]);

            const types = values.map( e => typeof e );

            if ( types.every( e => [_num, _big, _str].includes( typeof e ) ) )
            {
                if ( types.some( e => [_num, _big].includes( e ) ) )
                {
                    return values.every( isNumeric );
                }
                return values.every( isString );
            }
        }

        return false;
    };

    /**
     * Returns true if the specified value is an instance of {@link Map}<br>
     * or, if not <i>strict</i>, returns true if the specified value is an object with only string keys<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider string-keyed objects (a.k.a. 'dictionaries') to be Maps
     *
     * @returns {boolean} true if the specified value is an instance of Map
     *
     * @alias module:TypeUtils.isMap
     */
    const isMap = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) || [_str, _num, _big, _bool, _symbol].includes( typeof pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof Map;
        }

        if ( isNonNullObject( pObject ) )
        {
            if ( pObject instanceof WeakMap )
            {
                return true;
            }

            const entries = objectEntries( pObject );

            const strings = entries.filter( entry => isString( entry.key ) && !(entry.key.startsWith( "[object" )) );

            return (entries.length === strings.length);
        }
        else if ( isFunction( pObject ) && pObject?.length === 1 )
        {
            // perhaps we have a function that takes a key and returns a value...
            return true;
        }

        return false;
    };

    const isWeakMap = ( pObj ) => pObj instanceof WeakMap;

    /**
     * Returns true if the specified value is an instance of {@link Set}<br>
     * or, if not <i>strict</i>, returns true if the specified value is an array-like object with unique values<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider array-like objects that have unique values as if they are Sets
     *
     * @returns {boolean} true if the specified value is an instance of Set
     *
     * @alias module:TypeUtils.isSet
     */
    const isSet = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof Set;
        }

        if ( pObject instanceof WeakSet )
        {
            return true;
        }

        if ( isLikeArray( pObject, true ) || pObject?.length >= 0 )
        {
            const length = pObject.length;
            let set = new Set( [...pObject] );
            return set?.size === length;
        }

        return false;
    };

    const isWeakSet = ( pObj ) => pObj instanceof WeakSet;

    const MIN_DATE_TIME = -30610202964000; // Approx. year -271821
    const MAX_DATE_TIME = 7258140000000;  // Approx. year 2262

    /**
     * Returns true if the specified value is a valid Date instance.<br>
     * <br>
     * This function validates whether the provided `date` parameter is a non-null object,
     * contains a `getTime` method, and has a timestamp that falls within the predefined
     * minimum (`MIN_DATE_TIME`) and maximum (`MAX_DATE_TIME`) date limits.
     *
     * @param {Object} date - The date object to validate.
     * @returns {boolean} Returns true if the date object is considered valid; otherwise, false.
     */
    const isValidDateInstance = ( date ) => !isNull( date ) &&
                                            isFunction( date.getTime ) &&
                                            !isNanOrInfinite( date.getTime() ) &&
                                            date.getTime() >= MIN_DATE_TIME &&
                                            date.getTime() <= MAX_DATE_TIME;

    const isDateString = ( pStr ) => attempt( () => isString( pStr ) && !isBlankString( pStr ) ? isValidDateInstance( new Date( pStr.trim() ) ) : isNumber( pStr ) ? isValidDateInstance( new Date( pStr ) ) : isValidDateInstance( pStr ) );

    const canBeDateTime = function( pObj )
    {
        let date = isObject( pObj ) && pObj instanceof Number
                   ? new Date( pObj.valueOf() )
                   : isNumber( pObj )
                     ? new Date( pObj )
                     : isNumeric( pObj ) ? new Date( toInteger( toDecimal( pObj ) ) ) : null;

        if ( date && isValidDateInstance( date ) )
        {
            return true;
        }
    };

    /**
     * Parses a given input into a date object using a provided parser or parser object.<br>
     * <br>
     * The function supports custom parsing mechanisms by invoking the `parse` or `parseDate`
     * methods of the parser, or the parser itself, if it is a function.<br>
     * <br>
     * If the input cannot be parsed or an error occurs during parsing,
     * the function dispatches an error event and returns null.
     *
     * @param {*} input - The input to be parsed into a date.
     *
     * @param {Function|Object} dateParser - A function or object responsible for parsing the input.
     *                                       If an object, it should have a `parse` or `parseDate` method.
     *
     * @returns {Date|null} The parsed date object, or null if parsing failed or an error occurs.
     *
     * @alias module:TypeUtils.parseDate
     */
    const parseDate = ( input, dateParser ) =>
    {
        // noinspection JSUnresolvedReference
        if ( isFunction( dateParser ) || isFunction( dateParser?.parse || dateParser?.parseDate ) )
        {
            // noinspection JSUnresolvedReference
            return attempt( () => (dateParser.parse || dateParser.parseDate || dateParser).call( dateParser, input ) );
        }

        let date = new Date( input );

        if ( isValidDateInstance( date ) )
        {
            return date;
        }

        return null;
    };

    function _parseDate( pObj, pDateParser )
    {
        let date = null;

        if ( isString( pObj ) || pObj instanceof String )
        {
            date = parseDate( pObj, pDateParser );
            return (isNull( date ) || !isValidDateInstance( date ) ? attempt( () => new Date( pObj ) ) : date);
        }

        return date;
    }

    /**
     * Returns true if the specified object is an instance of Date<br>
     * or if not <i>strict</i>, if the specified object can be converted into a Date<br>
     *
     * @param {*} pObj A value to evaluate
     * @param {boolean} [pStrict=true] Specify false if you want to consider values that can be converted into a Date as Dates<br>
     * @param {Object|function} [pDateParser=null] An optional parameter used to specify a parser to convert strings into Dates
     *
     * @returns {boolean} true if the specified object is an instance of Date
     *
     * @alias module:TypeUtils.isDate
     */
    const isDate = function( pObj, pStrict = true, pDateParser = null )
    {
        if ( isUndefined( pObj ) || isNull( pObj ) )
        {
            return false;
        }

        // Check if input is already a valid Date instance
        if ( TYPES_CHECKS.isDate( pObj ) || pObj instanceof Date || objectToString.call( pObj ) === "[object Date]" )
        {
            return true;
        }

        if ( pStrict )
        {
            return false;
        }

        // Attempt to create a Date if input is a numeric or object containing a number
        if ( canBeDateTime( pObj ) )
        {
            return true;
        }

        // Try parsing if input is a string
        const date = _parseDate( pObj, pDateParser );

        return isDate( date, true ) && isValidDateInstance( date );
    };

    /**
     * Returns true if the specified value is a valid date or a numeric value.<br>
     * <br>
     * This function evaluates if the provided parameter is not null and
     * meets one of the following conditions:
     * - It is a valid date.
     * - It is an integer.
     * - It is a value that can be parsed to a number.
     *
     * @param {*} pDate - The input value to validate.
     * @returns {boolean} Returns true if the input is a valid date, an integer, or a numeric value; otherwise, returns false.
     *
     * @alias module:TypeUtils.isValidDateOrNumeric
     */
    const isValidDateOrNumeric = ( pDate ) => !isNull( pDate ) && (isDate( pDate ) || isInteger( pDate ) || isNumeric( pDate ));

    /**
     * Returns true if the specified value is an instance of RegExp<br>
     * or, if not <i>strict</i>, if the specified value is a string representation of a regular expression<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider a string representation of a regular expression to be a RegExp
     *
     * @returns {boolean} true if the specified value is an instance of RegExp
     *
     * @alias module:TypeUtils.isRegExp
     */
    const isRegExp = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return TYPES_CHECKS.isRegExp( pObject ) || pObject instanceof RegExp;
        }

        const s = _mt_str + (isString( pObject ) ? String( pObject ) : (isFunction( pObject.toString ) ? pObject.toString() : objectToString.call( pObject, pObject )));

        let pattern = s.replace( /\/[gimsuy]+$/, "/" ).trim();

        if ( /^\/.+\/$/.test( pattern ) )
        {
            pattern = pattern.replace( /\/$/, _mt_str ).replace( /^\//, _mt_str );

            try
            {
                let regExp = new RegExp( pattern );
                return isRegExp( regExp, true );
            }
            catch( ex )
            {
                // ignored
            }
        }

        return false;
    };

    /**
     * Returns true if the specified object is an instance of one (or more) of the specified classes<br>
     *
     * @param {Object} pObject An object to evaluate
     * @param pClasses {...function} One or more classes to which to compare the specified object's prototype<br>
     *
     * @returns {boolean} true if the specified object is an instance of one (or more) of the specified classes<br>
     *
     * @alias module:TypeUtils.instanceOfAny
     */
    const instanceOfAny = function( pObject, ...pClasses )
    {
        if ( isNull( pObject ) )
        {
            return false;
        }

        const classes = ([...(pClasses || [])]).filter( e => isClass( e, false ) );

        let is = false;

        while ( !is && classes?.length && isObject( pObject ) )
        {
            const cls = classes.shift();

            if ( isClass( cls, !BUILTIN_TYPE_NAMES.includes( cls?.name ) ) )
            {
                try
                {
                    is = (pObject instanceof cls) || pObject?.constructor === cls || pObject.prototype === cls;
                }
                catch( ex )
                {
                    attemptSilent( () => toolBocksModule.reportError( ex, "attempting to call instanceof without a class or callable", S_WARN, modName + "::instanceOfAny" ) );
                }
            }
        }

        return is;
    };

    /**
     * Returns true if the specified function is a class that is not a built-in JavaScript type<br>
     *
     * @param {function} pFunction A function to evaluate
     *
     * @returns {boolean} true if the specified function is a class that is not a built-in JavaScript type<br>
     *
     * @alias module:TypeUtils.isUserDefinedClass
     */
    const isUserDefinedClass = function( pFunction )
    {
        return isClass( pFunction ) && !BUILTIN_TYPE_NAMES.includes( pFunction?.name );
    };

    /**
     * Returns true if the specified function is one or the specified classes<br>
     *
     * @param {function} pFunction A function to evaluate
     * @param {...function} pListedClasses One or more classes to which to compare the specified function<br>
     *
     * @returns {boolean} true if the specified function is one or the specified classes
     *
     * @alias module:TypeUtils.isListedClass
     */
    const isListedClass = function( pFunction, ...pListedClasses )
    {
        return isClass( pFunction ) && instanceOfAny( new pFunction(), ...pListedClasses );
    };

    /**
     * Retrieves the prototype of a provided object or class.
     *
     * This function attempts to determine the prototype of the given input using the following order of precedence:
     * - `Object.getPrototypeOf`.
     * - The `__proto__` property, if available.
     * - The constructor's `prototype` property.
     * - The direct `prototype` property of the input.
     *
     * For classes, it prioritizes retrieving the `prototype` property or the class itself.
     *
     * @param {object|Function} pObject - The object or class for which the prototype is to be determined.
     * @returns {object|null|undefined} The prototype of the given input, or `null`/`undefined` if it cannot be determined or if the input is not valid.
     */
    const getProto = function( pObject )
    {
        if ( isObject( pObject ) )
        {
            // noinspection JSUnresolvedReference
            return Object.getPrototypeOf( pObject ) || pObject?.__proto__ || pObject?.constructor?.prototype || pObject?.prototype || pObject?.constructor;
        }
        if ( isClass( pObject ) )
        {
            return pObject?.prototype || pObject;
        }
    };

    /**
     * Retrieves the constructor of the provided object or function.
     *
     * This function determines the constructor of a given object or function by
     * checking if the input is a function, a class, or an instance of a class.
     * It attempts to fetch the constructor reference through several fallback methods,
     * including checking the Symbol.species property or the prototype of the input.
     * If the input is not a function or class, it examines the prototype chain to
     * deduce the constructor.
     *
     * @param {Object|Function} pObject - The object or function whose constructor is to be retrieved.
     * @returns {Function|null} The constructor function if found, otherwise null.
     */
    const getConstructor = function( pObject )
    {
        if ( isFunction( pObject ) || isObject( pObject ) )
        {
            return isClass( pObject ) ? pObject : pObject?.constructor || getProto( pObject )?.constructor;
        }

        return null;
    };

    /**
     * Returns true if the specified object is an instance of a class that is not a built-in JavaScript type<br>
     *
     * @param {Object} pObject An object to evaluate
     * @param {function} [pClass=null] Specify a specific class to restrict the comparison to a specific user-defined class
     *
     * @returns {boolean} true if the specified object is an instance of a class that is not a built-in JavaScript type
     *
     * @alias module:TypeUtils.isInstanceOfUserDefinedClass
     */
    const isInstanceOfUserDefinedClass = function( pObject, pClass = null )
    {
        if ( isNull( pObject ) || !(isObject( pObject ) || isFunction( pObject )) )
        {
            return false;
        }

        let clazz = isClass( pClass ) ? (pClass || getClass( pObject ) || Object.getPrototypeOf( pObject )) : getClass( pObject ) || Object.getPrototypeOf( pObject )?.constructor || getProto( pObject );

        return isUserDefinedClass( clazz ) && (null === clazz || instanceOfAny( pObject, clazz ));
    };

    /**
     * Returns true if the specified object is an instance of one or more of the specified classes
     * <br>
     *
     * @param {Object} pObject An object to evaluate
     * @param {...function} pListedClasses One or more classes to which to compare the specified object's prototype
     *
     * @returns {boolean} true if the specified object is an instance of one or more of the specified classes
     *
     * @alias module:TypeUtils.isInstanceOfListedClass
     */
    const isInstanceOfListedClass = function( pObject, ...pListedClasses )
    {
        return instanceOfAny( pObject, ...([...(pListedClasses || [])].filter( isClass )) );
    };

    /**
     * Returns true if the specified value is an instance of, or is assignable to, one of the specified classes.<br>
     * That is, if the specified value is an instance of one of the classes or one of their subclasses,
     * this function returns true.
     *
     * @param {*} pValue - The value to be checked for assignment compatibility.
     * @param {...Function} pClass - One or more class constructors of which the value must be an instance of or a subclass of in order to return true.
     * If no classes are specified, the constructor of the object to which this function is bound is used.
     * @returns {boolean} - Returns true if the value is assignable to one or more of the specified classes
     */
    const isAssignableTo = function( pValue, ...pClass )
    {
        if ( isNull( pValue ) || !isObject( pValue ) )
        {
            return false;
        }

        const klasses = (isNull( pClass ) ? [this.constructor] : (isArray( pClass ) ? [...(pClass || [])] : [pClass])).filter( isClass );

        for( let klass of klasses )
        {
            const cls = getClass( klass || this.constructor ) || klass;

            if ( instanceOfAny( pValue, cls, cls[Symbol.species] ) && !(this === pValue) )
            {
                return true;
            }
        }

        return false;
    };

    function resolveCandidates( ...pCandidates )
    {
        let arr = !isNull( pCandidates ) ? (isArray( pCandidates ) || isSpreadable( pCandidates ) ? [...(pCandidates || [])] : []) : [];
        return (arr.length <= 1) ? arr.flat() : arr;
    }

    /**
     * Returns the first of the candidates that is of the specified type<br>
     * (or null if no candidates meet the criterion)<br>
     *
     * @param  {string|function} pType The type an object must match to be returned
     * @param {...*} pCandidates One or more candidates, the first of which that matches the specified type will be returned
     *
     * @returns {*|null} The first of the candidates that is of the specified type (or null if no candidates meet the criterion)
     *
     * @alias module:TypeUtils.firstMatchingType
     */
    const firstMatchingType = function( pType, ...pCandidates )
    {
        let arr = resolveCandidates( ...pCandidates );

        if ( isString( pType ) )
        {
            const type = pType.trim().toLowerCase();
            arr = VALID_TYPES.includes( type ) ? arr.filter( e => type === typeof e && !isNull( e ) ) : [];
        }
        else if ( isClass( pType, false ) )
        {
            arr = arr.filter( e => e instanceof pType );
        }
        else if ( isObject( pType ) )
        {
            arr = arr.filter( e => e instanceof getClass( pType ) );
        }
        else if ( isFunction( pType ) )
        {
            const scope = $scope();

            try
            {
                arr = arr.filter( e => attempt( () => pType.call( scope, e ) ) );
            }
            catch( ex )
            {
                toolBocksModule.reportError( ex, "attempting to call a function to filter an array", S_WARN, modName + "::firstMatchingType", pType?.name );
            }
        }
        else
        {
            arr = [];
        }

        return arr.length > 0 ? arr[0] : null;
    };

    class Finder
    {
        #filterCriteria = ( e ) => isNonNullValue( e ) || isNonNullObject( e );

        constructor( pFilterCriteria )
        {
            this.#filterCriteria = isFunction( pFilterCriteria ) ? pFilterCriteria : Finder.DEFAULT_FILTER;
        }

        defaultFilter()
        {
            return ( e ) => Finder.DEFAULT_FILTER( e );
        }

        get filterCriteria()
        {
            return this.#filterCriteria || this.defaultFilter();
        }

        findAll( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            return arr.filter( this.filterCriteria );
        }

        findFirst( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            return arr.find( this.filterCriteria ) || null;
        }

        findLast( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            arr = [...arr].reverse();
            return this.findFirst( ...arr );
        }

        findAllNot( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            return arr.filter( e => !this.filterCriteria( e ) );
        }

        findFirstNot( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            return arr.find( e => !this.filterCriteria( e ) );
        }

        findLastNot( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            arr = this.findAllNot( ...arr );
            return arr.length > 0 ? $last( arr ) : null;
        }

        indexOf( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            return arr.findIndex( this.filterCriteria );
        }

        lastIndexOf( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            return arr.lastIndexOf( this.filterCriteria );
        }

        indexes( ...pCandidates )
        {
            let rtn = [];

            let arr = resolveCandidates( ...pCandidates );

            for( let i = $ln( arr ); i--; )
            {
                if ( this.filterCriteria( arr[i] ) )
                {
                    rtn.push( i );
                }
            }

            return rtn;
        }

        findNth( pIdx, ...pCandidates )
        {
            const indices = this.indexes( ...pCandidates );

            const idx = $nth( indices, pIdx );

            return $nth( [...pCandidates], idx );
        }
    }

    Finder.DEFAULT_FILTER = ( e ) => isNonNullValue( e ) || isNonNullObject( e );

    const firstValidObject = function( ...pObjects )
    {
        const finder = new Finder( ( e ) => isNonNullObject( e ) && objectKeys( e ).length > 0 );
        return finder.findFirst( ...pObjects );
    };

    const firstPopulatedObject = function( ...pObjects )
    {
        const finder = new Finder( ( e ) => isNonNullObject( e ) && isPopulated( e ) );
        return finder.findFirst( ...pObjects );
    };

    /**
     * Returns the class (function) of which the specified object is an instance
     * <br>
     * or the class itself if the specified value <i>is</i> a class (function)
     * <br>
     * @param {Object|function} pObject An instance of some class or a function that is a class
     *
     * @returns {function} The class of which the object is an instance
     *                     or the class itself if the object is a class function
     *
     * @alias module:TypeUtils.getClass
     */
    const getClass = function( pObject )
    {
        const options = { rejectPrimitiveWrappers: false, allowEmptyObjects: true, rejectNull: true };

        const obj = isObject( pObject, options ) || isFunction( pObject ) || isClass( pObject ) ? pObject : null;

        if ( isNull( obj ) )
        {
            return null;
        }

        let clazz = isClass( obj ) ? obj : [obj?.constructor, obj?.prototype?.constructor, obj?.prototype, Object.getPrototypeOf( obj ), Object.getPrototypeOf( obj )?.constructor].find( e => isClass( e ) );

        if ( isClass( clazz ) )
        {
            return clazz;
        }

        if ( ( !options?.rejectPrimitiveWrappers && isPrimitiveWrapper( pObject )) || instanceOfAny( pObject, ...BUILTIN_TYPES ) )
        {
            return pObject?.constructor;
        }

        return clazz;
    };

    const resolveClass = function( pClass, pDefaultClass )
    {
        if ( isClass( pClass ) )
        {
            return pClass;
        }

        let klass = getClass( pClass || pDefaultClass );

        klass = isClass( klass ) ? klass : isClass( pDefaultClass ) ? pDefaultClass : getClass( pDefaultClass );

        return isClass( klass ) ? klass : null;
    };

    /**
     * Returns the name of the class of which the specified object is an instance
     * <br>
     * or the name of the class if the specified value <i>is</i> a class (function)
     * <br>
     * @param {Object|function} pObject An instance of some class or a function that is a class
     *
     * @returns {string} The name of the class of which the object is an instance
     * or the name of the class if the object is a class function
     *
     * @alias module:TypeUtils.getClassName
     */
    const getClassName = function( pObject )
    {
        const clazz = getClass( pObject );
        return (!isNull( clazz ) ? clazz?.name || objectToString.call( clazz, clazz ).replace( /\[object\s+/, _mt_str ).replace( /\s*]\s*$/, _mt_str ) : _mt_str) || _mt_str;
    };

    /**
     * Returns the default value for the type specified
     *
     * @param {string} pType The type for which to return a default value
     * @see {@link TYPE_DEFAULTS}
     * @returns {*}
     *
     * @alias module:TypeUtils.defaultFor
     */
    const defaultFor = function( pType )
    {
        let type = isString( pType ) ? (_mt_str + pType).trim().toLowerCase() : typeof (pType);
        return (isString( type ) && JS_TYPES.includes( type )) ? TYPE_DEFAULTS[type] : defaultFor( typeof type );
    };

    /**
     * @typedef {object} CastOptions
     *
     * @property {string} propertyKey
     * @property {function} nullOrUndefined: defaultFor
     * @property {Array.<string>} reduceArrayFor: [_num, _big, _bool]
     * @property {boolean} preserveArrayForCastToObject: true
     * @property {string} joinOn: _mt_str
     * @property {boolean} executeFunctions: true
     * @property {object} bindFunctionsTo: null
     * @property {Array.<*>} passToFunctions: []
     * @property {object|function} dateFormatter: null
     * @property {object|function} dateParser: null
     *
     */

    /**
     * A constant object defining the default options for casting operations.
     *
     * @constant {Object} DEFAULT_CAST_OPTIONS
     * @type {CastOptions}
     * @property {string} propertyKey - The default key to use when accessing properties for casting.
     * @property {Function} nullOrUndefined - A function to handle default values for null or undefined inputs.
     * @property {Array} reduceArrayFor - An array of types to attempt reduction for when casting arrays.
     * @property {boolean} preserveArrayForCastToObject - Determines whether to preserve arrays when casting to objects.
     * @property {string} joinOn - A delimiter string used when joining array values into a single string during casting.
     * @property {boolean} executeFunctions - Indicates whether to execute functions during the casting process.
     * @property {Object|null} bindFunctionsTo - If specified, binds functions to this object during execution.
     * @property {Array} passToFunctions - Functions to be passed during casting operations.
     * @property {Function|null} dateFormatter - A function to format date objects during casting, or null for default behavior.
     * @property {Function|null} dateParser - A function to parse date strings during casting, or null for default behavior.
     */
    const DEFAULT_CAST_OPTIONS =
        {
            propertyKey: _mt_str,
            nullOrUndefined: defaultFor,
            reduceArrayFor: [_num, _big, _bool],
            preserveArrayForCastToObject: true,
            joinOn: _mt_str,
            executeFunctions: true,
            bindFunctionsTo: null,
            passToFunctions: [],
            dateFormatter: null,
            dateParser: null,
        };

    /**
     * CastUtils is a utility class designed for consistent type casting and transformations between various data types.
     * The class supports a range of type conversions while providing flexibility and customization through options.
     *
     * @class
     * @private
     */
        // noinspection JSPrimitiveTypeWrapperUsage
    class CastUtils
    {
        #toType;
        #originalValue;
        #value;
        #key;
        #options;

        #numericFilter = e => isValidDateOrNumeric( e ) || isBoolean( e );
        #toNumber = e => isDate( e ) ? attempt( () => e.getTime() ) : (isBoolean( e ) ? (e ? 1 : 0) : toDecimal( e ));

        constructor( pValue, pToType, pOptions = DEFAULT_CAST_OPTIONS )
        {
            this.#options = populateOptions( pOptions || {}, DEFAULT_CAST_OPTIONS );

            this.#key = this.#options?.propertyKey || _mt_str;

            this.#toType = isString( pToType ) ? (String( _mt_str + pToType ).trim().toLowerCase()) : typeof (pToType);
            this.#toType = isString( this.#toType ) && VALID_TYPES.includes( this.#toType ) ? this.#toType : _str;

            this.#originalValue = pValue;

            this.#value = this.initializeValue( pValue );
        }

        get toType()
        {
            return String( this.#toType || _str ).trim().toLowerCase();
        }

        get value()
        {
            let val = isPromise( this.#value ) ? Promise.resolve( this.#value ).then( ( pResult ) => this.#value = pResult ) : this.#value;
            return isPromise( val ) ? this.#originalValue : val;
        }

        get key()
        {
            return String( this.#key || _mt_str ).trim();
        }

        get options()
        {
            return { ...DEFAULT_CAST_OPTIONS, ...(this.#options || {}) };
        }

        get numericFilter()
        {
            return this.#numericFilter;
        }

        get toNumber()
        {
            return this.#toNumber;
        }

        arrToNumber( pArr )
        {
            return [...(pArr || [])].flat( Infinity ).filter( this.#numericFilter ).map( this.#toNumber ).reduce( ( acc, e ) => acc + toDecimal( e ), 0 );
        }

        initializeValue( pValue )
        {
            const me = this;
            const type = this.#toType || _str;

            let value = pValue;

            if ( _ud === typeof pValue || isNull( pValue, true ) )
            {
                const nullOrUndefined = this.#options?.nullOrUndefined;
                value = isFunction( nullOrUndefined ) ? attempt( () => nullOrUndefined?.call( me, type ) ) : null;
            }

            if ( this.#toType === typeof value )
            {
                this.#value = value;
                return value;
            }

            const reduceArrayForTypes = [...(this.#options?.reduceArrayFor || [])].filter( e => isString( e ) && VALID_TYPES.includes( e.trim().toLowerCase() ) );

            if ( isArray( value ) && reduceArrayForTypes?.includes( this.#toType ) )
            {
                value = this.reduceArray( [...(value)] || [] );
            }

            if ( _fun !== this.#toType && isFunction( value ) )
            {
                value = this.executeFunctions( value );
            }

            this.#value = value;

            return value;
        }

        executeFunctions( pValue )
        {
            const me = this;

            let value = pValue || this.#value || this.#originalValue;

            if ( _fun !== this.#toType && isFunction( value ) && this.#options?.executeFunctions )
            {
                let args = [...(this.#options?.passToFunctions || [])];

                let bindTo = this.#options?.bindFunctionsTo || me || this;

                let result = attempt( () => value.call( bindTo, ...args ) );

                result = (isPromise( result ) ? asyncAttempt( async() => result.then( e => e ).then( value => me.initializeValue( value ) ) ) : result);

                value = isPromise( result ) ? value : result;
            }

            return value;
        }

        reduceArray( pArray )
        {
            if ( !isLikeArray( pArray ) )
            {
                return pArray;
            }

            const me = this;

            let value = [...(pArray || this.#value || [])];

            value = [_num, _big, _bool].includes( this.#toType ) ? attempt( () => (me || this).arrToNumber( value ) ) : value;

            value = this.#toType === _str ? pArray.map( e => String( _mt_str + e ) ).join( this.#options?.joinOn || _mt_str ) : value;

            value = this.#toType === _symbol ? pArray.map( e => (isSymbol( e ) ? e : Symbol.for( e ) || Symbol( e )) ) : value;

            value = this.#toType === _obj ? (!this.#options?.preserveArrayForCastToObject ? { ...(objectValues( value ).flat()) } : value) : value;

            value = this.#toType === _fun ? isArray( value ) ? [...(value || [])].map( e => isFunction( e ) ? e : () => e ) : value : value;

            return value;
        }

        castToBoolean( pValue )
        {
            let value = pValue || this.value || this.#originalValue;

            if ( isBoolean( value ) )
            {
                return value;
            }

            if ( isFunction( Boolean.evaluate ) )
            {
                value = attempt( () => Boolean.evaluate( value ) );
            }

            if ( isFunction( value ) )
            {
                const me = this;
                let args = [...(this.#options?.passToFunctions || [])];
                let bindTo = this.#options?.bindFunctionsTo || me || this;
                value = attempt( () => value.call( bindTo, ...args ) );
            }

            value = isDate( value ) || isFunction( value?.getTime ) ? attempt( () => value.getTime() ) : value;

            value = isArray( value ) ? this.arrToNumber( value ) : value;

            value = isObject( value ) ? attempt( () => Object.keys( value || {} ).length > 0 ) : value;

            value = isString( value ) && [...(_affirmatives || [])].includes( String( value ).trim().toLowerCase() ) ? true : value;

            value = isNumeric( value ) ? (toDecimal( value ) > 0) : value;

            return Boolean( value );
        }

        castToNumber( pValue, pAsBigInt = false )
        {
            let value = pValue || this.value;

            value = isSymbol( value ) ? 0 : value;
            value = isPrimitiveWrapper( value ) ? attempt( () => value.valueOf() ) : value;
            value = isArray( value ) ? this.arrToNumber( value ) : value;
            value = isNumeric( value ) ? toDecimal( value ) : value;
            value = isBoolean( value ) ? (value ? 1 : 0) : value;
            value = isDate( value ) ? attempt( () => value.getTime() ) : value;
            value = (isFunction( value?.asFloat )) ? attempt( () => value.asFloat() ) : toFloat( value );

            return pAsBigInt ? BigInt( parseInt( toDecimal( value ) ) ) : toDecimal( Number( value ) );
        }

        castToString( pValue )
        {
            let value = pValue || this.value;

            if ( false === pValue )
            {
                return "false";
            }

            value = isString( value ) ? value : isPrimitiveWrapper( value ) ? attempt( () => value.valueOf() ) : value;

            value = isString( value ) ? value : isDate( value ) ? this.castDateToString( value ) || value : value;

            value = isFunction( value ) ? attempt( () => functionToString.call( value, value ) ) : value;

            value = isArray( value ) ? [...(value || [])].map( e => this.castToString( e ) ).join( this.options?.joinOn ) : value;

            value = isNumeric( value ) ? String( toDecimal( value ) ) : value;

            value = isString( value ) ? value : isFunction( value?.asString ) ? attempt( () => value.asString() ) : value;

            const prior = value || pValue || this.value;

            value = isString( value ) ? value : isFunction( value?.toString ) ? attempt( () => value.toString() ) : value;

            if ( /\[object\s*]/.test( String( value ) ) || ("[object Object]" === String( value )) )
            {
                value = attempt( () => JSON.stringify( prior || {} ) ) || "{}";
            }

            return isString( value ) ? value : _mt_str + String( value );
        }

        castDateToString( pDate, pDateFormatter )
        {
            let date = pDate || this.value;

            let str = isDate( date ) ? attempt( () => date.toISOString() ) : _mt_str;

            if ( isValidDateOrNumeric( date ) )
            {
                date = new Date( toDecimal( date?.getTime ? (attempt( () => date.getTime() ) || date) : date ) );

                const dateFormatter = pDateFormatter || this.options?.dateFormatter || (function( pDate ) { return isDate( pDate ) ? pDate?.toISOString() || _mt_str : String( pDate ); });

                const formatter = isFunction( dateFormatter?.format ) ? dateFormatter.format : dateFormatter;

                str = isFunction( formatter ) ? attempt( () => formatter.call( dateFormatter, date ) ) : str;
            }

            return str || attempt( () => (date || pDate).toISOString() );
        }

        castToDate( pValue, pDateParser )
        {
            let value = pValue || this.value;

            if ( isDate( value ) )
            {
                return new Date( value );
            }

            if ( isValidDateOrNumeric( value ) )
            {
                return new Date( parseInt( toDecimal( value ) ) );
            }

            if ( isString( value ) )
            {
                const dateParser = pDateParser || this.options.dateParser || (function( pVal ) { return isString( pVal ) ? attempt( () => new Date( pVal ) ) : null; });

                const parser = isFunction( dateParser?.parse ) ? dateParser?.parse : (isFunction( dateParser?.parseDate ) ? dateParser.parseDate : dateParser);

                const date = isFunction( parser ) ? attempt( () => parser.call( dateParser, value ) ) : null;

                return !isNaN( date ) && isDate( date ) ? date : null;
            }

            toolBocksModule.reportError( new Error( "unable to parse date" ), "attempting to parse date", S_WARN, modName + "::castToDate", value );

            return null;

        }

        castToObject( pValue, pPropertyKey )
        {
            const me = this;

            let value = pValue || this.value;
            let key = pPropertyKey || this.key;

            if ( _ud === typeof pValue || isNull( pValue, true ) )
            {
                const nullOrUndefined = this.#options?.nullOrUndefined;
                value = isFunction( nullOrUndefined ) ? attempt( () => nullOrUndefined?.call( me, this.toType ) ) : null;
            }

            value = isArray( value ) ? (this.options?.preserveArrayForCastToObject ? value : { ...(objectValues( value ).flat()) }) : value;

            if ( isFunction( value ) )
            {
                return this.objectFromFunction( value, key );
            }

            if ( isSymbol( value ) )
            {
                return { value };
            }

            if ( isEmptyString( key ) )
            {
                value = this.boxPrimitive( value );
            }
            else
            {
                value = { [key]: value };
            }

            return value;
        }

        boxPrimitive( pValue )
        {
            let value = pValue || this.value;
            // noinspection JSPrimitiveTypeWrapperUsage
            value = isString( pValue ) ? new String( value ) : value;
            // noinspection JSPrimitiveTypeWrapperUsage
            value = isBoolean( pValue ) ? new Boolean( value ) : value;
            return isNumber( value ) ? _big === this.toType ? new Number( BigInt( parseInt( value ) ) ) : new Number( value ) : value;
        }

        objectFromFunction( pValue, pKey = _mt_str )
        {
            let value = pValue || this.value;
            let key = pKey || this.key;

            if ( isFunction( value ) )
            {
                value =
                    {
                        apply: ( pThis, ...pArgs ) => value.apply( pThis || $scope(), [...pArgs] ),
                        call: ( pThis, ...pArgs ) => value.call( pThis || $scope(), ...pArgs ),
                    };
            }

            if ( !isEmptyString( key ) )
            {
                value[key] = value;
            }

            return value;
        }

        castToFunction( pValue, pAsynchronous = false )
        {
            let value = pValue || this.value;

            if ( isFunction( value ) )
            {
                if ( pAsynchronous )
                {
                    return isAsyncFunction( value ) ? value : () => asyncAttempt( () => value() );
                }
                return value;
            }

            return pAsynchronous ? isAsyncFunction( value ) ? value : () => asyncAttempt( () => value ) : () => attempt( () => value );
        }

        castToSymbol( pValue )
        {
            let value = pValue || this.value;
            return isSymbol( value ) ? value : (isString( value ) ? Symbol.for( String( _mt_str + value ) ) || Symbol( String( _mt_str + value ) ) : null);
        }

        cast( pValue )
        {
            let value = isNonNullValue( pValue ) || isNonNullObject( pValue ) ? pValue : (pValue || this.value);

            if ( this.toType === typeof value )
            {
                return value;
            }

            switch ( this.toType )
            {
                case _num:
                case _big:
                    return this.castToNumber( value, _big === this.toType );

                case _bool:
                    return this.castToBoolean( value );

                case _str:
                    return this.castToString( value );

                case _obj:
                    return this.castToObject( value );

                case _fun:
                    return this.castToFunction( value );

                case _symbol:
                    return this.castToSymbol( value );

                default:
                    break;
            }

        }
    }

    /**
     * Returns a new value converted to the specified type, if possible
     * <br>
     * @param {*} pValue A value to convert to the specified type
     * @param {string} pType The type to which to convert the specified value, if possible
     *
     * @param pOptions
     * @returns {*} a new value converted to the specified type, if possible
     *
     * @alias module:TypeUtils.castTo
     */
    const castTo = ( pValue, pType, pOptions = DEFAULT_CAST_OPTIONS ) => (new CastUtils( pValue, pType, pOptions )).cast();

    /**
     * Similar to the SQL function,
     * returns the first defined/non-null value that is also not NaN or Infinity.
     *
     * If all values are null, undefined, or NaN, or =/-Infinity, returns null.
     *
     *
     * @param {...*} pValue - One or more variables of any type, the first of which that is not null or undefined will be returned.
     * @returns {*} - The first value that is not null, undefined, NaN, or Infinity.
     * If all specified values are either null, undefined, NaN, or Infinity, returns null.
     */
    const NVL = function( ...pValue )
    {
        let arr = [...(pValue || [])];
        arr = arr.filter( isNonNullValue );
        arr = arr.filter( e => !isNumber( e ) || !isNanOrInfinite( e ) );
        return arr.length > 0 ? arr[0] : null;
    };

    /**
     * This class can be used to convert any non-null value into an iterable.
     * <br>
     * Unlike JavScript's built-in iterators, this class's iterator can be traversed in reverse and/or reset
     * <br>
     *
     * alias module:TypeUtils._Iterable
     *
     * @class
     *
     * @protected
     */
    class _Iterable
    {
        #iterable;
        #arrayLike;
        #iterator;
        #index = 0;

        #iterated = [];

        /**
         * @constructor
         *
         * @param {*} pIterable Any value to be treated as an iterable
         *
         * @return {_Iterable} A new iterable that can be used to iterate the value(s) with which it was constructed
         */
        constructor( pIterable )
        {
            this.#iterable = isIterable( pIterable ) ? pIterable : [pIterable];
            this.#iterable = isString( this.#iterable ) ? [].concat( this.#iterable.split( _mt_str ) ) : this.#iterable;

            if ( isLikeArray( this.#iterable ) )
            {
                this.#arrayLike = [...this.#iterable];
            }
            else if ( isMap( this.#iterable ) || isSet( this.#iterable ) )
            {
                this.#arrayLike = [...this.#iterable.values()];
            }

            if ( isIterable( this.#iterable ) )
            {
                const me = this;
                this.#iterator = attempt( () => (me || this).#iterable[Symbol.iterator]() );
            }
        }

        static get [Symbol.species]()
        {
            return this;
        }

        [Symbol.iterator]()
        {
            return this;
        }

        next()
        {
            if ( this.#arrayLike?.length )
            {
                if ( this.#index >= this.#iterable.length )
                {
                    return { done: true };
                }

                const value = this.#iterable[this.#index++];

                this.#iterated.push( value );

                return { value, done: false };
            }

            return this.#iterator?.next();
        }

        previous()
        {
            if ( this.#index > 0 )
            {
                if ( this.#arrayLike?.length )
                {
                    const value = this.#iterable[--this.#index];
                    return { value, done: false };
                }
                return this.#iterated?.length >= this.#index ?
                    {
                        value: this.#iterated[--this.#index],
                        done: false
                    } :
                    { done: true };
            }
            return { done: true };
        }

        reset()
        {
            this.#index = 0;
        }

        reverseIterator()
        {
            if ( this.#arrayLike?.length )
            {
                let newIterable = [...this.#iterable].reverse();
                return new this.constructor( newIterable );
            }
            toolBocksModule.reportError( new Error( "cannot reverse this iterator" ), "attempting to reverse an iterator", S_ERROR, modName + "::_Iterable::reverseIterator" );
            return this.#iterated.reverse();
        }
    }

    /**
     * A wrapper class to adapt a synchronous iterator into an asynchronous iterator.<br>
     * Provides asynchronous iteration capabilities for iterables or iterators.<br>
     */
    class _AsyncIterator
    {
        #iterator;

        constructor( pIterator )
        {
            this.#iterator = pIterator;
        }

        async next()
        {
            return await this.#iterator.next();
        }

        [Symbol.asyncIterator]()
        {
            return this;
        }

        [Symbol.iterator]()
        {
            return this.#iterator;
        }
    }

    /**
     * This subclass of _Iterable just returns done immediately
     * @class
     * @extends _Iterable
     *
     * alias module:TypeUtils.NullIterator
     *
     * @protected
     *
     */
    class NullIterator extends _Iterable
    {
        constructor()
        {
            super( [] );
        }

        next()
        {
            return { done: true };
        }

        previous()
        {
            return { done: true };
        }
    }

    function _objToIterable( pArrayLike )
    {
        if ( pArrayLike instanceof Map )
        {
            return new _Iterable( [...pArrayLike.entries()] );
        }
        else if ( pArrayLike instanceof Set )
        {
            return new _Iterable( [...(pArrayLike.values())] );
        }
        else if ( isDate( pArrayLike ) )
        {
            return new _Iterable( [pArrayLike] );
        }
        else if ( isArray( pArrayLike ) || isIterable( pArrayLike ) )
        {
            return new _Iterable( pArrayLike );
        }
        else
        {
            const newObject = {};

            const entries = objectEntries( pArrayLike );

            for( let entry of entries )
            {
                const key = ObjectEntry.getKey( entry );

                const value = ObjectEntry.getValue( entry );

                newObject[key] = toIterable( value );
            }

            return new _Iterable( Object.entries( newObject ) );
        }
    }

    /**
     * Returns an _Iterable for the specified value
     *
     * @param pArrayLike almost any kind of value,
     *                   but generally expected to be an "indexable" collection of values
     *                   strings are converted into an array of characters,
     *                   scalar values are converted into a 1-element array containing the value
     *
     * @param {boolean} pAsync Pass true to create an AsyncIterable
     *
     * @returns {_AsyncIterator|_Iterable} an instance of _Iterable or _AsyncIterator
     */
    const toIterable = function( pArrayLike, pAsync = false )
    {
        let iterable;

        switch ( typeof pArrayLike )
        {
            case _ud:
                iterable = new NullIterator();
                break;

            case _str:
                iterable = new _Iterable( pArrayLike.split( _mt_str ) );
                break;

            case _num:
            case _big:
            case _bool:
                iterable = new _Iterable( [pArrayLike] );
                break;

            case _fun:
                if ( isGeneratorFunction( pArrayLike ) )
                {
                    iterable = pArrayLike();
                }
                else
                {
                    iterable = new _Iterable( [pArrayLike] );
                }
                break;

            case _obj:
                iterable = _objToIterable( pArrayLike );
                break;

            default:
                iterable = new NullIterator();
        }

        return pAsync ? new _AsyncIterator( iterable ) : iterable;
    };

    /**
     * This class represents the common, functional programming inspired, Option or Maybe type<br>
     * @see https://en.wikipedia.org/wiki/Option_type
     *
     * @class
     *
     * @alias module:TypeUtils#classes#Option
     *
     */
    class Option
    {
        #value;

        constructor( pValue )
        {
            this.#value = (pValue instanceof this.constructor) ? pValue.value : pValue;
            while ( isNonNullObject( this.#value ) && (this.#value instanceof this.constructor) )
            {
                this.#value = this.value?.value;
            }
        }

        get value()
        {
            return lock( this.#value );
        }

        static Some( pValue )
        {
            return new Option( pValue );
        }

        static None()
        {
            return new Option( null );
        }

        isSome()
        {
            return (isDefined( this.#value ) && null !== this.#value && !isError( this.#value ));
        }

        isNone()
        {
            return isUndefined( this.#value ) || null === this.#value || isError( this.#value );
        }

        map( pFunction )
        {
            const func = isFunction( pFunction ) ? pFunction : ( e ) => e;
            return this.isSome() ? Option.Some( func( this.#value ) ) : Option.None();
        }

        flatMap( pFunction )
        {
            const func = isFunction( pFunction ) ? pFunction : ( e ) => e;
            return this.map( func ).getOrElse( Option.None() );
        }

        getOrElse( pDefault )
        {
            return this.isSome() ? this.value : pDefault;
        }
    }

    /**
     * This class extends Option and requires that the 'Some' value be of the type specified<br>
     *
     * @class
     * @extends Option
     *
     * @alias module:TypeUtils#classes#TypedOption
     */
    class TypedOption extends Option
    {
        #type;

        constructor( pValue, pType )
        {
            super( pValue );

            this.#type = pType || typeof (pValue);
        }

        get type()
        {
            return this.#type || _obj;
        }

        static Some( pValue, pType )
        {
            return new TypedOption( pValue, pType );
        }

        static None()
        {
            return new Option( null );
        }

        isSome()
        {
            return super.isSome() && isType( this.value, this.type );
        }

        isNone()
        {
            return super.isNone() || !isType( this.value, this.type );
        }

        map( pFunction )
        {
            const type = this.type;

            const func = isFunction( pFunction ) ? pFunction : ( e ) => castTo( e, type );

            return super.map( func );
        }

        flatMap( pFunction )
        {
            const type = this.type;

            const func = isFunction( pFunction ) ? pFunction : ( e ) => castTo( e, type );

            return super.flatMap( func );
        }

        getOrElse( pDefault )
        {
            const value = super.getOrElse( pDefault );

            if ( this.type === typeof (value) )
            {
                return value;
            }

            if ( this.type === typeof (pDefault) )
            {
                return pDefault;
            }
        }
    }

    /**
     * This class extends TypedOption and requires that the 'Some' value be a string<br>
     *
     * @class
     *
     * @extends TypedOption
     *
     * @alias module:TypeUtils#classes#StringOption
     */
    class StringOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _str );
        }
    }

    /**
     * This class extends TypedOption and requires that the 'Some' value be a number
     * <br>
     * @class
     * @extends TypedOption
     * @alias module:TypeUtils#classes#NumericOption
     */
    class NumericOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _num );
        }
    }

    /**
     * This class extends TypedOption and requires that the 'Some' value be a boolean
     * <br>
     * @class
     * @extends TypedOption
     * @alias module:TypeUtils#classes#BooleanOption
     */
    class BooleanOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _bool );
        }
    }

    /**
     * This class is used to represent a succsul result from a function with no return value
     */
    class VOID
    {
        #valid = true;

        constructor( pValid = true )
        {
            this.#valid = !!pValid;
        }

        get valid()
        {
            return this.#valid;
        }
    }

    VOID.OK = lock( new VOID( true ) );
    VOID.ERROR = lock( new VOID( false ) );

    function isVoid( pVal )
    {
        return pVal instanceof VOID;
    }

    /**
     * This class represents the return value of a function<br>
     * that might return null or throw exceptions<br>
     * <br>
     * This class extends Option,<br>
     * so you can use getOrElse or check for isSome or isNone,<br>
     * as well as check for whether the function has thrown an error
     * <br>
     * <br>
     * Functions that return a Result<br>
     * should catch errors and then add them to the Result before returning,<br>
     * rather than throw an Error<br>
     * <br>
     * This style of programming can reduce the effort of checking for null
     * <br>
     * or of wrapping function calls in try/catch blocks
     * <br>
     *
     * @class
     * @extends Option
     * @alias module:TypeUtils#classes#Result
     */
    class Result extends Option
    {
        #exceptions = [];

        constructor( pValue, ...pErrors )
        {
            super( pValue );

            let val = pValue;

            let errors = (pErrors && isArray( pErrors )) ? [...(pErrors || [])] : [];

            while ( isNonNullObject( val ) && val instanceof this.constructor )
            {
                errors.push( ...([...(val.exceptions || [])]) );
                val = val.getOrElse( null );
            }

            if ( isError( val ) )
            {
                errors.unshift( resolveError( val ) );
            }

            if ( $ln( errors ) )
            {
                this.#exceptions.push( ...([...(errors || [])].flat().filter( isError ) || []) );
            }

            if ( isError( pValue ) )
            {
                this.#exceptions.unshift( pValue );
            }
        }

        get returnValue()
        {
            return super.getOrElse( null );
        }

        get exceptions()
        {
            return ([].concat( this.#exceptions || [] ).flat()).filter( isError );
        }

        get errors()
        {
            return this.exceptions;
        }

        addErrors( ...pError )
        {
            this.#exceptions.push( ...pError );
            this.#exceptions = this.#exceptions.flat().filter( isError );
        }

        hasErrors()
        {
            return $ln( this.exceptions ) > 0;
        }

        get succeeded()
        {
            return !isError( this.value ) && !this.hasErrors();
        }

        toString()
        {
            let s = "{\"Result\":\"" + String( this.getOrElse( _mt ) ) + "\"";

            if ( this.hasErrors() )
            {
                s += ", \"errors\":\"" + this.exceptions.map( e => "\"" + (e?.message || "an error") + "\"" );
            }

            s += "}";

            return s.trim();
        }

        [Symbol.toPrimitive]( pHint )
        {
            return this.toString();
        }
    }

    class VoidResult extends Result
    {
        constructor( ...pErrors )
        {
            super( new VOID( $ln( [...(pErrors || [])] ) <= 0 ), ...pErrors );
        }

        get succeeded()
        {
            return super.succeeded && isVoid( this.value ) && this.value?.valid;
        }
    }

    /**
     * Returns a valid Date object based on the specified value.<br>
     * If the specified value is a valid Date, returns that value,
     * otherwise, returns the current Date.
     *
     * @param {*} pNow - The input value to be resolved. It can be a date, numeric timestamp,
     *                   or any other data type.
     *
     * @returns {Date}   A Date object derived from the input.
     *                   If the input is:
     *                 - A valid Date object, it is returned as-is.
     *                 - A numeric timestamp, it is converted to a Date object.
     *                   If the timestamp does not result in a valid date, the current date is returned.
     *                 - Any other data type, the current date is returned.
     */
    const resolveMoment = ( pNow ) => isDate( pNow ) ? pNow : (isNumeric( pNow ) ? (isDate( new Date( pNow ) ) ? new Date( pNow ) : new Date()) : new Date());

    /**
     * Returns true if the specified value is a directory entry object.<br>
     * <br>
     * A directory entry is an object matching the structure of the objects returned by Node.js or Deno
     * when reading a directory with file types=true.<br>
     * <br>
     * This function checks if the provided object represents a directory entry,
     * considering both Deno's `DirEntry` structure and Node.js's `Dirent`.
     * For Deno `DirEntry`, the object must have a `name` property and include
     * the boolean properties `isFile`, `isDirectory`, and `isSymLink`.
     * For Node.js `Dirent`, the object must have the `name` property and
     * include the methods `isFile`, `isDirectory`, and `isSymbolicLink`.
     *
     * @param {Object} pEntry - The input to be evaluated as a possible directory entry.
     *
     * @returns {boolean} - Returns true if the input is a valid directory entry object, otherwise false.
     *
     * @alias module:TypeUtils.isDirectoryEntry
     */
    const isDirectoryEntry = function( pEntry )
    {
        if ( isNull( pEntry ) || !isNonNullObject( pEntry ) )
        {
            return false;
        }

        const keys = objectKeys( pEntry );

        if ( keys.includes( "name" ) )
        {
            // check for Deno.DirEntry
            if ( keys.includes( "isFile" ) && keys.includes( "isDirectory" ) && keys.includes( "isSymLink" ) )
            {
                return true;
            }

            // check for Node.js Dirent
            return !!(isFunction( pEntry?.isFile ) &&
                      isFunction( pEntry?.isDirectory ) &&
                      isFunction( pEntry?.isSymbolicLink ));
        }

        return false;
    };

    /**
     * Returns true if the specified value is an instance of ArrayBuffer.<br>
     * <br>
     * This function evaluates whether the given parameter is an object
     * of type ArrayBuffer. It ensures that ArrayBuffer is defined and
     * accessible before performing the instance check. If the environment
     * does not support ArrayBuffer, the function returns false.
     *
     * @param {*} pValue - The value to be checked against ArrayBuffer.
     * @returns {boolean} True if the value is an instance of ArrayBuffer, otherwise false.
     *
     * @alias module:TypeUtils.isArrayBuffer
     */
    const isArrayBuffer = ( pValue ) => (_ud !== typeof ArrayBuffer && pValue instanceof ArrayBuffer);

    /**
     * Returns true if the specified value is an instance of SharedArrayBuffer.<br>
     * <br>
     * This function evaluates whether the given parameter is an object
     * of type SharedArrayBuffer. It ensures that SharedArrayBuffer is defined and
     * accessible before performing the instance check. If the environment
     * does not support SharedArrayBuffer, the function returns false.
     *
     * @param {*} pValue - The value to be checked against SharedArrayBuffer.
     * @returns {boolean} True if the value is an instance of SharedArrayBuffer, otherwise false.
     *
     * @alias module:TypeUtils.isSharedArrayBuffer
     */
    const isSharedArrayBuffer = ( pValue ) => (_ud !== typeof SharedArrayBuffer && pValue instanceof SharedArrayBuffer);

    /**
     * Returns true if the specified value is an instance of DataView.<br>
     * <br>
     * This function evaluates whether the given parameter is an object
     * of type DataView. It ensures that DataView is defined and
     * accessible before performing the instance check. If the environment
     * does not support DataView, the function returns false.
     *
     * @param {*} pValue - The value to be checked against DataView.
     * @returns {boolean} True if the value is an instance of DataView, otherwise false.
     *
     * @alias module:TypeUtils.isArrayBuffer
     */
    const isDataView = ( pValue ) => (_ud !== typeof DataView && pValue instanceof DataView);


    /**
     * Returns the first object that is an instance of Error from the provided input.<br>
     * <br>
     * <br>
     * The function takes a variable number of parameters, processes them into a flat array,
     * and filters out non-error objects. It then returns the first error object found.
     * <br>
     * <br>
     * If the input is null or undefined, or if none of the elements are error objects,
     * the function returns null.
     *
     * @function firstError
     *
     * @param {...*} pObj - A variable number of arguments, which can be of any type.
     *                      If multiple arguments are passed, they are converted into a flat array.
     *                      Only error objects within this input are considered.
     *
     * @returns {Error|undefined} The first error object from the input, or undefined if no errors are found.
     *
     * @alias module:TypeUtils.firstError
     */
    const firstError = function( ...pObj )
    {
        let arr = (!isNull( pObj ) ? isArray( pObj ) ? [...(pObj || [])] : [pObj] : []).flat().filter( isError );
        return arr.filter( isError ).shift() || null;
    };

    const DEFAULT_TRANSFORMER_PROPERTIES =
        {
            recursive: true,
            keyTransformer: ( pKey ) => pKey,
            valueTransformer: ( pValue ) => pValue
        };

    const DEFAULT_OBJECT_LITERAL_OPTIONS =
        {
            prune: false,
            trimStrings: false,
            omitFunctions: true,
            transientProperties: [],
            privatePropertyPrefixes: [_hash],
            skipPrivateProperties: true,
            preserveArrays: true,
            maxDepth: 32,
            preserveUserDefinedClasses: false,
            preserveTypes: true,
            respectToLiteralMethod: true,
            ...DEFAULT_TRANSFORMER_PROPERTIES
        };

    const FAST_OBJECT_LITERAL_OPTIONS =
        {
            prune: false,
            trimStrings: false,
            omitFunctions: true,
            transientProperties: ["class", "prototype"],
            privatePropertyPrefixes: [_hash, _underscore],
            skipPrivateProperties: true,
            preserveArrays: true,
            maxDepth: 5,
            preserveUserDefinedClasses: true,
            preserveTypes: false,
            respectToLiteralMethod: true,
            ...DEFAULT_TRANSFORMER_PROPERTIES
        };

    function restoreMethods( pSource, pTarget, pOptions = DEFAULT_OBJECT_LITERAL_OPTIONS )
    {
        const source = pSource || {};
        const target = pTarget || source;

        const options = { ...DEFAULT_OBJECT_LITERAL_OPTIONS, ...(pOptions || {}) };

        if ( !options.omitFunctions )
        {
            const excludedMethods = [...TRANSIENT_PROPERTIES, "constructor", "toString", "valueOf"];

            const excludeGeneric = e => isString( e ) && !excludedMethods.includes( e.trim() );

            objectMethods( source ).filter( excludeGeneric ).forEach( ( method ) =>
                                                                      {
                                                                          const func = source[method];
                                                                          if ( isFunction( func ) )
                                                                          {
                                                                              target[method] = func.bind( target );
                                                                          }
                                                                      } );
            return target;
        }
    }

    function resolveObjectLiteralArguments( pOptions, pVisited, pStack, pDepth = 0 )
    {
        const options = { ...DEFAULT_OBJECT_LITERAL_OPTIONS, ...(pOptions || {}) };

        const visited = pVisited || options?.visited || new ResolvedSet();

        const stack = [...(pStack || options?.stack || [])];

        let depth = isNumeric( pDepth ) ? toInteger( pDepth ) : 0;
        depth = isNanOrInfinite( depth ) ? 0 : clamp( depth, 0, 256 );

        return { options, visited, stack, depth };
    }

    const processValue = ( pValue, pOptions ) => (pOptions?.trimStrings && isString( pValue )) ? String( pValue ).trim() : pValue;

    function toArrayLiteral( pObject, pOptions, pVisited, pStack, pDepth = 0 )
    {
        const { options, visited, stack, depth } = resolveObjectLiteralArguments( pOptions, pVisited, pStack, pDepth );

        let arr = isNull( pObject ) ? [] : (!isArray( pObject ) ? (isFunction( pObject.values ) ? [...(pObject.values() || [])] : [pObject]) : [...(pObject || [])]) || [];

        if ( options?.prune )
        {
            arr = ([...(arr || [])].filter( isNonNullValue ) || []).filter( e => !isEmptyString( e ) );
        }

        arr = [...(arr || [])].map( ( e, i ) => toObjectLiteral( e, options, visited, [...stack, String( i )], depth + 1 ) ) || [];

        return arr;
    }

    function arrayToObject( pArr, pOptions, pVisited, pStack, pDepth )
    {
        let object = {};

        if ( isNull( pArr ) || !isArray( pArr ) )
        {
            return object;
        }

        let depth = toInteger( pDepth );

        let arr = toArrayLiteral( pArr, pOptions, pVisited, pStack, depth + 1 ) || [];

        if ( isArray( arr ) && $ln( arr ) > 0 )
        {
            for( let i = 0, n = arr.length; i < n; i++ )
            {
                object[String( i )] = attempt( () => toObjectLiteral( arr[i], pOptions, pVisited, [...(pStack || []), String( i )], depth + 1 ) );
            }
        }

        return object;
    }

    function _handleArray( pObject, pOptions = DEFAULT_OBJECT_LITERAL_OPTIONS, pVisited = new ResolvedSet(), pStack = [], pDepth = 0 )
    {
        if ( !(isArray( pObject ) || isFunction( pObject.values )) && isNonNullValue( pObject ) )
        {
            return [pObject];
        }

        const { options, visited, stack, depth } = resolveObjectLiteralArguments( pOptions, pVisited, pStack, pDepth );

        let arr = toArrayLiteral( pObject, options, visited, stack, depth );

        visited.add( arr );

        visited.resolve( pObject, arr );

        visited.resolveForNodePath( arr, ...stack );

        return [...(arr || [])];
    }

    function toObjectLiteral( pObject,
                              pOptions = DEFAULT_OBJECT_LITERAL_OPTIONS,
                              pVisited = new ResolvedSet(),
                              pStack = [],
                              pDepth = 0 )
    {
        if ( isNull( pObject ) || !isObject( pObject ) || isPrimitiveWrapper( pObject ) || isObjectLiteral( pObject ) )
        {
            return pObject;
        }

        const { options, visited, stack, depth } = resolveObjectLiteralArguments( pOptions, pVisited, pStack, pDepth );

        let maxDepth = toInteger( options?.maxDepth );
        maxDepth = isNanOrInfinite( maxDepth ) ? 16 : clamp( toInteger( maxDepth ), 2, 32 );

        const preserveTypes = !!options?.preserveTypes;

        // noinspection JSCheckFunctionSignatures
        if ( preserveTypes && instanceOfAny( pObject, Date, RegExp, Symbol, Map, Set, Promise, ArrayBuffer, SharedArrayBuffer, DataView, WeakMap, WeakRef, WeakSet ) )
        {
            return pObject;
        }

        if ( !isNanOrInfinite( maxDepth ) && !isNanOrInfinite( depth ) && depth > maxDepth )
        {
            return pObject || {};
        }

        const keyTransformer = isFunction( options?.keyTransformer ) ? options.keyTransformer : ( pKey ) => pKey;
        const valueTransformer = isFunction( options?.valueTransformer ) ? options.valueTransformer : ( pValue ) => pValue;

        if ( depth > maxDepth || detectCycles( stack, 5, 3 ) )
        {
            return isArray( pObject ) ? [...(pObject || [])] : isFunction( pObject.entries ) ? [...(pObject.entries() || [])] : { ...(resolveObject( pObject || {} )) };
        }

        const transientProperties = resolveTransientProperties( options );

        if ( isArray( pObject ) )
        {
            return _handleArray( pObject, options, visited, stack, depth );
        }

        if ( isMap( pObject ) || isFunction( pObject.entries ) )
        {
            let obj = {};

            for( let entry of pObject.entries() )
            {
                let k = ObjectEntry.getKey( entry );

                if ( !isBlankString( k ) )
                {
                    k = keyTransformer( k );

                    let v = valueTransformer( ObjectEntry.getValue( entry ) );

                    if ( options.recursive )
                    {
                        v = toObjectLiteral( v, options, visited, [...stack, k], depth + 1 );
                    }

                    obj[k] = v;
                }
            }

            visited.add( pObject );

            visited.resolve( pObject, obj );

            visited.resolveForNodePath( obj, ...stack );

            return obj;
        }

        if ( options.respectToLiteralMethod && isFunction( pObject?.toLiteral ) )
        {
            try
            {
                let literal = pObject.toLiteral();

                if ( isNonNullObject( literal ) )
                {
                    return literal;
                }

                literal = {};

                for( let prop in pObject )
                {
                    literal[prop] = pObject[prop];
                }

                return literal;
            }
            catch( ex )
            {
                toolBocksModule.handleError( ex );
            }
        }

        const entries = ObjectEntry.unwrapValues( pObject );

        let methods = [];

        if ( !(options?.omitFunctions) && isNonNullObject( pObject ) )
        {
            methods = objectMethods( pObject );
        }

        const obj = {};

        const includeProperty = ( pKey, pValue, pOptions ) =>
        {
            return ( !pOptions?.prune || isNonNullValue( pValue )) &&
                   ( !pOptions?.omitFunctions || !isFunction( pValue ))
                   && !transientProperties.includes( _toString( pKey ).trim() )
                   && ( !options.skipPrivateProperties || !isPrivateProperty( pKey, options.privatePropertyPrefixes ));
        };

        function updateObject( pKey, pValue, pOptions )
        {
            pValue = processValue( pValue, pOptions );

            if ( includeProperty( pKey, pValue, pOptions ) )
            {
                let key = keyTransformer( pKey );
                obj[key] = valueTransformer( pValue ) || pValue;
            }
            else if ( isFunction( pValue ) )
            {
                if ( !options.skipPrivateProperties || !isPrivateMethod( pValue, options.privatePropertyPrefixes ) )
                {
                    methods.push( pValue.bind( obj ) );
                }
            }
        }

        for( const entry of entries )
        {
            let key = String( ObjectEntry.getKey( entry ) ).trim();

            if ( transientProperties.includes( key ) || isPrivateProperty( key, options.privatePropertyPrefixes ) )
            {
                continue;
            }

            const value = visited.resolveForNodePath( undefined, [...stack, key] ) || ObjectEntry.getValue( entry );

            if ( !includeProperty( key, value, options ) )
            {
                // even if we skip the property, we may want to restore the method(s)
                if ( isFunction( value ) && ( !options.skipPrivateProperties || !isPrivateMethod( value, options.privatePropertyPrefixes )) )
                {
                    methods.push( value.bind( obj ) );
                }
                continue;
            }

            if ( depth > 32 || detectCycles( stack, 5, 3 ) || visited.has( value ) )
            {
                let newValue = visited.resolve( value ) || value || ObjectEntry.getValue( entry );

                updateObject( key, newValue, options );

                continue;
            }

            if ( $ln( methods ) > 0 && !options?.omitFunctions )
            {
                methods = methods.filter( e => isFunction( e ) && ( !options.skipPrivateProperties || !isPrivateMethod( e, options.privatePropertyPrefixes )) );

                methods.forEach( method => obj[method?.name] = method.bind( obj ) );
            }

            if ( !options.recursive || (options.preserveUserDefinedClasses && isInstanceOfUserDefinedClass( value )) )
            {
                updateObject( key, value, options );
            }
            else
            {
                let newValue = toObjectLiteral( value, options, visited, [...stack, key], (depth + 1) ) || value;

                updateObject( key, newValue, options );
            }

            if ( obj[key] )
            {
                visited.resolveForNodePath( obj[key], [...stack, key] );
            }
        }

        visited.add( pObject );

        restoreMethods( pObject, obj, options );

        visited.resolve( pObject, obj );

        visited.resolveForNodePath( obj, ...stack );

        return obj;
    }

    function transformObject( pObject, pOptions = DEFAULT_TRANSFORMER_PROPERTIES )
    {
        const options = { ...DEFAULT_TRANSFORMER_PROPERTIES, ...(pOptions || {}) };

        const recursive = !!options.recursive;
        const keyTransformer = isFunction( options.keyTransformer ) ? options.keyTransformer : ( pKey ) => pKey;
        const valueTransformer = isFunction( options.valueTransformer ) ? options.valueTransformer : ( pValue ) => pValue;

        if ( isNull( pObject ) || !isObject( pObject ) )
        {
            return pObject;
        }

        let source = attempt( () => ({ ...(pObject || {}) }) );

        let obj = {};

        const entries = attempt( () => objectEntries( source ) );

        if ( $ln( entries ) && isFunction( entries.forEach ) )
        {
            entries.forEach( entry =>
                             {
                                 let key = ObjectEntry.getKey( entry );
                                 key = keyTransformer( key ) || key;

                                 let value = ObjectEntry.getValue( entry );

                                 if ( isObject( value ) && recursive && !isInstanceOfUserDefinedClass( value ) )
                                 {
                                     obj[key] = transformObject( value, options );
                                 }
                                 else
                                 {
                                     obj[key] = valueTransformer( value );
                                 }
                             } );
        }

        return obj || pObject;
    }

    let parseJson = function( pJson )
    {
        if ( isObject( pJson ) || isArray( pJson ) || isTypedArray( pJson ) )
        {
            return pJson;
        }

        let s = _toString( isString( pJson ) ? pJson.trim() : _toString( pJson ).trim() );
        s = (s.replace( /^[\r\n\t]+/, _mt_str ).replace( /[\r\n\t]+$/, _mt_str ) || _mt_str).trim();

        let canParse = (s.startsWith( "{" ) && s.endsWith( "}" )) || ((s.startsWith( "[" ) && s.endsWith( "]" )));

        canParse = canParse || (s.startsWith( _dblqt ) && s.endsWith( _dblqt )) || (s.startsWith( _sglqt ) && s.endsWith( _sglqt ));

        if ( canParse )
        {
            let obj = attempt( () => JSON.parse( s ) );

            if ( isNonNullObject( obj ) || isArray( obj ) || isTypedArray( obj ) )
            {
                return obj;
            }

            if ( isString( obj ) )
            {
                obj = String( obj ).replace( /^["'`]+/, _mt ).replace( /["'`]+$/, _mt );
                obj = attempt( () => parseJson( obj ) ) || String( obj );
            }

            if ( isNonNullObject( obj ) || isArray( obj ) || isTypedArray( obj ) || (isString( obj ) && $ln( obj ) > 0) )
            {
                return obj;
            }
        }

        return { value: s };
    };

    toolBocksModule["parseJson"] = toolBocksModule["parseJson"] || parseJson;

    function asObject( pObject )
    {
        if ( isNonNullObject( pObject ) || isArray( pObject ) || isTypedArray( pObject ) )
        {
            return pObject || {};
        }

        if ( isString( pObject ) )
        {
            return attempt( () => (toolBocksModule["parseJson"] || parseJson).call( toolBocksModule, pObject ) );
        }

        if ( isFunction( pObject ) )
        {
            if ( isClass( pObject ) )
            {
                const instance = attempt( () => new pObject() );
                if ( !isNull( instance ) )
                {
                    return asObject( instance );
                }

                return { "class": pObject };
            }

            const result = attempt( () => pObject() );

            if ( !isNull( result ) )
            {
                return asObject( result );
            }

            return { [pObject?.name]: pObject };
        }

        return {};
    }

    const DEFAULT_AS_MAP_OPTIONS =
        lock( {
                  recursive: true,
                  locked: false,
                  preserveUserDefinedClasses: true,
                  preserveTypes: false,
                  maxDepth: 5,
                  ...DEFAULT_TRANSFORMER_PROPERTIES
              } );

    function asMap( pVal, pOptions = DEFAULT_AS_MAP_OPTIONS, pVisited = new ResolvedSet(), pStack = [], pDepth = 0 )
    {
        const options = { ...DEFAULT_AS_MAP_OPTIONS, ...(pOptions || {}) };

        const recursive = !!options.recursive;
        const preserve = !!options.preserveUserDefinedClasses;
        const locked = !!options.locked;
        const maxDepth = options.maxDepth || 5;

        const visited = pVisited || new ResolvedSet();
        const stack = (pStack || []);
        const depth = toInteger( pDepth ) || 0;

        if ( visited.has( pVal ) || depth > maxDepth || detectCycles( stack, 3, 3 ) )
        {
            return pVal;
        }

        const keyTransformer = isFunction( options.keyTransformer ) ? options.keyTransformer : ( pKey ) => pKey;
        const valueTransformer = isFunction( options.valueTransformer ) ? options.valueTransformer : ( pValue ) => pValue;

        let map = new Map();

        function shouldRecurse( pValue, pRecursive = recursive )
        {
            if ( pRecursive && isNonNullObject( pValue ) )
            {
                return !preserve || !isInstanceOfUserDefinedClass( pValue );
            }
            return false;
        }

        switch ( typeof pVal )
        {
            case _ud:
                return !!locked ? lock( map ) : map;

            case _obj:
                if ( isNull( pVal ) )
                {
                    break;
                }

                if ( isArray( pVal ) )
                {
                    if ( is2dArray( pVal ) )
                    {
                        map = new Map( pVal );
                        break;
                    }

                    pVal.forEach( ( e, i ) =>
                                  {
                                      map.set( i, shouldRecurse( e, recursive ) ? asMap( e, options, visited, [...stack, i, depth + 1] ) : e );
                                  } );
                }
                else
                {
                    objectEntries( pVal ).forEach( entry =>
                                                   {
                                                       let key = ObjectEntry.getKey( entry );

                                                       let value = ObjectEntry.getValue( entry );

                                                       key = keyTransformer( key );

                                                       map.set( key, shouldRecurse( value, recursive ) ? asMap( value, options, visited, [...stack, key], depth + 1 ) : valueTransformer( value ) );
                                                   } );
                }
                break;

            case _str:
                const str = valueTransformer( pVal );

                map.set( "value", str );
                map.set( str, str );

                break;

            case _num:
            case _big:
            case _bool:
                const num = valueTransformer( pVal );
                map.set( "value", num );
                map.set( num, num );
                map.set( _toString( num ), num );
                break;

            case _fun:
                map.set( (pVal?.name || "function"), pVal );
                map.execute = function( ...pArgs )
                {
                    return isAsyncFunction( pVal ) ? asyncAttempt( async() => await pVal.call( map, ...pArgs ) ) : attempt( () => pVal.call( map, ...pArgs ) );
                };
                break;

            case _symbol:
                map.set( pVal, pVal );
                map.set( String( pVal ).toString(), pVal );
                break;

            default:
                break;
        }

        visited.resolve( pVal, map );
        visited.resolveForNodePath( map, ...stack );

        return !!locked ? lock( map ) : map;
    }

    /**
     * Applies Array.flat to each of the variable number of values
     * @param {...*} pArgs One or more values, treated as an array of arrays, each of which will be flattened
     * @returns {FlatArray<*[], 1>[]} An array of the values passed, flattening all nested arrays
     */
    function flattened( ...pArgs )
    {
        let args = (isArray( pArgs ) || isLikeArray( pArgs )) ? [...(pArgs || [])].flat( Infinity ) : [pArgs || _mt_str].filter( e => !isEmptyString( e ) );

        let arr = [];

        for( let elem of args )
        {
            arr.push( isArray( elem ) ? flattened( elem ) : elem );
        }

        return [...arr].flat();
    }

    /**
     * Returns an object literal (or Map) of key/value nodes
     * where the key is the concatenated path to the leaf node in the source object.
     *
     * @param {object} pObject the source object from which to generate the new object
     * @param {boolean} [pAsMap=false] indicates whether to return an object literal or an instance of Map
     *
     * @param pPathString
     * @param pVisited
     * @param pStack
     * @returns {object|Map<string,*>} a new object that is either an object literal or an instance of Map
     *                                 where the keys are the concatenated path to the original value in the source object
     */
    function collapse( pObject, pAsMap = false, pPathString = _mt_str, pVisited = new ResolvedSet(), pStack = [] )
    {
        let obj = pAsMap ? new Map() : {};

        const options =
            {
                rejectPrimitiveWrappers: false,
                rejectArrays: false,
                rejectNull: true,
                allowEmptyObjects: false,
                preserveArrays: true,
            };

        function setValue( pNodePathString, pValue )
        {
            if ( isMap( obj ) )
            {
                obj.set( pNodePathString, pValue );
            }
            else
            {
                obj[pNodePathString] = pValue;
            }
        }

        if ( isNonNullObject( pObject, false, options, [...(pStack || [])] ) )
        {
            const visited = pVisited || new ResolvedSet();
            const stack = [...(pStack || [])];

            let pathString = pPathString || stack.join( _dot );

            if ( visited.has( pObject ) || detectCycles( stack, 5, 5 ) )
            {
                obj = visited.resolve( pObject ) || visited.resolveForNodePath( undefined, pathString.split( _dot ) ) || pObject;
            }

            function resolveNestedPaths( pObj, pNodePathString, pVisited, pStack )
            {
                const pile = [...(pStack || stack || [])];
                const traversed = pVisited || new ResolvedSet();

                let nodePathString = String( pNodePathString ) || toNodePathArray( pile ).join( _dot );

                if ( visited.has( pObj ) || detectCycles( pile, 5, 5 ) )
                {
                    return;
                }

                objectEntries( pObj ).forEach( ( entry ) =>
                                               {
                                                   const key = entry.key;
                                                   const value = entry.value;

                                                   if ( isNonNullValue( value ) )
                                                   {
                                                       nodePathString = `${nodePathString}${_dot}${key}`;

                                                       while ( isNonNullObject( value ) )
                                                       {
                                                           resolveNestedPaths( value, nodePathString, traversed, [...pile, key] );
                                                       }

                                                       setValue( nodePathString, value );

                                                       traversed.resolveForNodePath( value, nodePathString.split( _dot ) );
                                                   }
                                               } );
            }

            let literal = toObjectLiteral( pObject );

            resolveNestedPaths( literal, pathString, visited );

            return obj;
        }
    }

    function expand( pObject )
    {

    }

    /**
     * Aligns a given number of bits to the nearest valid byte boundary.
     * Valid byte boundaries are 8, 16, 32, and 64 for all supported environments
     *
     * @param {number} pNumBits - The number of bits to align.
     * @return {number} The aligned byte size, clamped between 8 and 64.
     */
    function alignToBytes( pNumBits )
    {
        let numBits = clamp( isNumeric( pNumBits ) ? toDecimal( pNumBits || 8 ) : 8, 8, 64 );

        let necessary = (numBits > 8 ? (numBits > 16 ? (numBits > 32 ? 64 : 32) : 16) : 8);

        return clamp( necessary, 8, 64 );
    }

    /**
     * Calculates the minimum number of bits required to represent a range of values
     * between the specified minimum and maximum values.
     *
     * @param {number|string} pMinValue The minimum value of the range, can be either a number or a numeric string.
     * @param {number|string} pMaxValue The maximum value of the range, can be either a number or a numeric string.
     * @return {number} The minimum number of bits required to represent the values in the specified range,
     * including a sign bit if necessary.
     *
     * @alias module:TypeUtils.calculateBitsNeeded
     */
    function calculateBitsNeeded( pMinValue, pMaxValue )
    {
        // protect against non-numeric input
        let minValue = isNumeric( pMinValue ) ? toDecimal( pMinValue ) : isNumeric( pMaxValue ) ? toDecimal( pMaxValue ) : 0;
        let maxValue = isNumeric( pMaxValue ) ? toDecimal( pMaxValue ) : isNumeric( pMinValue ) ? toDecimal( pMinValue ) : 0;

        minValue = Math.min( minValue, maxValue );
        maxValue = Math.max( minValue, maxValue );

        //use the largest absolute value to calculate the minimum required bits
        const num = Math.max( Math.abs( minValue ), Math.abs( maxValue ) );

        // take the ceiling of the base-2 logarithm of the absolute value
        let bitsNeeded = num === 0 ? 1 : Math.ceil( Math.log2( Math.abs( num ) ) );

        // add 1 for a sign bit if either value is negative
        bitsNeeded += (minValue < 0 || maxValue < 0 ? 1 : 0);

        return bitsNeeded;
    }

    /**
     * Returns true if any of the specified values is a floating-point number.
     *
     * @param {...*} pArgs - One or more values to be evaluated
     * @return {boolean} Returns true if any of the arguments are floating-point numbers, otherwise false.
     *
     * @alias module:TypeUtils.containsFloat
     */
    function containsFloat( ...pArgs )
    {
        const arr = flattened( ...pArgs ).filter( isNumeric ).map( toDecimal );
        return arr.some( isFloat );
    }

    /**
     * Determines the appropriate typed array class (Float32Array or Float64Array)
     * to represent floating-point numbers based on the range of values.
     *
     * @param {number} pMinValue - The minimum value in the range.
     * @param {number} pMaxValue - The maximum value in the range.
     * @return {Function} The constructor function for the chosen typed array class (Float32Array or Float64Array).
     *
     * @private
     */
    function _calculateFloatTypedArrayClass( pMinValue, pMaxValue )
    {
        return Math.max( Math.abs( pMinValue ), Math.abs( pMaxValue ) ) <= 2 ** 31 ? Float32Array : Float64Array;
    }

    // noinspection OverlyComplexFunctionJS
    /**
     * Returns the appropriate TypedArray <b>class</b>
     * based on the provided array-like input.
     *
     * @param {...*} pArray A variable-length list of elements.
     *                      Elements can be primitives or arrays.
     *                      They are flattened, converted to numeric values,
     *                      and evaluated to determine the correct TypedArray class.
     *
     * @return {Function} The constructor of the appropriate TypedArray class.
     *                    The returned class will be one of the following:
     *                    Int8Array, Uint8Array, Int16Array, Uint16Array,
     *                    Int32Array, Uint32Array, Float32Array, Float64Array,
     *                    or BigUint64Array.
     *
     * @alias module:TypeUtils.calculateTypedArrayClass
     */
    function calculateTypedArrayClass( ...pArray )
    {
        const arr = [...(flattened( ...(pArray || []) ).filter( isNumeric ).map( toDecimal ))];

        const minValue = Math.min( ...(arr.map( toDecimal )) );
        const maxValue = Math.max( ...(arr.map( toDecimal )) );

        if ( containsFloat( ...(arr || []) ) )
        {
            return _calculateFloatTypedArrayClass( minValue, maxValue );
        }

        const signed = arr.some( e => e < 0 );

        let bitsNeeded = calculateBitsNeeded( minValue, maxValue );

        // Align to the appropriate type boundary (8, 16, 32, or 64)
        bitsNeeded = clamp( alignToBytes( bitsNeeded ), 8, 64 );

        switch ( bitsNeeded )
        {
            case 0:
            case 8:
                return signed ? Int8Array : Uint8Array;

            case 16:
                return signed ? Int16Array : Uint16Array;

            case 32:
                return signed ? Int32Array : Uint32Array;

            case 64:
                return signed ? BigInt64Array : BigUint64Array;

            default:
                return Int8Array;
        }
    }

    /**
     * Converts the provided array to a typed array.
     *
     * If the input is already a typed array, it is returned as-is.
     * Otherwise, it determines the appropriate typed array class based on the elements of the array,
     * and converts the input array to that typed array. If the calculated class is BigUint64Array or
     * BigInt64Array, the elements of the array are converted to BigInt using a helper function
     * `toDecimal` before creating the typed array.
     *
     * @function toTypedArray
     * @param {Array|TypedArray} pArray The input array or typed array to convert.
     * @returns {TypedArray|Uint8Array|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|BigInt64Array|BigUint64Array|Float32Array|Float64Array}
     *          A new typed array or the original typed array if already in typed array format.
     *
     * @alias module:TypeUtils.toTypedArray
     */
    const toTypedArray = function( pArray )
    {
        if ( isTypedArray( pArray ) )
        {
            return pArray;
        }

        try
        {
            let arr = [...(pArray || [])];

            const typedArrayClass = calculateTypedArrayClass( ...arr );

            if ( typedArrayClass === BigUint64Array || typedArrayClass === BigInt64Array )
            {
                arr = arr.map( e => BigInt( toDecimal( e ) ) );
            }

            return new typedArrayClass( arr );
        }
        catch( ex )
        {
            attemptSilent( () => toolBocksModule.handleError( ex, toTypedArray, pArray ) );
        }

        return pArray;
    };

    const COMPARE_OPTIONS = lock( { nullFirst: false, prioritizeNumeric: false } );

    function compareForNullOrIdentity( pA, pB, pOptions = COMPARE_OPTIONS )
    {
        if ( pA === pB )
        {
            return 0;
        }

        const options = { ...COMPARE_OPTIONS, ...(pOptions || {}) };

        const nullsFirst = !!options.nullFirst;

        return (isNull( pA )) ? isNull( pB ) ? 0 : (nullsFirst ? -1 : 1) : (isNull( pB )) ? nullsFirst ? 1 : -1 : null;
    }

    function compareNumericValues( pA, pB )
    {
        const a = toDecimal( pA );
        const b = toDecimal( pB );

        return a < b ? -1 : a > b ? 1 : 0;
    }

    function compareArrays( pA, pB, pOptions = COMPARE_OPTIONS, pVisited = new VisitedSet(), pStack = [] )
    {
        let arrA = [...(pA || [pA] || [])];
        let arrB = [...(pB || [pB] || [])];

        let comp = compare( arrA.length, arrB.length, pOptions, pVisited, pStack );

        if ( 0 === comp )
        {
            const options = { ...COMPARE_OPTIONS, ...(pOptions || {}) };

            const visited = pVisited || new VisitedSet();
            const stack = pStack || [];

            arrA = arrA.sort( ( a, b ) => compare( a, b, options, visited, stack ) );
            arrB = arrB.sort( ( a, b ) => compare( a, b, options, visited, stack ) );

            for( let i = 0; i < arrA.length; i++ )
            {
                comp = compare( arrA[i], arrB[i], options, visited, stack.concat( String( i ) ) );

                if ( 0 !== comp )
                {
                    break;
                }
            }
        }

        return comp;
    }

    function compareObjects( pA, pB, pOptions = COMPARE_OPTIONS, pVisited = new VisitedSet(), pStack = [] )
    {
        if ( !isNonNullObject( pA ) )
        {
            return isNonNullObject( pB ) ? -1 : 0;
        }
        else if ( !isNonNullObject( pB ) )
        {
            return 1;
        }

        const options = { ...COMPARE_OPTIONS, ...(pOptions || {}) };

        let entriesA = objectEntries( pA );
        let entriesB = objectEntries( pB );

        let comp = compareForNullOrIdentity( entriesA, entriesB, options );

        if ( isNull( comp ) || ![-1, 0, 1].includes( comp ) )
        {
            // compare by number of entries first
            comp = entriesA.length - entriesB.length;
            comp = comp > 0 ? 1 : (comp < 0 ? -1 : 0);

            if ( 0 === comp )
            {
                // compare keys
                comp = compareArrays( (entriesA.map( e => String( e[0] ) ).sort()), (entriesB.map( e => String( e[0] ) ).sort()), options, pVisited, pStack );

                let visited = pVisited || new VisitedSet();
                let stack = pStack || [];

                // sort entries by key before comparing values
                entriesA = entriesA.sort( ( a, b ) => compare( a[0], b[0], options, visited, stack ) );
                entriesB = entriesB.sort( ( a, b ) => compare( a[0], b[0], options, visited, stack ) );

                // compare values
                if ( 0 === comp )
                {
                    if ( visited.has( pA ) && visited.has( pB ) )
                    {
                        return 0;
                    }

                    visited.add( pA );

                    comp = compareArrays( entriesA.map( e => e[1] ), entriesB.map( e => e[1] ), options, visited, stack );
                }
            }
        }

        return comp;
    }

    function canCompareAsPrimitive( pValue )
    {
        return isPrimitive( pValue ) || isPrimitiveWrapper( pValue ) || isDate( pValue ) || isFunction( pValue ) || isRegExp( pValue ) || isNumeric( pValue );
    }

    function comparePrimitiveValues( pA, pB, pOptions = COMPARE_OPTIONS )
    {
        const options = { ...COMPARE_OPTIONS, ...(pOptions || {}) };

        let comp = 0;

        if ( options.prioritizeNumeric && isNumeric( pA ) && isNumeric( pB ) )
        {
            comp = compareNumericValues( pA, pB );
        }
        else if ( canCompareAsPrimitive( pA ) && canCompareAsPrimitive( pB ) )
        {
            comp = (toPrimitive( pA ) || pA) - (toPrimitive( pB ) || pB);
        }

        comp = comp > 0 ? 1 : (comp < 0 ? -1 : 0);

        return comp;
    }

    const compare = function( pA, pB, pOptions = COMPARE_OPTIONS, pVisited = new VisitedSet(), pStack = [] )
    {
        const options = { ...COMPARE_OPTIONS, ...(pOptions || {}) };

        let comp = compareForNullOrIdentity( pA, pB, options );

        if ( !isNull( comp ) && [-1, 0, 1].includes( comp ) )
        {
            return comp;
        }

        comp = comparePrimitiveValues( pA, pB, options );

        if ( 0 === comp )
        {
            let visited = pVisited || new VisitedSet();
            let stack = pStack || [];

            if ( detectCycles( stack, 5, 5 ) )
            {
                return 0;
            }

            if ( isArray( pA ) || isArray( pB ) )
            {
                comp = compareArrays( (isArray( pA ) ? pA : [pA]), (isArray( pB ) ? pB : [pB]), options, visited, stack );
            }
            else
            {
                comp = compareObjects( pA, pB, options, visited, stack );
            }
        }

        return comp;
    };

    // noinspection JSUnresolvedReference
    ObjectEntry.prototype.compareTo = function( pOther, pOptions = COMPARE_OPTIONS )
    {
        if ( this === pOther || OBJECT_REGISTRY.getGuid( pOther ) === (OBJECT_REGISTRY.getGuid( this )) )
        {
            return 0;
        }

        // noinspection JSUnresolvedReference
        let comp = compare( (this.key || this[0]), (pOther?.key || pOther?.[0]) );

        return 0 === comp ? compare( this, pOther, pOptions ) : comp;
    };

    ObjectEntry.prototype.equals = function( pOther )
    {
        if ( isNull( pOther ) )
        {
            return false;
        }

        if ( this === pOther || OBJECT_REGISTRY.getGuid( pOther ) === (OBJECT_REGISTRY.getGuid( this )) )
        {
            return true;
        }

        return 0 === this.compareTo( pOther );
    };

    ObjectEntry.compare = function( pA, pB, pOptions = COMPARE_OPTIONS )
    {
        const a = ObjectEntry.from( pA );
        const b = ObjectEntry.from( pB );

        return a.compareTo( b, pOptions );
    };

    /**
     * Represents a generic object with dynamic properties and proxies.
     * This class allows for flexible property management and supports dynamic property access and mutation.
     *
     * Used in the #DuplicatesDetector to prevent holding entire Entities in memory when only a few properties are necessary to identify duplicates
     */
    class GenericObject
    {
        #id;
        #properties = new Map();

        constructor( pId, pObject, ...pProperties )
        {
            this.#id = pId || pObject?.id;

            let obj = (isNonNullObject( pObject ) || isArray( pObject )) ? pObject : (isString( pObject ) ? attempt( () => parseJson( pObject ) ) : {});

            let properties = ([...(pProperties || [])] || []).filter( isString ).map( e => e.trim() ).filter( e => !isBlankString( e ) );

            let entries = objectEntries( obj );
            entries = entries.filter( entry => ($ln( properties ) <= 0) || properties.includes( ObjectEntry.getKey( entry ) ) );
            entries.forEach( entry => this.#properties.set( ObjectEntry.getKey( entry ), ObjectEntry.getValue( entry ) ) );

            return new Proxy( this,
                              {
                                  get: ( pTarget = this, pProperty, pReceiver ) =>
                                  {
                                      if ( isString( pProperty ) &&
                                           !isBlankString( pProperty ) &&
                                           pTarget.#properties.has( pProperty ) )
                                      {
                                          return pTarget.#properties.get( pProperty );
                                      }

                                      // Fall back to the original object's properties/methods
                                      return Reflect.get( pTarget, pProperty, pReceiver );
                                  },
                                  set: ( pTarget = this, pProperty, pValue, pReceiver ) =>
                                  {
                                      if ( isString( pProperty ) && !isEmptyString( String( pProperty ).trim() ) )
                                      {
                                          pTarget.#properties.set( pProperty, pValue );
                                          return true;
                                      }

                                      return Reflect.set( pTarget, pProperty, pValue, pReceiver );
                                  }
                              } );
        }

        getProperty( pProperty )
        {
            return this.#properties.get( pProperty );
        }
    }

    class ComparatorFactory
    {
        #options;

        constructor( pCompareOptions = COMPARE_OPTIONS )
        {
            this.#options = lock( { ...COMPARE_OPTIONS, ...(pCompareOptions || {}) } );
        }

        comparator()
        {
            return ( a, b ) => compare( a, b, this.#options );
        }

        nullsFirstComparator()
        {
            return ( a, b ) => compare( a, b, { ...this.#options, nullFirst: true } );
        }

        numericComparator()
        {
            return ( a, b ) => compare( a, b, { ...this.#options, prioritizeNumeric: true } );
        }

        reverseComparator()
        {
            return ( a, b ) => -(compare( a, b, this.#options ));
        }

        areEqual( pA, pB )
        {
            return pA === pB || (0 === compare( pA, pB, this.#options ));
        }
    }

    function invertBits( pBitString )
    {
        let bitString = resolveBitString( pBitString );

        const arr = new Array( bitString.length );

        for( let i = 0, n = bitString.length; i < n; i++ )
        {
            arr[i] = _zero === bitString[i] ? "1" : _zero;
        }

        return arr.join( _mt_str );
    }

    function resolveBitString( pBitString )
    {
        switch ( typeof pBitString )
        {
            case _str:
                // the expected case, a string of zeroes and ones
                let bitString = pBitString.trim();
                if ( /^[01]+$/.test( bitString ) )
                {
                    return bitString.trim().replaceAll( /[^01]/g, _mt_str );
                }

                // TODO: other cases...

                break;

            case _num:
            case _big:
                return toBits( pBitString );

            case _obj:
                if ( isArray( pBitString ) || isTypedArray( pBitString ) )
                {
                    const arr = [...pBitString];

                    if ( arr.every( e => [0, 1].includes( toDecimal( e ) ) ) )
                    {
                        return arr.join( _mt_str );
                    }

                    // TODO: other cases, byte arrays, string arrays to be encoded...
                }

                if ( isArrayBuffer( pBitString ) || isSharedArrayBuffer( pBitString ) || isDataView( pBitString ) )
                {
                    // TODO: is 8 the correct size?
                    return resolveBitString( new Uint8Array( pBitString ) );
                }

                break;
        }

        toolBocksModule.handleError( new Error( `Unable to resolve bit string: ${pBitString}` ), resolveBitString, pBitString );

        return _mt_str;
    }

    function addOneToBitString( pBitString )
    {
        let bitString = resolveBitString( pBitString );

        const bits = bitString.split( _mt_str );

        // add one
        let carry = 1;

        // Iterate from LSB to MSB
        for( let i = bits.length; ((i--) > 0) && (carry > 0); )
        {
            const bit = bits[i];

            if ( _zero === bit )
            {
                bits[i] = "1";
                carry = 0;
            }
            else
            {
                bits[i] = _zero;
            }
        }

        return bits.join( _mt_str );
    }

    /**
     * Computes the two's complement of a given binary string.<br>
     * <br>
     *
     * The input should be a binary string composed of '0's and '1's only.<br>
     * The function assumes that the input binary string is valid
     * and does not perform any additional validation.<br>
     *
     * The two's complement of a binary number
     * is calculated by inverting all the bits (0s become 1s, and 1s become 0s)
     * and then adding 1 to the result.
     *
     * @param {string} pBitString - A binary string for which the two's complement is to be calculated.
     * @returns {string} The two's complement of the input binary string as another binary string.
     */
    const twosComplement = function( pBitString )
    {
        let bitString = resolveBitString( pBitString );

        bitString = invertBits( bitString );

        return addOneToBitString( bitString );
    };

    const intToBits = function( pValue, pLength = 8 )
    {
        const num = isNumeric( pValue ) ? toDecimal( pValue ) : 0;

        const length = alignToBytes( Math.max( pLength, calculateBitsNeeded( num, num ) ) );

        if ( length > 64 )
        {
            throw new Error( `Cannot convert ${num} to bits. The value requires more than 64 bits.` );
        }

        const negative = num < 0;

        let abs = Math.abs( num );

        // initialize the bit string with the sign-bit
        let bitString = _mt_str;

        // we iterate from length-1 in order to reserve the sign-bit for a possible negative value
        for( let i = (length - 1); abs >= 0 && i >= 0; i-- )
        {
            const place = 2 ** i;

            if ( abs >= place )
            {
                bitString += "1";
                abs -= place;
            }
            else
            {
                bitString += "0";
            }
        }

        // bitString = bitString.padStart( length, "0" );

        if ( negative )
        {
            bitString = twosComplement( bitString );
        }

        return bitString;
    };

    const floatToBits = function( pValue )
    {
        throw new Error( "Not implemented" );
    };

    const toBits = function( pValue, pLength )
    {
        const num = isNumeric( pValue ) ? toDecimal( pValue ) : 0;

        if ( 0 === num || isInteger( num ) )
        {
            return intToBits( num, pLength );
        }

        if ( isFloat( num ) )
        {
            return floatToBits( num, pLength );
        }

        if ( isString( num ) )
        {
            if ( isNumeric( num ) )
            {
                return toBits( toDecimal( pValue ), pLength );
            }

            throw new IllegalArgumentError( `Cannot convert ${num} to bits. The value is not a number.` );
        }

        return String( parseInt( toDecimal( num ), 2 ) ).replace( /^0b/, _mt_str );
    };

    const uuidToNumber = function( pUUID )
    {
        if ( isUUID( pUUID ) )
        {
            let uuid = _toString( pUUID ).replaceAll( /[^0-9A-Fa-f]/gi, _mt );
            return BigInt( `0x${uuid}` );
        }

        return 0;
    };

    /**
     * Converts a UUID or GUID value to a numeric value that will fit into 32 bits.
     * THIS FUNCTION CANNOT GUARANTEE THAT 2 DIFFERENT UUID VALUES WILL PRODUCE DIFFERENT NUMERIC VALUES
     * USE THIS FOR ONLY VERY SPECIFIC USE CASES
     *
     * @param pUUID a globally unique identifier
     * @returns {number} a number >=0 and <= Number.MAX_SAFE_INTEGER
     */
    const uuidTo32BitInteger = function( pUUID )
    {
        if ( isUUID( pUUID ) )
        {
            let uuid = _toString( pUUID ).replaceAll( /[^0-9A-Fa-f]/gi, _mt );

            let safeNum = 0;

            let shifts = [2, 5, 7, 5, 3, 5, 7, 9];

            shifts = Array.from( { length: $ln( uuid ) }, ( v, i ) => shifts[(i % 7)] );

            for( let i = 0, n = $ln( uuid ); i < n; i++ )
            {
                safeNum = ((safeNum << (shifts.shift())) - safeNum) + uuid.charCodeAt( i );
                safeNum |= 0; // convert to 32-bit integer
            }

            return Math.abs( safeNum );
        }

        return 0;
    };

    const uuidToSafeInteger = function( pUUID )
    {
        if ( isUUID( pUUID ) )
        {
            let uuid = _toString( pUUID ).replaceAll( /[^0-9A-Fa-f]/gi, _mt );

            let lowBits = 0;
            let highBits = 0;

            const primeFactor = 31;

            const MODULUS_26 = 2 ** 26;
            const SHIFT_26 = MODULUS_26;

            for( let i = 0; i < uuid.length; i++ )
            {
                const charCode = uuid.charCodeAt( i );

                // update the lowBits using the standard DJB2-style multiplication
                lowBits = (lowBits * primeFactor) + charCode;
                lowBits %= MODULUS_26;

                // update the highBits using a different seed (shifted charCode)
                // to ensure the two resulting chunks are independent.
                highBits = (highBits * primeFactor) + (charCode << 1);
                highBits %= MODULUS_26;
            }

            // combine the two 26-bit integers into a single 52-bit integer.
            // by multiplying the high bits by 2^26 and adding the low bits.
            return (highBits * SHIFT_26) + lowBits;
        }

        return 0;
    };

    // returns true if val is of the type (or one of the types) specified
    const $is = ( val, type ) => (null !== val) && ((_str === typeof type) ? (type === typeof val) : (isArray( type ) ? [...(type || [])].includes( typeof val ) : (_fun === typeof type && val instanceof type)));

    const $isFun = ( val ) => $is( val, _fun )
        , $isStr = ( val ) => $is( val, _str )
        , $isNum = ( val ) => $is( val, _num )
        , $isObj = ( val ) => $is( val, _obj );

    const EXCLUDED_METHODS = ["constructor", "length", "name", "arguments", "caller", "equals", "compareTo", "isValid"];

    function getMethods( pClass )
    {
        if ( _ud === typeof pClass || isNull( pClass ) || $scope() === pClass )
        {
            return [];
        }

        let target = isNonNullObject( pClass ) ? (pClass.prototype || Object.getPrototypeOf( pClass )) : isClass( pClass ) ? pClass : {};

        let entries = objectEntries( target );

        let methods = [];

        if ( $ln( entries ) <= 0 )
        {
            for( let prop in (target || pClass || {}) )
            {
                let value = target[prop] || pClass?.[prop] || Object.getPrototypeOf( pClass )?.[prop];

                if ( isFunction( value ) )
                {
                    value.name = value.name || toString( prop, true );
                    methods.push( value );
                }
            }
        }
        else
        {
            entries.forEach( entry =>
                             {
                                 let key = ObjectEntry.getKey( entry );
                                 let value = ObjectEntry.getValue( entry );

                                 if ( isFunction( value ) && !(EXCLUDED_METHODS.includes( key )) )
                                 {
                                     attempt( () => value.name = value.name || key );
                                     methods.push( value );
                                 }
                             } );
        }

        if ( $ln( methods ) <= 0 )
        {
            const prototypes = [pClass?.prototype, Object.getPrototypeOf( pClass || {} ), target?.prototype, Object.getPrototypeOf( target || {} )].filter( e => !isNull( e ) );

            for( let proto of prototypes )
            {
                let p = proto;

                let iterationCap = new IterationCap( 10 );

                while ( !isNull( p ) && !iterationCap.reached )
                {
                    for( let prop in p )
                    {
                        if ( prop )
                        {
                            let value = p[prop] || attemptSilent( () => Object.getPrototypeOf( p )?.[prop] );

                            if ( isFunction( value ) )
                            {
                                attempt( () => value.name = value.name || prop );
                                methods.push( value );
                            }
                        }
                    }

                    p = p?.prototype || (_ud !== typeof p && !isNull( p )) ? Object.getPrototypeOf( p ) : null;
                }
            }
        }

        return methods;
    }

    /**
     * Returns true if the specified object implements all the specified methods
     * @param pObject
     * @param pMethods
     */
    function implementsMethods( pObject, ...pMethods )
    {
        if ( isNull( pObject ) || !isObject( pObject ) || $scope() === pObject )
        {
            return false;
        }

        let methods = [...(pMethods || [])].filter( e => isString( e ) || isFunction( e ) );

        if ( isArray( pObject ) )
        {
            return [...(pObject || [])].every( e => implementsMethods( e, ...methods ) );
        }

        let methodNames = methods.map( e => isString( e ) ? e.trim() : isFunction( e ) ? e?.name : _mt );

        if ( methodNames.every( name => isFunction( pObject[name] ) ) )
        {
            methods = methods.filter( e => isFunction( e ) );

            return methods.every( func => (_mt === func?.name) || (pObject[func.name]?.length === func.length) );
        }

        return false;
    }

    function isSubclassOf( pChild, pParent )
    {
        if ( (isNull( pChild ) || !(isClass( pChild ) || isObject( pChild ))) || (isNull( pParent ) || !(isClass( pParent ) || isObject( pParent ))) )
        {
            return false;
        }

        let child = isClass( pChild ) ? pChild : getClass( pChild );
        let parent = isClass( pParent ) ? pParent : getClass( pParent );

        if ( child === parent )
        {
            return true;
        }

        let parentPrototype = parent?.prototype;
        let childPrototype = child?.prototype;

        if ( null === parentPrototype || parentPrototype === Object || parentPrototype === Array )
        {
            return null === childPrototype || (childPrototype === Object && parentPrototype === Object) || (childPrototype === Array && parentPrototype === Array);
        }
        else if ( null === childPrototype )
        {
            return false;
        }

        return parentPrototype.isPrototypeOf( childPrototype );
    }

    /**
     * Returns true if the specified object is either an instance of the specified class
     * or if it has all the methods defined by the class
     * @param pObject
     * @param pClass
     */
    function implementsInterface( pObject, pClass )
    {
        if ( (isNull( pObject ) || !isObject( pObject )) || (isNull( pClass ) || !(isClass( pClass ) || isObject( pClass ))) )
        {
            return false;
        }

        if ( [pObject, pClass].includes( $scope() ) )
        {
            return false;
        }

        if ( isArray( pClass ) )
        {
            let klasses = [...(pClass || [])].filter( e => isClass( e ) || isNonNullObject( e ) );

            return klasses.every( kls => implementsInterface( pObject, kls ) );
        }

        let klass = isClass( pClass ) ? pClass : getClass( pClass ) || pClass;

        if ( !isClass( klass ) )
        {
            if ( isNonNullObject( klass ) )
            {
                let methods = attempt( () => getMethods( klass || pClass ) ) || attempt( () => getMethods( pClass || klass ) );
                return implementsMethods( pObject, ...methods );
            }

            return false;
        }

        if ( isArray( pObject ) )
        {
            return [...(pObject || [])].every( e => implementsInterface( e, klass ) );
        }

        if ( pObject instanceof klass )
        {
            return true;
        }

        const prototype = klass.prototype || pClass.prototype || Object.getPrototypeOf( klass ) || Object.getPrototypeOf( pClass );

        if ( isNull( prototype ) )
        {
            return false;
        }

        const methods = attempt( () => getMethods( prototype ) ) || [];

        return implementsMethods( pObject, ...methods );
    }

    const NON_DELEGATED_PROPERTIES = ["class", "length", "prototype", "__proto__", "constructor"];

    /**
     * Adds read-only properties to an object, the target (`pTarget`),
     * that delegate to a source object, the delegate ('pDelegate') to return a value.
     *
     * If the target already defines a property with the same name, preserves that property.
     *
     * If the delegated property is a function,
     * the returned function is bound to the delegate
     * to preserve 'this' semantics within the function.
     *
     * @param {Object} pTarget - The target object to which to add properties and methods
     * @param {Object} pDelegate - The source object to which to delegate
     *                             when these properties are accessed or methods invoked.
     *
     * @param {Array<string>} [pOmitted=NON_DELEGATED_PROPERTIES] a list of properties and/or methods that should not be delegated
     *
     * @returns {boolean} - Returns true if any properties ere successfully delegated, false otherwise
     */
    const delegateTo = ( pTarget, pDelegate, pOmitted = [...NON_DELEGATED_PROPERTIES] ) =>
    {
        let delegated = false;

        if ( isNull( pTarget ) || !isObject( pTarget ) || ($scope() === pTarget) )
        {
            attemptSilent( () => (ToolBocksModule.resolveLogger( toolBocksModule?.logger, console ) || console).log( `Invalid Target. Target is ${($scope() === pTarget) ? "the global scope" : (isNull( pTarget ) ? "null" : "not an object")} at delegateTo, line 5963` ) );
            return false;
        }

        const target = asObject( pTarget );

        if ( isNull( pDelegate ) || ( !(isNonNullObject( pDelegate ) || isFunction( pDelegate ))) )
        {
            attemptSilent( () => (ToolBocksModule.resolveLogger( toolBocksModule?.logger, console ) || console).log( `${pDelegate} is null or not an object or function at delegateTo, line 5971` ) );
            return false;
        }

        let delegate = isFunction( pDelegate ) || isClass( pDelegate ) ? ((pDelegate?.prototype || Object.getPrototypeOf( pDelegate )) || pDelegate) : asObject( pDelegate );

        if ( isNull( delegate ) || !(isObject( delegate ) || isFunction( delegate )) || ($scope() === delegate) )
        {
            if ( $scope() === delegate )
            {
                attemptSilent( () => (ToolBocksModule.resolveLogger( toolBocksModule?.logger, console ) || console).log( `Cannot delegate to the global scope` ) );
            }
            return delegated;
        }

        if ( !isObject( delegate ) )
        {
            if ( isFunction( delegate ) )
            {
                if ( isClass( delegate ) )
                {
                    const instance = attemptSilent( () => new delegate() );
                    if ( isNonNullObject( instance ) )
                    {
                        return attempt( () => delegateTo( target, instance ) );
                    }
                }

                let name = _toString( delegate?.name || _mt );
                if ( (isString( name ) && _mt !== name.trim()) )
                {
                    attempt( () => target[name] = isFunction( target[name] ) ? target[name].bind( target ) : isAsyncFunction( delegate ) ? (async function( ...pArgs ) { return await asyncAttempt( async() => await delegate( ...pArgs ) ); }).bind( target ) : (function( ...pArgs ) { return attempt( () => delegate( ...pArgs ) ); }).bind( target ) );
                    delegated = isFunction( target[name] );
                }
            }

            return delegated;
        }

        let propertiesDelegated = [];

        let omitted = [...(NON_DELEGATED_PROPERTIES || []), ...(pOmitted || [])];

        let entries = attempt( () => objectEntries( delegate || {} ) );

        if ( entries && $ln( entries ) > 0 && isFunction( entries.forEach ) )
        {
            entries.forEach( entry =>
                             {
                                 if ( !isNull( entry ) )
                                 {
                                     const key = _toString( ObjectEntry.getKey( entry ) || _mt );

                                     // Skip if the property already exists (e.g., from parent class)
                                     // or is a property included in the omitted list
                                     if ( (_mt !== key) && !omitted.includes( key ) && !(key in target) )
                                     {
                                         try
                                         {
                                             Object.defineProperty( target,
                                                                    key,
                                                                    {
                                                                        configurable: false,
                                                                        enumerable: true,
                                                                        get: function()
                                                                        {
                                                                            const value = delegate[key];

                                                                            if ( isFunction( value ) )
                                                                            {
                                                                                return ( ...pArgs ) => value.bind( delegate ).call( delegate, ...pArgs );
                                                                            }

                                                                            return value;
                                                                        }
                                                                    } );

                                             propertiesDelegated.push( key );

                                             delegated = true;
                                         }
                                         catch( ex )
                                         {
                                             attemptSilent( () => toolBocksModule.handleError( ex, delegateTo, target, delegate, key ) );
                                         }
                                     }
                                 }
                             } );
        }

        let methods = attempt( () => getMethods( delegate ) );

        if ( $ln( methods ) > 0 )
        {
            methods = [...(methods || [])].filter( isFunction );

            for( const method of methods )
            {
                let methodName = method?.name;

                // cannot delegate to anonymous functions
                if ( _mt === _toString( methodName ).trim() || "anonymous" === _toString( methodName ).trim() )
                {
                    continue;
                }

                if ( !(omitted.includes( methodName )) &&
                     !(propertiesDelegated.includes( methodName ) &&
                     !hasProperty( target, methodName )) )
                {
                    let delegateMethod = (delegate[methodName] || method).bind( delegate );

                    if ( isAsyncFunction( target[methodName] ) || isAsyncFunction( delegateMethod ) )
                    {
                        const originalMethod = isFunction( target[methodName] ) ? target[methodName].bind( target ) : function() {}.bind( target );

                        // noinspection UnnecessaryLocalVariableJS
                        const newMethod = async function( ...pArgs )
                        {
                            let originalReturnValue = await asyncAttempt( async() => await originalMethod( ...pArgs ) );

                            let delegateReturnValue = await asyncAttempt( async() => await delegateMethod( ...pArgs ) );

                            return await delegateReturnValue || await originalReturnValue;
                        };

                        target[methodName] = newMethod.bind( target );
                    }
                    else if ( isFunction( target[methodName] ) )
                    {
                        const originalMethod = target[methodName].bind( target );

                        // noinspection UnnecessaryLocalVariableJS
                        const newMethod = function( ...pArgs )
                        {
                            let originalReturnValue = attempt( () => originalMethod( ...pArgs ) );

                            let delegateReturnValue = attempt( () => delegateMethod( ...pArgs ) );

                            return delegateReturnValue || originalReturnValue;
                        };

                        target[methodName] = newMethod.bind( target );
                    }
                    else
                    {
                        target[methodName] = function( ...pArgs )
                        {
                            (delegateMethod || method)( ...pArgs );
                        }.bind( target );
                    }

                    if ( isFunction( target[methodName] ) )
                    {
                        propertiesDelegated.push( methodName );
                        delegated = true;
                    }
                }
            }
        }

        return delegated;
    };

    const CONSTANTS =
        {
            DEFAULT_IS_OBJECT_OPTIONS,
            IS_NON_NULL_OBJECT_OPTIONS,

            DEFAULT_IS_POPULATED_OPTIONS,
            LAX_POPULATED_OPTIONS,
            STRICT_POPULATED_OPTIONS,
            IS_POPULATED_ARRAY_OPTIONS,

            DEFAULT_CAST_OPTIONS,

            DEFAULT_TRANSFORMER_PROPERTIES,
            DEFAULT_OBJECT_LITERAL_OPTIONS,
            FAST_OBJECT_LITERAL_OPTIONS,

            DEFAULT_AS_MAP_OPTIONS,

            COMPARE_OPTIONS,

            JS_TYPES,
            VALID_TYPES,
            TYPE_DEFAULTS,
            TYPE_SORT_ORDER,
            BYTES_PER_TYPE,

            VOID_OK: VOID.OK,
            VOID_ERROR: VOID.ERROR
        };

    /**
     * This is the module itself, exported from this function
     */
    let mod =
        {
            dependencies,

            JS_TYPES,
            VALID_TYPES,
            TYPE_DEFAULTS,
            TYPE_SORT_ORDER,
            BYTES_PER_TYPE,

            CONSTANTS,

            DEFAULT_OBJECT_LITERAL_OPTIONS,
            FAST_OBJECT_LITERAL_OPTIONS,

            flattened,

            TYPES_CHECKS,
            isUndefined,
            isDefined,
            isNull,
            isNotNull,
            isNonNullValue,
            isPrimitive,
            isPrimitiveWrapper,
            isObject,
            isCustomObject,
            isNonNullObject,
            isWeakRef,
            isNullOrNaN,
            isValidObject,
            isPopulated,
            isPopulatedObject,
            isPopulatedArray,
            isError,
            isEvent,
            isScalar,
            asScalar,
            firstError,
            isFunction,
            isAsyncFunction,
            isGeneratorFunction,
            isPrivateMethod,
            isPromise,
            isThenable,
            isString,
            isEmptyString,
            isNumber,
            isCloneable,
            isInteger,
            toInteger,
            isFloat,
            containsFloat,
            toFloat,
            isBigInt,
            isNumeric,
            isZero,
            isBinary,
            isOctal,
            isHex,
            isDecimal,
            isScientificNotation,
            isNanOrInfinite,
            isBoolean,
            isArray,
            isTypedArray,
            is2dArray,
            isKeyValueArray,
            isIterable,
            isAsyncIterable,
            isLikeArray,
            isSpreadable,
            isMap,
            isWeakMap,
            isSet,
            isWeakSet,
            isDate,
            isDateString,
            isRegExp,
            isClass,
            isUserDefinedClass,
            isListedClass,
            isInstanceOfUserDefinedClass,
            isInstanceOfListedClass,
            isAssignableTo,
            isSymbol,
            isType,
            isUUID,
            isGUID: isUUID,
            isUrl,
            isValidDateOrNumeric,
            isValidDateInstance,
            isDirectoryEntry,
            isArrayBuffer,
            isSharedArrayBuffer,
            isDataView,

            $is,
            $isObj,
            $isFun,
            $isNum,
            $isStr,

            toDecimal,
            toHex,
            toOctal,
            toBinary,
            toBits,
            intToBits,
            floatToBits,
            invertBits,

            resolveBitString,
            resolveVisitor,
            resolveError,
            resolveEvent,
            resolveObject,
            resolveLogLevel,
            resolveMethod,
            resolveMoment,

            canBind,
            twosComplement,

            clamp,

            areSameType,
            areCompatibleTypes,

            instanceOfAny,
            getClass,
            getClassName,
            resolveClass,
            defaultFor,
            castTo,
            toIterable,
            parseDate,

            firstMatchingType,
            firstValidObject,
            firstPopulatedObject,

            estimateBytesForType,

            NVL,
            isReadOnly,
            calculateBitsNeeded,
            alignToBytes,
            calculateTypedArrayClass,
            toTypedArray,
            arrayToObject,
            isObjectLiteral,
            toArrayLiteral,
            toObjectLiteral,
            asObject,
            asMap,
            transformObject,

            hasProperty,
            getProperty,
            setProperty,

            toNodePathArray,
            collapse,

            errorToString,
            propertyDescriptors,

            uuidToNumber,
            uuidTo32BitInteger,
            uuidToSafeInteger,
            toUUID,

            getMethods,
            implementsMethods,
            implementsInterface,
            isSubclassOf,
            delegateTo,

            /**
             * The classes exported with this module.<br>
             * <br>
             * Classes:<br>
             * <ul>
             * <li><i></i>: </li>
             * </ul>
             * @alias module:TypeUtils#classes
             */
            classes:
                {
                    GenericObject,
                    ComparatorFactory,
                    Finder,
                    VisitedSet,
                    ResolvedSet,
                    Option,
                    TypedOption,
                    StringOption,
                    NumericOption,
                    BooleanOption,
                    Result,
                    VoidResult
                },
            GenericObject,
            ComparatorFactory,
            Finder,
            VisitedSet,
            ResolvedSet,
            Option,
            TypedOption,
            StringOption,
            NumericOption,
            BooleanOption,
            Result,
            VoidResult
        };

    mod = toolBocksModule.extend( mod );

    return mod.expose( mod, INTERNAL_NAME, (_ud !== typeof module ? module : mod) ) || mod;

}());
