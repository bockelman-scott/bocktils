// noinspection JSPrimitiveTypeWrapperUsage

/**
 * Defines several useful functions for detecting the type of a variable or object.
 * DEPENDS ON Constants.cjs
 */

/** import the Constants.cjs we depend upon, using require for maximum compatibility with Node versions */
const constants = require( "./Constants.cjs" );

/**
 * Defines a string to represent the type, undefined
 */
const { _ud = "undefined" } = constants;

/**
 * This function returns the host environment scope (Browser window, Node.js global, or Worker self)
 */
const $scope = constants?.$scope || function()
{
    return (_ud === typeof self ? ((_ud === typeof global) ? ((_ud === typeof globalThis ? {} : globalThis)) : (global || {})) : (self || {}));
};

(function exposeModule()
{
    /**
     * Define a string key which is unlikely to collide with other libraries or properties.
     * We use this to store the module generated by this function in global scope.
     * We can avoid re-executing the rest of this function if the module is already defined.
     */
    const INTERNAL_NAME = "__BOCK__TYPE_UTILS__";

    /**
     * Checks to see if this module is already defines and available in the global scope
     * Returns the existing module instead of recreating it, if it is already present.
     */
    if ( $scope() && (null != $scope()[INTERNAL_NAME]) )
    {
        return $scope()[INTERNAL_NAME];
    }

    /**
     * An array of this module's dependencies
     * which are re-exported with this module,
     * so if you want to, you can just import the leaf module
     * and then use the other utilities as properties of that module
     */
    const dependencies =
        {
            constants
        };

    const
        {
            _mt_str,
            _dot,
            _str,
            _fun,
            _num,
            _big,
            _bool,
            _obj,
            _symbol,
            _minus,
            DIGITS,
            DIGITS_MAP,
            HEX_DIGITS,
            HEX_DIGITS_MAP,
            OCT_DIGITS,
            OCT_DIGITS_MAP,
            BIN_DIGITS,
            BIN_DIGITS_MAP,
            S_ERROR,
            S_WARN,
            S_ERR_PREFIX,
            TYPED_ARRAYS,
            ERROR_TYPES,
            PRIMITIVE_WRAPPER_TYPES,
            GLOBAL_TYPES,
            BUILTIN_TYPES,
            BUILTIN_TYPE_NAMES,
            SERIALIZABLE_TYPES,
            AsyncFunction,
            IllegalArgumentError,
            populateOptions,
            no_op,
            lock,
            classes
        } = constants;

    const { ModulePrototype } = classes;

    const modName = "TypeUtils";

    let modulePrototype = new ModulePrototype( modName, INTERNAL_NAME );

    /**
     * This is an array of the 'valid' JavaScript primitive types.
     * Note that 'undefined' is not considered to be a 'valid' type
     * @type {Readonly<(string)[]>}
     */
    const VALID_TYPES = lock( [_str, _num, _big, _symbol, _bool, _obj, _fun] );

    /**
     * This is an array of all JavaScript primitive types.
     * This includes all the 'valid' types AND 'undefined'
     * @type {Readonly<(string)[]>}
     */
    const JS_TYPES = lock( [_ud].concat( VALID_TYPES ) );

    /**
     * This object is a dictionary of the default values for each primitive type
     * @type {Readonly<{}>}
     */
    const TYPE_DEFAULTS = lock(
        {
            [_str]: _mt_str,
            [_big]: 0n,
            [_num]: 0,
            [_bool]: false,
            [_fun]: null,
            [_obj]: null,
            [_symbol]: null,
            [_ud]: undefined
        } );

    /**
     * This oddly named function, so as not to collide with 'isArray',
     * is used to polyfill Array for ancient browsers or non-spec execution environments
     * @param pArg a value to evaluate
     * @returns {boolean} true if the specified argument is an Array
     * @private
     */
    function doesBeArray( pArg )
    {
        return !(_ud === typeof pArg || null == pArg) && "[object Array]" === {}.toString.call( pArg );
    }

    // poly-fill for isArray; probably obsolete with modern environments
    if ( _fun !== typeof Array.isArray )
    {
        try
        {
            Array.isArray = doesBeArray;
        }
        catch( ex )
        {
            modulePrototype.reportError( ex, "extending the built-in Array class", S_WARN, modName + "::Array::isArray" );
        }
    }

    /**
     * Returns true if the specified value is undefined
     * @param pObject a value to evaluate
     * @returns {boolean} true if the specified value is undefined
     */
    const isUndefined = function( pObject )
    {
        return (_ud === typeof pObject || undefined === pObject);
    };

    /**
     * Returns true if the specified value IS defined.
     * This is just an inversion of isUndefined
     * @param pObject a value to evaluate
     * @returns {boolean} true if the specified value is defined
     * @see isUndefined
     */
    const isDefined = function( pObject )
    {
        return !isUndefined( pObject );
    };

    const isEmptyString = function( pObject )
    {
        return _str === typeof (pObject) && (_mt_str === pObject || _str.length === 0);
    };

    /**
     * Returns true if the specified value is null (or, when not strict, undefined or an empty string)
     * The default is non-strict and will return true for any value that is null, undefined, or an empty string.
     * @param pObject {any} a value to evaluate
     * @param pStrict {boolean} specify true to treat any value that is not identical to null as not-null
     * @returns {boolean} if the specified value is null (or, when not strict, undefined or an empty string)
     */
    const isNull = function( pObject, pStrict = false )
    {
        return pStrict ? (null === pObject) : (isUndefined( pObject ) || null == pObject || isEmptyString( pObject ));
    };

    /**
     * Returns true if the specified value is NOT null (or, when not strict, NOT undefined and NOT an empty string)
     * The default is non-strict and will return false for any value that is null, undefined, or an empty string.
     * This is just an inversion of isNull
     * @param pObject {any} a value to evaluate
     * @param pStrict {boolean} specify true to treat any value that is not identical to null as not-null
     * @returns {boolean} if the specified value is NOT null (or, when not strict, NOT undefined or an empty string)
     * @see isNull
     */
    const isNotNull = function( pObject, pStrict = false )
    {
        return !isNull( pObject, pStrict );
    };

    /**
     * Returns true if the specified value is a Function.
     * Or, if invoked with false as the second argument, if the specified value is callable (via call() or apply())
     * @param pObj {any} a value to evaluate
     * @param pStrict {boolean} specify false to return true for objects that define call and apply methods
     * @returns {boolean} true if the specified value is a Function (or when not invoked with strict, any object defining both a call and apply method)
     */
    const isFunction = function( pObj, pStrict = true )
    {
        return !isNull( pObj ) && (_fun === typeof pObj || ( !pStrict && (_fun === typeof pObj.call) && (_fun === typeof pObj.apply)));
    };

    /**
     * Returns true if the specified value is an asynchronous Function
     * @param pObject {any} a value to evaluate
     * @returns {boolean} true if the specified value is an asynchronous Function
     */
    const isAsyncFunction = function( pObject )
    {
        return isFunction( pObject, true ) && (pObject.constructor === AsyncFunction || pObject === AsyncFunction);
    };

    /**
     * Returns true if the specified value is a function that creates a generator
     * @param pObject a value to evaluate
     * @returns {boolean} true if the specified value is a function that creates a generator
     */
    function isGeneratorFunction( pObject )
    {
        return (isFunction( pObject ) && "[object Generator]" === {}.toString.call( pObject.prototype, pObject.prototype ));
    }

    /**
     * This object defines the default options for the isObject function.
     * - rejectPrimitiveWrappers {boolean} when true,
     *   objects that are instances of String, Number, or Boolean,
     *   are not consider objects (default: true)
     *
     * - rejectArrays {boolean} when true, arrays are not considered to be 'objects', (default: false)
     *
     * - rejectNull {boolean} when true, null, is not considered an 'object' (default: false)
     * @type {{rejectArrays: boolean, rejectPrimitiveWrappers: boolean, rejectNull: boolean}}
     */
    const DEFAULT_IS_OBJECT_OPTIONS =
        {
            rejectPrimitiveWrappers: true,
            rejectArrays: false,
            rejectNull: false
        };

    /**
     * Returns true if the specified value is an instance of String, Number, or Boolean
     * @param pObj a value to evaluate
     * @returns {boolean} true if the specified value is an instance of String, Number, or Boolean
     */
    function isPrimitiveWrapper( pObj )
    {
        return !isNull( pObj ) && ([].concat( PRIMITIVE_WRAPPER_TYPES )).filter( e => pObj instanceof e ).length > 0; // (pObj instanceof String || pObj instanceof Number || pObj instanceof Boolean || pObj instanceof BigInt);
    }

    /**
     * Returns true if the specified value is an object.
     * Use the options to clarify how to treat primitive wrappers, arrays, and nulls
     * @see DEFAULT_IS_OBJECT_OPTIONS
     * @see isPrimitiveWrapper
     * @param pObj {any} a value to evaluate
     * @param pOptions {Object} an object specifying how to handle arrays, null values, or primitive wrappers
     * @returns {boolean} true if the specified value is an object
     */
    const isObject = function( pObj, pOptions = DEFAULT_IS_OBJECT_OPTIONS )
    {
        if ( (_obj === typeof pObj) || pObj instanceof Object )
        {
            const options = populateOptions( pOptions, DEFAULT_IS_OBJECT_OPTIONS );

            if ( options.rejectNull && isNull( pObj ) )
            {
                return false;
            }

            if ( options.rejectPrimitiveWrappers && isPrimitiveWrapper( pObj ) )
            {
                return false;
            }

            return !(options.rejectArrays && doesBeArray( pObj ));
        }
        return false;
    };

    /**
     * Returns true if the specified value is an object that does not derive from the JavaScript Object type
     * @param pObj {any} a value to evaluate
     * @returns {boolean} true if the specified value is an object that does not derive from the JavaScript Object type
     */
    const isCustomObject = function( pObj )
    {
        return isObject( pObj ) && pObj.prototype !== null && pObj.prototype !== Object && (pObj.constructor === null || pObj.constructor !== Object);
    };

    /**
     * Returns true if the specified value is a string or a String
     * @param pObj {any} a value to evaluate
     * @returns {boolean} true if the specified value is a string or a String
     */
    const isString = function( pObj )
    {
        return (_str === typeof pObj) || pObj instanceof String;
    };

    /**
     * Attempts to convert a value to a string
     * @param pObj {any}
     * @returns {string}
     * @private
     */
    function _toString( pObj )
    {
        if ( isString( pObj ) )
        {
            return pObj;
        }
        return (0 === pObj || "0" === pObj || false === pObj) ? "0" : ((_mt_str + String( pObj ) + _mt_str).trim()).replaceAll( /[,_]/g, _mt_str ).trim();
    }

    /**
     * Returns true if the specified value is a number or Number (and NOT a Date)
     * @param pObj {any} a value to evaluate
     * @returns {boolean} true if the specified value is a number or Number (and NOT a Date)
     */
    const isNumber = function( pObj )
    {
        return ([_num, _big].includes( typeof pObj ) || pObj instanceof Number || pObj instanceof BigInt) && !(isObject( pObj ) && pObj instanceof Date);
    };

    const isBigInt = function( pNum )
    {
        return isNumber( pNum ) && _big === typeof pNum;
    };

    const isNanOrInfinite = function( pNum )
    {
        if ( !([_num, _big, _str].includes( typeof pNum ) || pNum instanceof Number) )
        {
            return true;
        }
        const num = parseFloat( pNum );
        return isNaN( num ) || !isFinite( num );
    };

    /**
     * Returns true if the specified value can be expressed as an integer (or zero).
     * That is, the value is a natural number, a.k.a. "whole number" and contains no powers of the base less than 1
     *
     * @param pObj {number|string} a value to evaluate
     * @param pStrict {boolean} if true, the specified value must be a number; strings will not be parsed
     * @returns {boolean} true if the specified value can be expressed as an integer (or zero) without any loss of precision
     */
    const isInteger = function( pObj, pStrict = true )
    {
        let is = 0 === pObj || (isNumber( pObj ) && parseInt( pObj ) === pObj);

        if ( !is && !pStrict && isString( pObj ) && isNumeric( pObj ) )
        {
            let n = parseFloat( pObj );

            if ( isInteger( n, true ) )
            {
                let s = _mt_str + String( n );

                return s === pObj;
            }
        }

        return is;
    };

    /**
     * Returns true if the specified value cannot be expressed as an integer (or zero).
     * That is, if isInteger( n ) would return true, this function would return false,
     * unless the value is 0, which we treat as a special case and also consider to be a float.
     *
     * @param pObj {number|string} a value to evaluate
     * @param pStrict {boolean} if true, the specified value must be a number; strings will not be parsed
     * @returns {boolean} true if the specified value cannot be expressed as an integer (or zero)
     */
    const isFloat = function( pObj, pStrict = true )
    {
        if ( 0 === pObj )
        {
            return true;
        }

        let is = isNumber( pObj ) && (parseFloat( pObj ) !== parseInt( pObj ));

        if ( !is && !pStrict && isString( pObj ) && isNumeric( pObj ) )
        {
            let n = parseFloat( pObj );

            if ( isFloat( n, true ) )
            {
                let s = _mt_str + String( n );

                return s === pObj;
            }
        }

        return is;
    };

    /**
     * Returns true if the specified value represents a hexadecimal number (base 16)
     * @param pObj {string|number}
     * @returns {boolean} true if the specified value represents a hexadecimal number
     */
    function isHex( pObj )
    {
        const s = _toString( pObj );
        return ("0" !== s) && /^(-)?(0x)([\dA-Fa-f]+)?(([.,])([\dA-Fa-f]+))?$/i.test( s ) && !/[G-Wg-w\s]|[yzYZ]/.test( s );
    }

    /**
     * Returns true if the specified value represents an octal number (base 8)
     * @param pObj {string|number}
     * @returns {boolean} true if the specified value represents an octal number
     */
    function isOctal( pObj )
    {
        const s = _toString( pObj );
        return ("0" !== s) && /^(-)?(0o)([0-7]+)?(([.,])([0-7]+))?$/i.test( s ) && !/[A-Za-np-z\s]/.test( s );
    }

    function isBinary( pObj )
    {
        const s = _toString( pObj );
        return ("0" !== s) && /^(-)?(0b)([0-1]+)?(([.,])([0-1]+))?$/i.test( s ) && !/[AC-Z]|[ac-z]|\s/.test( s );
    }

    /**
     * Returns true if the specified value represents a decimal number (base 10)
     * @param pObj {string|number}
     * @returns {boolean} true if the specified value represents a decimal number
     */
    function isDecimal( pObj )
    {
        const s = _toString( pObj );
        return ("0" === s || "-0" === s || ( !(isHex( s ) || isOctal( s ) || isBinary( s )) && !/[^\d.+-]/.test( s )));
    }

    /**
     * Returns the base for the numeric value specified (i.e., 16 for hexadecimal values, 8 for octal values, or 10 for decimal values)
     * @param pObj {string|number}
     * @returns {number} the base for the numeric value specified (16, 8, or 10)
     */
    function calculateRadix( pObj )
    {
        return isDecimal( pObj ) ? 10 : isHex( pObj ) ? 16 : isOctal( pObj ) ? 8 : isBinary( pObj ) ? 2 : 0;
    }

    /**
     * Returns true if the specified value is, or can be converted to, a number
     * @param pObj {string|number} a value to evaluate
     * @param pAllowLeadingZeroForBase10 specify true to allow decimal values with leading zeroes (default: false)
     * @returns {boolean} true if the specified value is, or can be converted to, a number
     */
    const isNumeric = function( pObj, pAllowLeadingZeroForBase10 = false )
    {
        if ( isNumber( pObj ) || "0" === pObj )
        {
            return true;
        }

        if ( !([_num, _big, _str].includes( typeof pObj ) || (pObj instanceof Number || pObj instanceof String)) )
        {
            return false;
        }

        let value = ((_mt_str + _toString( pObj )).replace( /n+$/, _mt_str )).trim();

        if ( "0" === pObj || isDecimal( value ) || isHex( value ) || isOctal( value ) || isBinary( value ) )
        {
            if ( isDecimal( value ) && !!pAllowLeadingZeroForBase10 )
            {
                while ( /^0/.test( value ) )
                {
                    value = value.slice( 1 );
                }
            }

            if ( _mt_str === value )
            {
                return false;
            }

            let integer = parseInt( value, calculateRadix( pObj ) );

            return !isNanOrInfinite( integer );
        }

        return false;
    };

    /**
     * Returns true if the specified value === 0
     *
     * This can be useful if you might normally test for truthiness and you want 0 to be considered true.
     *
     * @param pValue {number|string} a value to evaluate
     * @param pStrict specify false to accept numeric values (i.e., strings that represent numbers) (default: false)
     * @returns {boolean} true if the specified value === 0
     */
    const isZero = function( pValue, pStrict = true )
    {
        const valid = pStrict ? isNumber( pValue ) : isNumeric( pValue );

        return valid && ((0 === pValue || /^0+$/.test( _toString( pValue ) )) || (Math.round( parseFloat( pValue ) ) === 0 && Math.abs( parseFloat( pValue ) ) < 0.000000000000001));
    };

    function getDigitsMap( pBase )
    {
        let base = !isNull( pBase ) && (isNumber( pBase ) || isString( pBase )) ? parseInt( pBase ) : 10;

        base = (isNanOrInfinite( base ) ? (isString( pBase ) ? ({
                                                                    "hex": 16,
                                                                    "octal": 8,
                                                                    "binary": 2,
                                                                    "decimal": 10
                                                                }[(pBase.trim().toLowerCase())] || 10) : 10) : 10);

        switch ( base )
        {
            case 0:
            case 10:
                return DIGITS_MAP;

            case 2:
                return BIN_DIGITS_MAP;

            case 8:
                return OCT_DIGITS_MAP;

            case 16:
                return HEX_DIGITS_MAP;

            default:
                const digits = DIGITS.slice( 0, pBase );
                return new Map( digits.map( ( e, i ) => [e, i] ) );
        }
    }

    /**
     * Returns the decimal representation of the specified value
     * @param pObj {number|string|[number|string]} a value to convert to a decimal representation
     * @returns {number|[number]} a decimal representation of the specified value
     */
    const toDecimal = function( pObj )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toDecimal );
        }

        if ( !isNumeric( pObj ) )
        {
            return 0;
        }

        let value = 0;

        if ( isDecimal( pObj ) )
        {
            try
            {
                value = parseFloat( pObj );
            }
            catch( ex )
            {
                modulePrototype.reportError( ex, "parsing " + _toString( pObj ), S_WARN, modName + "::toDecimal" );
                value = 0;
            }

            return value;
        }

        if ( isNumber( pObj ) )
        {
            let num = Number( pObj );
            return parseFloat( num.toString( 10 ) );
        }

        let s = _toString( pObj ).trim();

        let sign = s.startsWith( _minus ) ? -1 : 1;

        let power = calculateRadix( s );

        s = s.replace( _minus, _mt_str );

        s = s.replace( /^0([box])/i, _mt_str );

        let parts = s.split( _dot );

        let integer = (parts[0] || "0");
        let fraction = (parts[1] || "0");

        if ( /^0+$/.test( fraction ) )
        {
            return parseInt( s, power ) * sign;
        }

        let digitsMap = getDigitsMap( power );

        let intDigits = [].concat( ...(integer.split( _mt_str ).reverse()) );

        for( let i = 0, n = intDigits.length; i < n; i++ )
        {
            let digit = intDigits[i];

            value += Math.pow( digitsMap[digit], i );
        }

        let fractionDigits = fraction.split( _mt_str );

        for( let i = 0, n = fractionDigits.length; i < n; i++ )
        {
            let digit = fractionDigits[i];

            value += Math.pow( digitsMap[digit], -(i + 1) );
        }

        return value * sign;
    };

    /**
     * Returns a string representation of the specified value as a hexadecimal number
     * @param pObj {number|string|[number|string]} a value to convert to base 16 (hexadecimal)
     * @returns {string|[string]} a string representation of the specified value as a hexadecimal (base 16) number
     */
    const toHex = function( pObj )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toHex );
        }

        let decimalValue = toDecimal( pObj );

        const s = decimalValue.toString( 16 );

        return (s.startsWith( "-" ) ? "-0x" : "0x") + s.replace( /^-/, _mt_str ).trim();
    };

    /**
     * Returns a string representation of the specified value as an octal number
     * @param pObj {number|string} a value to convert to base 8 (octal)
     * @returns {string|string[]} a string representation of the specified value as an octal (base 8) number
     */
    const toOctal = function( pObj )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toOctal );
        }

        let decimalValue = toDecimal( pObj );

        const s = decimalValue.toString( 8 );

        return (s.startsWith( "-" ) ? "-0o" : "0o") + s.replace( /^-/, _mt_str ).trim();
    };

    /**
     * Returns a string representation of the specified value as a binary number
     *
     * @param pValue {number|string|[number|string]} a value to convert to base 2 (binary)
     * @param pPrecision {number} the number of decimal places to include
     *                            if the value is not a whole number (integer) Defaults to 0
     *
     * @returns {string|string[]} a string representation of the specified value as a binary (base 2) number
     */
    const toBinary = function( pValue, pPrecision = 0 )
    {
        if ( isArray( pValue ) )
        {
            return [...pValue].map( toBinary );
        }

        let decimalValue = toDecimal( pValue );

        let s = decimalValue.toString( 2 );

        if ( s.includes( _dot ) )
        {
            let maxPrecision = Math.max( 0, Math.min( 15, parseInt( _toString( pPrecision || _mt_str ), 10 ) ) );

            if ( (isNanOrInfinite( maxPrecision ) || maxPrecision <= 0) && isNull( pPrecision ) )
            {
                const msg = `Non-Integer value passed to ${modName}::toBinary without specifying precision; value will be truncated`;

                modulePrototype.reportError( new IllegalArgumentError( msg, { value: num } ), msg, S_WARN, modName + "::toBinary", { value: num } );

                s = s.replace( /\.\d+$/, _mt_str );
            }
        }

        return (s.startsWith( "-" ) ? "-0b" : "0b") + s.replace( /^-/, _mt_str ).trim();
    };

    /**
     * Returns true if the specified value is a boolean or Boolean
     * @param pValue {any} a value to evaluate
     * @returns {boolean} true if the specified value is a boolean or Boolean
     */
    const isBoolean = function( pValue )
    {
        return ((_bool === typeof pValue) && ((false === pValue) || true === pValue)) || pValue instanceof Boolean;
    };

    /**
     * Returns true if the specified value is an object and is not null.
     * Optionally, you can pass options to consider objects with no properties as 'null objects'
     * @param pObject {any} a value to evaluate
     * @param pStrict {boolean} specify true to treat any value that is not identical to null as not-null
     * @param pOptions {Object} an object to clarify how to handle objects that are not null, but have no properties, i.e., {}
     * @returns {boolean} true if the specified value is an object and is not null
     */
    const isNonNullObject = function( pObject, pStrict = false, pOptions = { allow_empty_object: true } )
    {
        if ( !isNull( pObject, pStrict ) && isObject( pObject ) )
        {
            const options = Object.assign( { allow_empty_object: true }, pOptions || {} );

            return options.allow_empty_object || (Object.entries( pObject )?.length > 0 && !isNull( Object.entries( pObject )[0][1], pStrict ));
        }
        return false;
    };

    /**
     * Returns true if the specified value, which might otherwise evaluate to 'falsey',
     * is actually a non-null value, such as 0, false, or an empty string
     * @param pObject {any} a value to evaluate
     * @returns {boolean} true if the specified value is actually a non-null value,
     * even when it might otherwise evaluate to 'falsey', (such as 0, false, or an empty string)
     */
    const isNonNullValue = function( pObject )
    {
        return (false === pObject || 0 === pObject || _mt_str === pObject || isNotNull( pObject, false ));
    };

    /**
     * Returns true if the specified value is an array
     * @param pObj {any} a value to evaluate
     * @returns {boolean} true if the specified value is an array
     */
    const isArray = function( pObj )
    {
        return isObject( pObj ) && ((isFunction( Array.isArray )) ? Array.isArray( pObj ) : doesBeArray( pObj ));
    };

    const isTypedArray = function( pObj )
    {
        return (([...TYPED_ARRAYS].filter( e => pObj instanceof e ))?.length || 0) > 0;
    };

    /**
     * Returns true if the specified value is iterable.
     * That is, the value can be used in a "for...of" loop
     * @param pObj {any} a value to evaluate
     * @returns {boolean} true if the specified value is iterable
     */
    const isIterable = function( pObj )
    {
        return !isNull( pObj ) && (isFunction( pObj[Symbol.iterator] ) || isArray( pObj ) || isTypedArray( pObj ));
    };

    /**
     * Returns true if the specified value is spreadable.
     * That is, the value can be expanded by use of the ... operator
     * @param pObj {any} a value to evaluate
     * @param pMustBeIterable specify true to require that the value also be iterable
     *                        this can distinguish between objects that can be copied via {...object}
     *                        versus truly spreadable values
     *                        (default: true)
     * @returns {boolean} true if the specified value is spreadable
     */
    const isSpreadable = function( pObj, pMustBeIterable = true )
    {
        let is = !isNull( pObj ) && (isArray( pObj ) || isString( pObj ) || isNonNullObject( pObj ) || isDefined( pObj[Symbol.isConcatSpreadable] ));
        return is && (pMustBeIterable ? isIterable( pObj ) : is);
    };

    /**
     * Returns true if the specified value is asynchronously iterable.
     * That is, the value can be used in a "for await ... of" loop
     * @param pObj {any} a value to evaluate
     * @returns {boolean} true if the specified value is asynchronously iterable
     */
    const isAsyncIterable = function( pObj )
    {
        return !isNull( pObj ) && isFunction( pObj[Symbol.asyncIterator] );
    };

    /**
     * Returns true if the specified value is array-like
     * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects)
     * @param pArg {any} a value to evaluate
     * @param pMustBeIterable {boolean} specify true if the value must also define [Symbol.iterator] (default:false)
     * @returns {boolean} true if the specified value is array-like (that is, has a length property and one or more numeric keys)
     */
    const isLikeArray = function( pArg, pMustBeIterable = false )
    {
        if ( isArray( pArg ) || isString( pArg ) || isTypedArray( pArg ) )
        {
            return true;
        }

        if ( !isNull( pArg ) && !isNull( pArg?.length ) )
        {
            const keys = Object.keys( pArg );

            if ( keys.some( key => isNumeric( key ) ) )
            {
                return !pMustBeIterable || isIterable( pArg );
            }
        }

        return false;
    };

    /**
     * Returns true of the specified value is a Symbol
     * @param pValue {any} a value to evaluate
     * @returns {boolean} true of the specified value is a Symbol
     */
    const isSymbol = function( pValue )
    {
        return _symbol === typeof pValue || pValue instanceof Symbol;
    };

    /**
     * Returns true if the specified value cannot be modified.
     * @see constants.isReadOnly
     * @type {(function(*): boolean)|(function(*): *)}
     */
    const isReadOnly = constants?.isReadOnly || function( pObject )
    {
        return isObject( pObject ) && (isNull( pObject ) || Object.isFrozen( pObject ) || Object.isSealed( pObject ));
    };

    /**
     * Returns true if the specified value is of the type specified (or is an instance of the class specified)
     * @param pValue {any} a value to evaluate
     * @param pType {string|Function} the type for which to compare the type of the specified value (or a class of which the specified value is an instance)
     * @returns {boolean} true if the specified value is of the type specified (or is an instance of the class specified)
     */
    const isType = function( pValue, pType )
    {
        const typeName = (isString( pType ) && JS_TYPES.includes( pType )) ?
                         (pType).trim().toLowerCase() :
                         typeof pType;

        if ( JS_TYPES.includes( typeName ) && (typeof pValue) === typeName )
        {
            return true;
        }

        if ( isObject( pValue ) && isFunction( pType ) )
        {
            return pValue instanceof pType;
        }

        return false;
    };

    /**
     * Returns true if the specified values are of the same type
     * @param pValues {...any} two or more values to compare
     * @returns {boolean} true if the specified values are of the same type
     */
    const areSameType = function( ...pValues )
    {
        let areSame = true;

        if ( !isNull( pValues ) )
        {
            const values = isLikeArray( pValues, true ) ? [...pValues] : [pValues || _mt_str];

            let first = values[0];

            let types = [typeof first];

            if ( [_num, _big].includes( typeof first ) )
            {
                types.push( _num, _big );
            }

            for( let i = 1, n = values.length; i < n; i++ )
            {
                let value = values[i];

                if ( !types.includes( typeof value ) )
                {
                    areSame = false;
                    break;
                }
            }
        }

        return areSame;
    };

    const areCompatibleTypes = function( ...pValues )
    {
        if ( areSameType( ...pValues ) )
        {
            return true;
        }

        if ( !isNull( pValues ) )
        {
            const values = isLikeArray( pValues, true ) ? [...pValues] : [pValues || _mt_str];

            const types = values.map( e => typeof e );

            return (types.every( e => [_num, _big, _str].includes( typeof e ) ));
        }

        return false;
    };

    /**
     * Returns true if the specified value is an instance of Map
     * or, if not strict, returns true if the specified value is an object with only string keys
     * @param pObject {any} a value to evaluate
     * @param pStrict {boolean} specify false to consider string-keyed objects (a.k.a. 'dictionaries') to be Maps (default: true)
     * @returns {boolean} true if the specified value is an instance of Map
     */
    const isMap = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) || [_str, _num, _big, _bool, _symbol].includes( typeof pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof Map;
        }

        if ( isObject( pObject ) )
        {
            const entries = Object.entries( pObject );

            const strings = entries.filter( entry => isString( entry[0] ) && !(entry[0].startsWith( "[object" )) );

            return (entries.length === strings.length);
        }
        else if ( isFunction( pObject ) && pObject?.length === 1 )
        {
            // perhaps we have a function that takes a key and returns a value...
            return true;
        }

        return false;
    };

    /**
     * Returns true if the specified value is an instance of Set
     * or, if not strict, returns true if the specified value is an array-like object with unique values
     * @param pObject {any} a value to evaluate
     * @param pStrict {boolean} specify false to consider array-like objects that have unique values as if they are Sets (default: true)
     * @returns {boolean} true if the specified value is an instance of Set
     */
    const isSet = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof Set;
        }

        if ( isLikeArray( pObject, true ) || pObject?.length >= 0 )
        {
            const length = pObject.length;
            let set = new Set( [...pObject] );
            return set?.size === length;
        }

        return false;
    };

    /**
     * Returns true if the specified object is an instance of Date
     * or if not strict, if the specified object can be converted into a Date
     * @param pObj {any} a value to evaluate
     * @param pStrict {boolean} specify false if you want to consider values that can be converted into a Date as Dates
     * @param pDateParser {object|function} (optional) a parser to convert strings into Dates
     * @returns {boolean} true if the specified object is an instance of Date
     */
    const isDate = function( pObj, pStrict = true, pDateParser = (function( pStr ) {}) )
    {
        if ( isUndefined( pObj ) || isNull( pObj ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return ((pObj instanceof Date) || ("[object Date]" === {}.toString.call( pObj ) || (pObj.constructor === Date) || (pObj.prototype === Date)));
        }

        let date = isObject( pObj ) && pObj instanceof Number ? new Date( pObj.valueOf() ) : (isNumber( pObj ) ? new Date( pObj ) : null);

        if ( isString( pObj ) || pObj instanceof String )
        {
            if ( null == date && (isFunction( pDateParser ) || isFunction( pDateParser?.parse || pDateParser?.parseDate )) )
            {
                try
                {
                    date = (pDateParser.parse || pDateParser.parseDate || pDateParser).call( pDateParser, pObj );
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, `formatting ${pObj} as a date`, S_WARN, modName + "::isDate" );
                }
            }

            if ( null == date )
            {
                try
                {
                    date = new Date( pObj );
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, `evaluating ${pObj} as a Date`, S_ERROR, modName + "::isDate" );
                }
            }
        }

        if ( null == date || !isDate( date, true ) )
        {
            switch ( typeof pObj )
            {
                case _str:
                case _num:
                case _big:
                    try
                    {
                        date = new Date( pObj );
                    }
                    catch( ex )
                    {
                        modulePrototype.reportError( ex, `evaluating ${pObj} as a Date`, S_ERROR, modName + "::isDate" );
                    }

                    break;
            }
        }

        return (isDate( date, true ));
    };

    /**
     * Returns true if the specified value is an instance of RegExp
     * or, if not strict, if the specified value is a string representation of a regular expression
     * @param pObject {any} a value to evaluate
     * @param pStrict specify false to consider a string representation of a regular expression as a RegExp
     * @returns {boolean} true if the specified value is an instance of RegExp
     */
    const isRegExp = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof RegExp;
        }

        const s = _mt_str + (isString( pObject ) ? String( pObject ) : (isFunction( pObject.toString ) ? pObject.toString() : {}.toString.call( pObject, pObject )));

        let pattern = s.replace( /\/[gimsuy]+$/, "/" ).trim();

        if ( /^\/.+\/$/.test( pattern ) )
        {
            pattern = pattern.replace( /\/$/, _mt_str ).replace( /^\//, _mt_str );

            try
            {
                let regExp = new RegExp( pattern );
                return isRegExp( regExp );
            }
            catch( ex )
            {
                // ignored
            }
        }

        return false;
    };

    /**
     * Returns true if the value passed represents a JavaScript Class
     * JavaScript classes return "function" for the typeof operator,
     * so this function is necessary to determine the difference between a function and a class definition
     * @param {function} pFunction a function to evaluate
     * @param pStrict {boolean} specify false to consider built-in types as classes (default: true)
     * @returns true if the function specified is a class definition
     */
    const isClass = function( pFunction, pStrict = true )
    {
        if ( isFunction( pFunction ) || ( !pStrict && BUILTIN_TYPE_NAMES.includes( pFunction.name )) )
        {
            if ( /^class\s/.test( (Function.prototype.toString.call( pFunction, pFunction )).trim() ) )
            {
                return true;
            }

            return !pStrict && BUILTIN_TYPE_NAMES.includes( pFunction.name );
        }

        return false;
    };

    /**
     * Returns true if the specified object is an instance of one (or more) of the specified classes
     * @param pObject {Object} an object to evaluate
     * @param pClasses {...function} one or more classes to which to compare the specified object's prototype
     * @returns {boolean} true if the specified object is an instance of one (or more) of the specified classes
     */
    const instanceOfAny = function( pObject, ...pClasses )
    {
        const classes = [].concat( ...(pClasses || []) ) || [];

        let is = false;

        while ( !is && classes?.length )
        {
            const cls = classes.shift();

            if ( isClass( cls, !BUILTIN_TYPE_NAMES.includes( cls?.name ) ) )
            {
                try
                {
                    is = (pObject instanceof cls) || pObject.prototype === cls;
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, "attempting to call instanceof without a class or callable", S_WARN, modName + "::instanceOfAny" );
                }
            }
        }

        return is;
    };

    /**
     * Returns true if the specified function is a class that is not a built-in JavaScript type
     * @param pFunction {function} a function to evaluate
     * @returns {boolean} true if the specified function is a class that is not a built-in JavaScript type
     */
    const isUserDefinedClass = function( pFunction )
    {
        return isClass( pFunction );
    };

    /**
     * Returns true if the specified function is one or the specified classes
     * @param pFunction {function} a function to evaluate
     * @param pListedClasses {...function} one or more classes to which to compare the specified function
     * @returns {boolean} true if the specified function is one or the specified classes
     */
    const isListedClass = function( pFunction, ...pListedClasses )
    {
        return isClass( pFunction ) && instanceOfAny( new pFunction(), ...pListedClasses );
    };

    /**
     * Returns true if the specified function is a class that is not a built-in JavaScript type
     * @param pObject {Object} an object to evaluate
     * @param pClass {function} specify a specific class to restrict the comparison to a specific user-defined class
     * @returns {boolean} true if the specified object is an instance of a class that is not a built-in JavaScript type
     */
    const isInstanceOfUserDefinedClass = function( pObject, pClass = null )
    {
        let clazz = isClass( pClass ) ? pClass || pObject?.constructor : pObject?.constructor || pObject?.prototype?.constructor || pObject?.prototype;
        return isUserDefinedClass( clazz ) && (null === clazz || instanceOfAny( pObject, clazz ));
    };

    /**
     * Returns true if the specified object is an instance of one or more of the specified classes
     * @param pObject {Object} an object to evaluate
     * @param pListedClasses {...function} one or more classes to which to compare the specified object's prototype
     * @returns {boolean} true if the specified object is an instance of one or more of the specified classes
     */
    const isInstanceOfListedClass = function( pObject, ...pListedClasses )
    {
        return instanceOfAny( pObject, ...pListedClasses );
    };

    /**
     * Returns the first of the candidates that is of the specified type (or null if no candidates meet the criterion)
     * @param pType {string|function} the type an object must match to be returned
     * @param pCandidates {...any} one or more candidates, the first of which that matches the specified type will be returned
     * @returns {*|null} the first of the candidates that is of the specified type (or null if no candidates meet the criterion)
     */
    const firstMatchingType = function( pType, ...pCandidates )
    {
        let arr = !isNull( pCandidates ) ? (isArray( pCandidates ) ? [].concat( ...pCandidates ) : (isSpreadable( pCandidates ) ? [...pCandidates] : [])) : [];

        if ( isString( pType ) )
        {
            const type = pType.trim().toLowerCase();
            arr = VALID_TYPES.includes( type ) ? arr.filter( e => type === typeof e && !isNull( e ) ) : [];
        }
        else if ( isClass( pType, false ) )
        {
            arr = arr.filter( e => e instanceof pType );
        }
        else if ( isFunction( pType ) )
        {
            const scope = $scope();
            arr = arr.filter( e => pType.call( scope, e ) );
        }
        else
        {
            arr = [];
        }

        return arr.length > 0 ? arr[0] : null;
    };

    /**
     * Returns the class (function) of which the specified object is an instance
     * or the class itself if the specified value *is* a class (function)
     * @param pObject an instance of some class or a function that is a class
     * @param pOptions an object to pass options to the isClass method of TypeUtils
     * @returns {function} the class of which the object is an instance or the class itself if the object is a class function
     */
    const getClass = function( pObject, pOptions = { strict: true } )
    {
        const options = Object.assign( { strict: true }, pOptions || {} );

        const obj = isObject( pObject, { rejectPrimitiveWrappers: false } ) || isFunction( pObject ) ? pObject || function() {} : null;

        if ( isNull( obj, true ) )
        {
            return null;
        }

        const strict = options?.strict;

        let clazz = isClass( obj, strict ) ? obj : obj?.constructor || obj?.prototype?.constructor || obj?.prototype || obj?.__proto__;

        if ( isClass( clazz, strict ) )
        {
            return clazz;
        }

        if ( obj )
        {
            if ( isClass( obj, strict ) )
            {
                clazz = obj;
            }

            if ( isClass( clazz, strict ) )
            {
                return clazz;
            }

            let _class = clazz;

            const iterationLimit = 5;
            let iterations = 0;

            // the IterationCap object will return reached when iterations exceed the cap,
            // so ignore the linter warnings
            // noinspection LoopStatementThatDoesntLoopJS
            while ( !isClass( _class, strict ) && (iterations++ <= iterationLimit) )
            {
                switch ( iterations )
                {
                    case 0:
                    case 1:
                        _class = (obj.constructor || obj?.prototype?.constructor) || _class;
                        break;

                    case 2:
                        _class = (obj?.prototype?.constructor || isClass( obj?.prototype, strict ) ? obj?.prototype : _class);
                        break;

                    case 3:
                        _class = isClass( obj?.prototype, strict ) ? obj?.prototype : _class;
                        break;

                    case 4:
                        _class = isClass( obj?.__proto__, strict ) ? obj?.__proto__ : _class;
                        break;

                    default:
                        break;
                }
            }

            clazz = (isClass( _class, strict ) ? _class : (isClass( clazz, strict ) ? clazz : (isClass( clazz ) ? clazz : Object))) || Object;

            if ( clazz && Object === clazz )
            {
                if ( obj instanceof Date )
                {
                    clazz = Date;
                }
                else if ( obj instanceof RegExp )
                {
                    clazz = RegExp;
                }
                else if ( obj instanceof Boolean )
                {
                    clazz = Boolean;
                }
                else if ( obj instanceof String )
                {
                    clazz = String;
                }
                else if ( obj instanceof Number )
                {
                    clazz = Number;
                }
            }
        }

        return clazz;
    };

    /**
     * Returns the name of the class of which the specified object is an instance
     * or the name of the class if the specified value *is* a class (function)
     * @param pObject {function} an instance of some class or a function that is a class
     * @returns {string} the name of the class of which the object is an instance
     * or the name of the class if the object is a class function
     */
    const getClassName = function( pObject )
    {
        const obj = isObject( pObject, { rejectPrimitiveWrappers: false } ) || isFunction( pObject ) ? pObject || function() {} : null;

        if ( isNull( obj, true ) )
        {
            return _mt_str;
        }

        let name = _mt_str;

        if ( obj )
        {
            if ( isClass( obj, false ) )
            {
                name = String( obj.name || (obj.constructor?.name) );
            }
            else if ( isObject( obj ) )
            {
                const clazz = getClass( obj, { strict: false } );
                if ( clazz )
                {
                    name = getClassName( clazz );
                }
            }

            if ( (_mt_str === name.trim()) )
            {
                name = String( obj?.constructor?.name || obj?.prototype?.constructor?.name || obj?.prototype?.name );
            }
        }

        return name;
    };

    /**
     * Returns the default value for the type specified
     * @param pType {string} the type for which to return a default value
     * @see TYPE_DEFAULTS
     * @returns {*}
     */
    const defaultFor = function( pType )
    {
        let type = isString( pType ) ? (_mt_str + pType).trim().toLowerCase() : typeof (pType);

        if ( isString( type ) && JS_TYPES.includes( type ) )
        {
            return TYPE_DEFAULTS[type];
        }

        return defaultFor( typeof type );
    };

    /**
     * Returns a new value converted to the specified type, if possible
     * @param pValue {any} a value to convert to the specified type
     * @param pType {string} the type to which to convert the specified value, if possible
     * @returns {*} a new value converted to the specified type, if possible
     */
    const castTo = function( pValue, pType )
    {
        let type = isString( pType ) ? (_mt_str + pType).trim().toLowerCase() : typeof (pType);

        type = isString( type ) && VALID_TYPES.includes( type ) ? type : _str;

        let value = !isNull( pValue, true ) ? pValue : pValue || null;

        switch ( type )
        {
            case _str:
                value = (isFunction( value?.asString )) ? value.asString() : (_mt_str + value);
                break;

            case _num:
            case _big:
                try
                {
                    value = (isFunction( value?.asFloat )) ? value.asFloat() : parseFloat( value );
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, `casting ${value} to number`, S_WARN, modName + "::castTo" );
                }
                break;

            case _bool:
                value = Boolean( value );
                break;

            case _obj:
                switch ( typeof value )
                {
                    case _obj:
                        break;

                    case _str:
                        value = new String( value );
                        break;

                    case _num:
                        value = new Number( value );
                        break;

                    case _big:
                        value = new Number( BigInt( value ) );
                        break;

                    case _bool:
                        value = new Boolean( value );
                        break;

                    default:
                        break;
                }
                break;

            default:
                break;
        }
        return value;
    };

    /**
     * Instances of this class are iterable.
     * Can be used to construct an iterable from any non-null value.
     * Unlike JavScript's built-in iterators, this iterator can be traversed in reverse and/or reset
     */
    class _Iterator
    {
        #iterable;

        #index = 0;

        constructor( pIterable )
        {
            this.#iterable = isIterable( pIterable ) ? pIterable : [pIterable];
            this.#iterable = isString( this.#iterable ) ? [].concat( this.#iterable.split( _mt_str ) ) : this.#iterable;
        }

        [Symbol.iterator]()
        {
            return this;
        }

        next()
        {
            if ( this.#index >= this.#iterable.length )
            {
                return { done: true };
            }

            const value = this.#iterable[this.#index++];

            return { value, done: false };
        }

        previous()
        {
            if ( this.#index < 1 )
            {
                return { done: true };
            }

            const value = this.#iterable[--this.#index];

            return { value, done: false };
        }

        reset()
        {
            this.#index = 0;
        }

        reverseIterator()
        {
            let newIterable = [...this.#iterable].reverse();

            return new this.constructor( newIterable );
        }
    }

    /**
     * This subclass of _Iterator just returns done immediately
     */
    class NullIterator extends _Iterator
    {
        constructor()
        {
            super( [] );
        }

        next()
        {
            return { done: true };
        }

        previous()
        {
            return { done: true };
        }
    }

    /**
     * Returns an _Iterator for the specified value
     *
     * @param pArrayLike almost any kind of value,
     *                   but generally expected to be an "indexable" collection of values
     *                   strings are converted into an array of characters,
     *                   scalar values are converted into a 1-element array containing the value
     *
     * @returns {IterableIterator} an instance of _Iterator
     */
    const toIterator = function( pArrayLike )
    {
        switch ( typeof pArrayLike )
        {
            case _ud:
                return new NullIterator();

            case _str:
                return new _Iterator( pArrayLike.split( _mt_str ) );

            case _num:
            case _big:
            case _bool:
                return new _Iterator( [pArrayLike] );

            case _fun:
                if ( isGeneratorFunction( pArrayLike ) )
                {
                    return pArrayLike();
                }

                return new _Iterator( [pArrayLike] );

            case _obj:
                if ( isArray( pArrayLike ) )
                {
                    return new _Iterator( pArrayLike );
                }

                if ( pArrayLike instanceof Map )
                {
                    return new _Iterator( [...pArrayLike.entries()] );
                }

                if ( pArrayLike instanceof Set )
                {
                    return new _Iterator( [...pArrayLike] );
                }

                if ( isDate( pArrayLike ) )
                {
                    return new _Iterator( [pArrayLike] );
                }

                const newObject = {};

                const entries = Object.entries( pArrayLike );

                for( let entry of entries )
                {
                    const key = entry[0];

                    const value = entry[1];

                    newObject[key] = toIterator( value );
                }

                return new _Iterator( Object.entries( newObject ) );

            default:
                return new NullIterator();
        }
    };

    /**
     * This class represents the common, functional programming inspired, Option or Maybe type
     * https://en.wikipedia.org/wiki/Option_type
     *
     */
    class Option
    {
        #value;

        constructor( pValue )
        {
            this.#value = (pValue instanceof this.constructor) ? pValue.#value : pValue;
        }

        get value()
        {
            return lock( this.#value );
        }

        static Some( pValue )
        {
            return new Option( pValue );
        }

        static None()
        {
            return new Option( null );
        }

        isSome()
        {
            return (null !== this.#value);
        }

        isNone()
        {
            return isUndefined( this.#value ) || null === this.#value;
        }

        map( pFunction )
        {
            const func = isFunction( pFunction ) ? pFunction : ( e ) => e;
            return this.isSome() ? Option.Some( func( this.#value ) ) : Option.None();
        }

        flatMap( pFunction )
        {
            const func = isFunction( pFunction ) ? pFunction : ( e ) => e;
            return this.map( func ).getOrElse( Option.None() );
        }

        getOrElse( pDefault )
        {
            return this.isSome() ? this.value : pDefault;
        }
    }

    /**
     * This class extends Option and requires that the 'Some' value be of the type specified
     */
    class TypedOption extends Option
    {
        #type;

        constructor( pValue, pType )
        {
            super( pValue );

            this.#type = pType;
        }

        get type()
        {
            return this.#type || _obj;
        }

        static Some( pValue, pType )
        {
            return new TypedOption( pValue, pType );
        }

        static None()
        {
            return new Option( null );
        }

        isSome()
        {
            return super.isSome() && isType( this.value, this.type );
        }

        isNone()
        {
            return super.isNone() || !isType( this.value, this.type );
        }

        map( pFunction )
        {
            const type = this.type;

            const func = isFunction( pFunction ) ? pFunction : ( e ) => castTo( e, type );

            return super.map( func );
        }

        flatMap( pFunction )
        {
            const type = this.type;

            const func = isFunction( pFunction ) ? pFunction : ( e ) => castTo( e, type );

            return super.flatMap( func );
        }

        getOrElse( pDefault )
        {
            const value = super.getOrElse( pDefault );

            if ( this.type === typeof (value) )
            {
                return value;
            }

            if ( this.type === typeof (pDefault) )
            {
                return pDefault;
            }
        }
    }

    /**
     * This class extends Option and requires that the 'Some' value be a string
     */
    class StringOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _str );
        }
    }

    /**
     * This class extends Option and requires that the 'Some' value be a number
     */
    class NumericOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _num );
        }
    }

    /**
     * This class extends Option and requires that the 'Some' value be a boolean
     */
    class BooleanOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _bool );
        }
    }

    /**
     * This class represents the return value of a function that might return null or throw exceptions
     * This class extends Option, so you can use getOrElse or check for isSome or isNone,
     * as well as check for whether the function throw errors
     * Functions that return a Result
     * should catch errors and then add them to the Result before returning,
     * rather than throw an Error
     * This style of programming can reduce the effort of checking for null
     * or of wrapping function calls in try/catch blocks
     */
    class Result extends Option
    {
        #exceptions = [];

        constructor( pValue, pErrors = [] )
        {
            super( pValue );

            this.#exceptions = [].concat( pErrors || [] ).flat();
        }

        get returnValue()
        {
            return super.getOrElse( null );
        }

        get exceptions()
        {
            return [].concat( this.#exceptions ).flat();
        }

        addErrors( ...pError )
        {
            this.#exceptions.push( ...pError );
            this.#exceptions = this.#exceptions.flat();
        }

        hasErrors()
        {
            return (this.#exceptions?.length || 0) > 0;
        }
    }

    /**
     * This is the module itself, exported from this function
     */
    let mod =
        {
            dependencies,
            getScope: $scope,
            JS_TYPES,
            VALID_TYPES,
            TYPE_DEFAULTS,
            isUndefined,
            isDefined,
            isNull,
            isNotNull,
            isNonNullValue,
            isPrimitiveWrapper,
            isObject,
            isCustomObject,
            isNonNullObject,
            isFunction,
            isAsyncFunction,
            isGeneratorFunction,
            isString,
            isEmptyString,
            isNumber,
            isInteger,
            isFloat,
            isBigInt,
            isNumeric,
            isZero,
            isBinary,
            isOctal,
            isHex,
            isDecimal,
            isNanOrInfinite,
            toDecimal,
            toHex,
            toOctal,
            toBinary,
            isBoolean,
            isArray,
            isTypedArray,
            isIterable,
            isAsyncIterable,
            isLikeArray,
            isSpreadable,
            isMap,
            isSet,
            isDate,
            isRegExp,
            isClass,
            isUserDefinedClass,
            isListedClass,
            isInstanceOfUserDefinedClass,
            isInstanceOfListedClass,
            isSymbol,
            isType,
            areSameType,
            areCompatibleTypes,
            instanceOfAny,
            getClass,
            getClassName,
            defaultFor,
            castTo,
            toIterator,
            firstMatchingType,
            isReadOnly,
            classes: { Option, TypedOption, StringOption, NumericOption, BooleanOption, Result },
            Option,
            TypedOption,
            StringOption,
            NumericOption,
            BooleanOption,
            Result
        };

    mod = modulePrototype.extend( mod );

    return mod.expose( mod, INTERNAL_NAME, (_ud !== typeof module ? module : mod) ) || mod;

}());
