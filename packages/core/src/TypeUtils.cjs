/**
 * @fileOverview
 * This module defines several utility functions for testing the typeof a value,<br>
 * converting between types, and finding elements based on their type.<br>
 * <br>
 * The original motivation for this module<br>
 * is that is a common source of bugs to type something like:<br>
 * <code>
 *     if( "string" === someVariable )
 * </code>
 * <br>
 * when what is intended is:<br>
 * <code>
 *     if( "string" === typeof someVariable )
 * </code>
 * <br>
 * This module also defines and exports the commonly-used quasi-functional programming constructs,<br>
 * <br>
 * {@Link Option}, {@link TypedOption}, and {@link Result}<br>
 * <br>
 * as well as functions for converting numbers to and from hexadecimal, octal, binary, and decimal forms.<br>
 * <br>
 *
 *
 * @module TypeUtils
 *
 * @author Scott Bockelman
 * @license MIT
 */

/* import the Constants.cjs we depend upon, using require for maximum compatibility with Node versions */
const constants = require( "./Constants.cjs" );

/**
 * Defines a string to represent the type, undefined
 */
const { _ud = "undefined" } = constants;

/**
 * This function returns the host environment scope (Browser window, Node.js global, or Worker self)
 */
const $scope = constants?.$scope || function()
{
    return (_ud === typeof self ? ((_ud === typeof global) ? ((_ud === typeof globalThis ? {} : globalThis)) : (global || {})) : (self || {}));
};

// noinspection FunctionTooLongJS
/**
 * This module is constructed by an Immediately Invoked Function Expression (IIFE).
 * see: <a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE">MDN: IIFE</a> for more information on this design pattern
 */
(function exposeModule()
{
    /**
     * Defines a string key which is unlikely to collide with other libraries or properties.
     * We use this to store the module generated by this function in global scope.
     * We can avoid re-executing the rest of this function if the module is already defined.
     */
    const INTERNAL_NAME = "__BOCK__TYPE_UTILS__";

    /**
     * Checks to see if this module is already defines and available in the global scope
     * Returns the existing module instead of recreating it, if it is already present.
     */
    if ( $scope() && (null != $scope()[INTERNAL_NAME]) )
    {
        return $scope()[INTERNAL_NAME];
    }

    /**
     * This is a dictionary of this module's dependencies.
     * <br>
     * It is exported as a property of this module,
     * allowing us to just import this module<br>
     * and then import or use the other utilities<br>
     * as properties of this module.
     * <br>
     * @dict
     * @type {Object}
     * @alias module:TypeUtils#dependencies
     */
    const dependencies =
        {
            constants
        };

    const
        {
            _mt_str,
            _dot,
            _str,
            _fun,
            _num,
            _big,
            _bool,
            _obj,
            _symbol,
            _minus,
            _zero,
            _affirmatives,
            DIGITS,
            DIGITS_MAP,
            HEX_DIGITS_MAP,
            OCT_DIGITS_MAP,
            BIN_DIGITS_MAP,
            S_ERROR,
            S_WARN,
            TYPED_ARRAYS,
            PRIMITIVE_WRAPPER_TYPES,
            BUILTIN_TYPE_NAMES,
            AsyncFunction,
            IllegalArgumentError,
            isPromise = ( pArg ) => (pArg && (pArg.constructor === Promise || pArg === Promise || pArg instanceof Promise)),
            isThenable = ( pArg ) => (pArg && (pArg.then && ("function" === typeof pArg.then))),
            populateOptions,
            detectCycles,
            objectEntries,
            objectKeys,
            objectValues,
            attempt,
            asyncAttempt,
            lock,
            classes
        } = constants;

    const { ToolBocksModule, ModuleEvent } = classes;

    /**
     * Represents the name of the module<br>
     * This name is used when error events are emitted to indicate the source of the error.
     * @type {string}
     */
    const modName = "TypeUtils";

    /**
     * This is the object that is returned from this function.
     * <br>
     * This object is the TypeUtils module<br>
     * <br>
     * The variables and functions defined in this file are added to the module before it is exported and returned.
     * <br>
     * @type {ToolBocksModule}
     */
    let modulePrototype = new ToolBocksModule( modName, INTERNAL_NAME );

    /**
     * This is an array of the 'valid' JavaScript primitive types.<br>
     * Note that 'undefined' is not considered to be a 'valid' type<br>
     * @namespace VALID_TYPES
     * @const
     * @readonly
     * @type {Array<string>}
     * @alias module:TypeUtils#VALID_TYPES
     */
    const VALID_TYPES = lock( [_str, _num, _big, _symbol, _bool, _obj, _fun] );

    /**
     * This is an array of all JavaScript primitive types.<br>
     * This includes all the 'valid' types AND 'undefined'<br>
     * @namespace JS_TYPES
     * @const
     * @readonly
     * @type {Array<string>}
     * @alias module:TypeUtils#JS_TYPES
     */
    const JS_TYPES = lock( [_ud].concat( VALID_TYPES ) );

    /**
     * This is an immutable array of the primitive types defined in JavaScript.<br>
     * These are the string, number, BigInt, symbol, and boolean types.<br>
     * <br>
     * @namespace PRIMITIVE_TYPES
     * @const
     * @readonly
     * @type {Array<string>}
     * @alias module:TypeUtils#PRIMITIVE_TYPES
     */
    const PRIMITIVE_TYPES = lock( [_str, _num, _big, _symbol, _bool] );

    /**
     * Returns true if the type of the specified value is a primitive data type.<br>
     * That is, it is not an object, function, or custom type.<br>
     * <br>
     *
     * @param {*} value - The value to evaluate
     * @returns {boolean} Returns true if the value is a primitive type, otherwise false.
     *
     * @function isPrimitive
     *
     * @alias module:TypeUtils.isPrimitive
     */
    const isPrimitive = ( value ) => PRIMITIVE_TYPES.includes( typeof value );

    /**
     * This object is a dictionary of the default values for each primitive type<br>
     * @namespace TYPE_DEFAULTS
     * @dict
     * @const
     * @readonly
     * @type {Object}
     * @alias module:TypeUtils#TYPE_DEFAULTS
     */
    const TYPE_DEFAULTS = lock(
        {
            [_str]: _mt_str,
            [_big]: 0n,
            [_num]: 0,
            [_bool]: false,
            [_fun]: null,
            [_obj]: null,
            [_symbol]: null,
            [_ud]: undefined
        } );

    /**
     * A map of the JavaScript data types to their respective sort order.<br>
     * <br>
     * This object provides a standardized order for sorting or categorizing types.<br>
     * Each key corresponds to a specific data type, with an associated
     * numerical value indicating its order in comparison to others.<br>
     * <br>
     * <br>
     * Keys/Values:<br>
     * <ul>
     *
     *   <li>"number": The lowest sort order (0).</li>
     *   <li>"bigint": The next lowest sort order (1)</li>
     *   <li>"boolean": The next lowest sort order (2)</li>
     *   <li>"string": The next lowest sort order (3)</li>
     *   <li>"object": The next lowest sort order (4)</li>
     *   <li>"function": The next lowest sort order (5)</li>
     *   <li>"symbol": The next lowest sort order (6)</li>
     *   <li>"undefined": The highest sort order (7)</li>
     *
     *  </ul>
     *
     * @namespace TYPE_SORT_ORDER
     * @dict
     * @const
     * @readonly
     * @type {Object}
     * @alias module:TypeUtils#TYPE_SORT_ORDER
     */
    const TYPE_SORT_ORDER = lock(
        {
            [_num]: 0,
            [_big]: 1,
            [_bool]: 2,
            [_str]: 3,
            [_obj]: 4,
            [_fun]: 5,
            [_symbol]: 6,
            [_ud]: 7
        } );

    /**
     * The VisitedSet class extends the native JavaScript Set class,
     * providing additional functionality to handle equality comparison for objects.
     *
     * Instances of this class are useful in recursive algorithms
     * to avoid visiting the same node more than once.
     *
     * @class
     * @alias module:TypeUtils#VisitedSet
     */
    class VisitedSet extends Set
    {
        /**
         * A function used to determine the equality of two objects.
         *
         * This function should accept two parameters representing the objects to be compared
         * and return a boolean value indicating whether the objects are considered equal.
         *
         * Typically, the equality function is used in contexts such as data comparison,
         * filtering, deduplication, or other scenarios that require logic to compare two values.
         *
         * @type {function({object},{object}):boolean}
         *
         * @param {any} element1 - The object to compare to the other.
         *
         * @param {any} element2 - The other object to compare to the first.
         *
         * @returns {boolean} true if the two objects are considered equal, otherwise false.
         */
        #equalityFunction = (( a, b ) => a === b);

        constructor( pEqualityFunction = ( a, b ) => a === b, ...pValues )
        {
            super( pValues );

            this.#equalityFunction = pEqualityFunction || (( a, b ) => a === b);
        }

        static get [Symbol.species]()
        {
            return this;
        }

        has( pValue )
        {
            if ( super.has( pValue ) )
            {
                return true;
            }

            for( let v of this.values() )
            {
                if ( isObject( v ) && (v === pValue || isFunction( this.#equalityFunction ) ? this.#equalityFunction( v, pValue ) : pValue === v) )
                {
                    return true;
                }
            }

            return false;
        }
    }

    /**
     * Returns the estimated number of bytes required to represent the specified data type.
     * <br>
     * <br>
     * Note that these values are <i>estimates</i> only<br>
     * and that the types, symbol, object, and function<br>
     * cannot be estimated; they must be calculated at runtime.<br>
     * <br>
     * Finally, the estimated number of bytes for the string type is actually 'bytes per character'
     * <br>
     *
     * @function estimateBytesForType
     *
     * @param {string} pType - The JavaScript data type to estimate memory usage for.
     *
     * @returns {number} - The estimated number of bytes for the given type.<br>
     *                     <br>
     *                     Returns:<br>
     *                     2 (bytes per character) for strings (assuming UTF-16 encoding),<br>
     *                     8 for numbers (IEEE 754 double-precision),<br>
     *                     16 for big integers (an arbitrary assumption),<br>
     *                     1 for booleans,<br>
     *                     0 for symbols and functions (size indeterminable),<br>
     *                     0 for objects (dynamic size, indeterminable),<br>
     *                     and -1 for unsupported or unknown types.<br>
     *
     *  @alias module:TypeUtils.estimateBytesForType
     */
    const estimateBytesForType = function( pType )
    {
        const type = (_mt_str + pType).toLowerCase();

        if ( JS_TYPES.includes( pType ) )
        {
            switch ( type )
            {
                case _str:
                    return 2; // Assumes string as UTF-16, 2 bytes per character
                case _num:
                    return 8; // Number (IEEE 754 double-precision floating point)
                case _big:
                    return 16; // Arbitrary assumption for BigInt size
                case _bool:
                    return 1; // Boolean (1 byte)
                case _symbol:
                    return 0; // Symbol size cannot be determined
                case _fun:
                    return 0; // Functions don't have a measurable byte size
                case _obj:
                    return 0; // Objects' sizes are dynamic and can't be determined simply
                default:
                    return -1; // For unsupported or unknown types
            }
        }
    };

    /**
     * An object that maps data types to their estimated size in bytes.
     * <br>
     * Note that these values are estimates only<br>
     * and that the types, symbol, object, and function<br>
     * cannot be estimated; they must be calculated at runtime.<br>
     * <br>
     * Finally, the estimated number of bytes for the String type is actually 'bytes per character'<br>
     * <br>
     * @namespace BYTES_PER_TYPE
     * @dict
     * @const
     * @readonly
     * @type {Object}
     * @alias module:TypeUtils#BYTES_PER_TYPE
     */
    const BYTES_PER_TYPE = lock(
        {
            [_str]: estimateBytesForType( _str ),
            [_big]: estimateBytesForType( _big ),
            [_num]: estimateBytesForType( _num ),
            [_bool]: estimateBytesForType( _bool ),
            [_fun]: estimateBytesForType( _fun ),
            [_obj]: estimateBytesForType( _obj ),
            [_symbol]: estimateBytesForType( _symbol ),
            [_ud]: estimateBytesForType( _ud )
        }
    );

    /**
     * This oddly named function, so as not to collide with 'isArray',<br>
     * is used to polyfill Array for ancient browsers or non-spec execution environments<br>
     *
     * @function _isArr
     *
     * @param {*} pArg a value to evaluate
     *
     * @returns {boolean} true if the specified argument is an Array
     *
     * @private
     */
    const _isArr = ( pArg ) => !(_ud === typeof pArg || null == pArg) && "[object Array]" === {}.toString.call( pArg );

    // poly-fill for isArray; probably obsolete with modern environments
    if ( _fun !== typeof Array.isArray )
    {
        modulePrototype.attempt( () => Array.isArray = _isArr );
    }

    /**
     * Returns true if the specified value is undefined<br>
     *
     * @function isUndefined
     *
     * @param {*} pObject A value to evaluate
     *
     * @returns {boolean} true if the specified value is undefined
     *
     * @alias module:TypeUtils.isUndefined
     */
    const isUndefined = ( pObject ) => (_ud === typeof pObject || undefined === pObject);

    /**
     * Returns true if the specified value IS defined.<br>
     * This is just an inversion of {@link isUndefined}
     *
     * @function isDefined
     *
     * @param {*} pObject A value to evaluate
     *
     * @returns {boolean} true if the specified value is defined
     *
     * @see {@link isUndefined}
     *
     * @alias module:TypeUtils.isDefined
     */
    const isDefined = ( pObject ) => !isUndefined( pObject );

    /**
     * Returns true if the specified value is a string or a {@link String} object<br>
     *
     * @function isString
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is a string or a String
     *
     * @alias module:TypeUtils.isString
     */
    const isString = ( pObj ) => (_str === typeof pObj) || pObj instanceof String;

    /**
     * Returns true if the specified value is an empty string.<br>
     * <br>
     * A value is considered to be an empty string<br>
     * if it is strictly of type "string"<br>
     * and either has a length of 0 or matches the pre-defined empty string constant.<br>
     * <br>
     *
     * @function isEmptyString
     *
     * @param {*} pObject - The value to be evaluated.
     *
     * @returns {boolean} Returns true if the input is an empty string; otherwise, returns false.
     *
     * @alias module:TypeUtils.isEmptyString
     */
    const isEmptyString = ( pObject ) => isString( pObject ) && (_mt_str === pObject || _str.length === 0);

    /**
     * Returns true if the specified value is null<br>
     * (or, when not <i>strict</i>, undefined or an empty string)<br>
     * <br>
     * The default behavior is non-strict<br>
     * and will return true for any value that is null, undefined, or an empty string.<br>
     * <br>
     *
     * @function isNull
     *
     * @param {*} pObject The value to evaluate
     * @param {boolean} pStrict Specify true to treat any value that is not <b>identical<b> to null as not-null<br>
     *
     * @returns {boolean} if the specified value is null (or, when not strict, undefined or an empty string)
     *
     * @alias module:TypeUtils.isNull
     */
    const isNull = ( pObject, pStrict = false ) => pStrict ? (null === pObject) : (isUndefined( pObject ) || null == pObject || isEmptyString( pObject ));

    /**
     * Returns true if the specified value is <i>NOT</i> null<br>
     * (or, when not <i>strict</i>, NOT undefined and NOT an empty string)<br>
     * <br>
     * The default behavior is non-strict and will return true<br>
     * for any value that is not null, undefined, or an empty string.<br>
     * <br>
     * This is just an inversion of {@link isNull}<br>
     *
     * @function isNotNull
     *
     * @param {*} pObject The value to evaluate
     * @param  {boolean} pStrict Specify true to treat any value that is not identical to null as not-null
     *
     * @returns {boolean} true if the specified value is NOT null (or, when not strict, NOT undefined and NOT an empty string)
     *
     * @see isNull
     *
     * @alias module:TypeUtils.isNotNull
     */
    const isNotNull = ( pObject, pStrict = false ) => !isNull( pObject, pStrict );

    /**
     * Returns true if the specified value is a Function.<br>
     * Or, if invoked with false as the second argument,<br>
     * the specified value is callable (via call() or apply())
     *
     * @function isFunction
     *
     * @param {*} pObj A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to return true for objects that define 'call' and 'apply' methods<br>
     *
     * @returns {boolean} true if the specified value is a Function<br>
     * (or when not invoked with strict, any object defining both a call and apply method)
     *
     * @alias module:TypeUtils.isFunction
     */
    const isFunction = ( pObj, pStrict = true ) => !isNull( pObj ) && (_fun === typeof pObj || ( !pStrict && (_fun === typeof pObj.call) && (_fun === typeof pObj.apply)));

    /**
     * Returns true if the specified value is an <i>asynchronous</i> Function<br>
     *
     * @function isAsyncFunction
     *
     * @param {*} pObject A value to evaluate
     * @returns {boolean} true if the specified value is an asynchronous Function
     *
     * @alias module:TypeUtils.isAsyncFunction
     */
    const isAsyncFunction = ( pObject ) => isFunction( pObject, true ) && (pObject.constructor === AsyncFunction || pObject === AsyncFunction);

    /**
     * Returns true if the specified value is a function that creates a generator<br>
     *
     * @function isGeneratorFunction
     *
     * @param {*} pObject A value to evaluate
     *
     * @returns {boolean} true if the specified value is a function that creates a generator
     *
     * @alias module:TypeUtils.isGeneratorFunction
     */
    const isGeneratorFunction = ( pObject ) => (isFunction( pObject ) && "[object Generator]" === {}.toString.call( pObject.prototype, pObject.prototype ));

    /**
     * @typedef {Object} ObjectEvaluationOptions
     *
     * @property [rejectPrimitiveWrappers=true] When true, instances of the Boolean, String, Number, and BigInt classes are not considered to be objects.<br>
     * @property [rejectArrays=false] When true, arrays are not considered to be objects<br>
     * @property [rejectNull=false] When true, null is not considered to be an object, even though typeof null === "object"
     * @property [allowEmptyObjects=true] When false, objects with no properties, i.e., Object.keys(obj).length === 0, are not considered objects
     */

    /**
     * This object defines the default options for the {@link isObject} function.<br>
     * @type {ObjectEvaluationOptions}
     * @alias module:TypeUtils#DEFAULT_IS_OBJECT_OPTIONS
     */
    const DEFAULT_IS_OBJECT_OPTIONS =
        {
            rejectPrimitiveWrappers: true,
            rejectArrays: false,
            rejectNull: false,
            allowEmptyObjects: true
        };

    /**
     * Returns true if the specified value is an instance of String, Number, Boolean, or BigInt<br>
     *
     * @function isPrimitiveWrapper
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an instance of String, Number, Boolean, or BigInt
     *
     * @alias module:TypeUtils.isPrimitiveWrapper
     */
    const isPrimitiveWrapper = ( pObj ) => !isNull( pObj ) && [...PRIMITIVE_WRAPPER_TYPES].filter( e => pObj instanceof e ).length > 0;

    /**
     * Returns the primitive type value of the specified object.<br>
     *
     * @param {*} pValue
     */
    const toPrimitive = function( pValue )
    {
        if ( _ud === typeof pValue || null === pValue )
        {
            return 0;
        }

        let value = isPrimitive( pValue ) ? pValue : (isPrimitiveWrapper( pValue ) ? pValue?.valueOf() : isDate( pValue ) ? pValue.getTime() : pValue);

        value = isPrimitive( value ) ? value : attempt( () => isFunction( value?.toString ) ? value.toString() : {}.prototype.toString.call( value ) );

        return value;
    };

    /**
     * Returns true if the specified value is an object.<br>
     * Use the options to clarify how to treat primitive wrappers, arrays, and nulls<br>
     *
     * @function isObject
     *
     * @see {@link DEFAULT_IS_OBJECT_OPTIONS}
     * @see {@link isPrimitiveWrapper}
     *
     * @param {*} pObj A value to evaluate
     * @param {ObjectEvaluationOptions} pOptions An object specifying how to handle arrays, null values, or primitive value wrappers<br>
     *
     * @returns {boolean} true if the specified value is an object according to the options specified
     *
     * @alias module:TypeUtils.isObject
     */
    const isObject = function( pObj, pOptions = DEFAULT_IS_OBJECT_OPTIONS )
    {
        if ( (_obj === typeof pObj) || pObj instanceof Object )
        {
            const options = populateOptions( pOptions, DEFAULT_IS_OBJECT_OPTIONS );

            if ( options.rejectNull && isNull( pObj ) )
            {
                return false;
            }

            if ( options.rejectPrimitiveWrappers && isPrimitiveWrapper( pObj ) )
            {
                return false;
            }

            return !(options.rejectArrays && _isArr( pObj ));
        }
        return false;
    };

    /**
     * Returns true if the specified value is an object that does not derive from the JavaScript {@link Object} type<br>
     *
     * @function isCustomObject
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an object that does not derive from the JavaScript Object type
     *
     * @alias module:TypeUtils.isCustomObject
     */
    const isCustomObject = ( pObj ) => isObject( pObj ) && pObj.prototype !== null && pObj.prototype !== Object && (pObj.constructor === null || pObj.constructor !== Object) && !isPrimitiveWrapper( pObj );


    /**
     * Returns true if the specified value is an object that represents an Error.<br>
     * That is, if the object is an instance of Error or a subclass of Error.<br>
     *
     * @function isError
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an object representing a runtime error
     *
     * @alias module:TypeUtils.isError
     */
    const isError = ( pObj ) => isObject( pObj ) && pObj instanceof Error;

    /**
     * Returns true if the specified value is an object that represents an Event<br>
     * That is, the object is an instance of Event, CustomEvent, or a subclass of Event or CustomEven
     *
     * @function isEvent
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an Event or CustomEvent or a subclass of either
     *
     * @alias module:TypeUtils.isCustomObject
     */
    const isEvent = ( pObj ) => isObject( pObj ) && (pObj instanceof Event || pObj instanceof CustomEvent || pObj instanceof ModuleEvent);

    /**
     * Returns the first object that is an instance of Error from the provided input.<br>
     * <br>
     * <br>
     * The function takes a variable number of parameters, processes them into a flat array,
     * and filters out non-error objects. It then returns the first error object found.
     * <br>
     * <br>
     * If the input is null or undefined, or if none of the elements are error objects,
     * the function returns null.
     *
     * @function firstError
     *
     * @param {...*} pObj - A variable number of arguments, which can be of any type.
     *                      If multiple arguments are passed, they are converted into a flat array.
     *                      Only error objects within this input are considered.
     *
     * @returns {Error|undefined} The first error object from the input, or undefined if no errors are found.
     *
     * @alias module:TypeUtils.firstError
     */
    const firstError = function( ...pObj )
    {
        let arr = (!isNull( pObj ) ? isArray( pObj ) ? pObj : [pObj] : []).flat().filter( isError );
        return arr.filter( e => isError( e ) ).shift() || null;
    };

    /**
     * Attempts to convert a value to a string<br>
     *
     * @param {*} pObj
     *
     * @returns {string} A string representation of the specified value, if possible
     *
     * @private
     */
    function _toString( pObj )
    {
        if ( isString( pObj ) )
        {
            return pObj;
        }
        return (0 === pObj || _zero === pObj || false === pObj) ? _zero : ((_mt_str + String( pObj ) + _mt_str).trim()).replaceAll( /[,_]/g, _mt_str ).trim();
    }

    /**
     * Returns true if the specified value is a number or Number (and NOT a Date)<br>
     *
     * @function isNumber
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is a number or Number (and NOT a Date)
     *
     * @alias module:TypeUtils.isNumber
     */
    const isNumber = ( pObj ) => ([_num, _big].includes( typeof pObj ) || pObj instanceof Number || pObj instanceof BigInt) && !(isObject( pObj ) && pObj instanceof Date);

    /**
     * Returns true if the specified value is a BigInt.<br>
     *
     * @function isBigInt
     *
     * @param {*} pNum A value to evaluate
     *
     * @returns {boolean} true if the input is a BigInt and valid, otherwise false.
     *
     * @alias module:TypeUtils.isBigInt
     */
    const isBigInt = ( pNum ) => isNumber( pNum ) && _big === typeof pNum;

    /**
     * Returns true if the value is NaN or is not Finite<br>
     * This combines the commonly used conditions,<br>
     * <code>isNaN( num ) || !isFinite( num )</code>
     * <br>
     *
     * @function isNanOrInfinite
     *
     * @param {*} pNum A value to evaluate
     *
     * @returns {boolean} true if the specified value is not a number or is NaN or is not Finite
     *
     * @alias module:TypeUtils.isNanOrInfinite
     */
    const isNanOrInfinite = function( pNum )
    {
        if ( !([_num, _big, _str].includes( typeof pNum ) || pNum instanceof Number) )
        {
            return true;
        }
        const num = parseFloat( pNum );
        return isNaN( num ) || !isFinite( num );
    };

    /**
     * Returns true if the specified value can be expressed as an integer (or zero).<br>
     * That is, the value is a natural number, a.k.a. "whole number" and contains no powers of a base less than 1<br>
     * <br>
     *
     * @function isInteger
     *
     * @param {number|string} pObj A value to evaluate
     * @param {boolean} pStrict If true, the specified value must be a number; strings will not be parsed
     *
     * @returns {boolean} true if the specified value can be expressed as an integer (or zero) without any loss of precision
     *
     * @alias module:TypeUtils.isInteger
     */
    const isInteger = function( pObj, pStrict = true )
    {
        let is = (0 === pObj) || (isNumber( pObj ) && !isNanOrInfinite( pObj ) && (parseInt( pObj ) === pObj));

        if ( !is && !pStrict && isString( pObj ) && isNumeric( pObj ) )
        {
            let n = parseFloat( pObj );

            if ( !isNanOrInfinite( n ) && isInteger( n, true ) )
            {
                let s = (_mt_str + String( n )).trim();

                return s === (_mt_str + String( pObj )).trim();
            }
        }

        return is;
    };

    /**
     * Returns true if the specified value cannot be expressed as an integer (or zero).<br>
     * That is, if isInteger( n ) would return true, this function would return false,<br>
     * unless the value is 0, which we treat as a special case and also consider to be a float.<br>
     *
     * @function isFloat
     *
     * @param {number|string} pObj A value to evaluate
     *
     * @param {boolean} pStrict  If true, the specified value must be a number; strings will not be parsed
     *
     * @param {boolean} pZeroIsFloat indicates whether to consider zero a float or an integer, Defaults to true
     *
     * @returns {boolean} true if the specified value cannot be expressed as an integer (or zero)
     *
     * @alias module:TypeUtils.isFloat
     */
    const isFloat = function( pObj, pStrict = true, pZeroIsFloat = true )
    {
        if ( 0 === pObj )
        {
            return !!pZeroIsFloat;
        }

        let is = isNumber( pObj ) && !isNaN( parseFloat( pObj ) ) && ((parseFloat( pObj ) !== parseInt( pObj )) || parseFloat( pObj ) % 1 !== 0);

        if ( !is && !pStrict && isString( pObj ) && isNumeric( pObj ) )
        {
            let n = parseFloat( pObj );

            if ( isFloat( n, true ) )
            {
                let s = _mt_str + String( n );

                return s === pObj;
            }
        }

        return is;
    };

    /**
     * Returns true if the specified value represents a hexadecimal number (base 16)<br>
     * The value can either be a hexadecimal literal, such a 0xFF, <br>
     * or a string starting with "0x" and containing only the hexadecimal digits, a minus sign, or a decimal point<br>
     *
     * @function isHex
     *
     * @param {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents a hexadecimal number
     *
     * @alias module:TypeUtils.isHex
     */
    function isHex( pObj )
    {
        const s = _toString( pObj ).replaceAll( /_/g, _mt_str ).trim();
        return (_zero !== s) && /^(-)?(0x)([\dA-Fa-f]+)?(([.,])([\dA-Fa-f]+))?$/i.test( s ) && !/[G-Wg-w\s]|[yzYZ]/.test( s );
    }

    /**
     * Returns true if the specified value represents an octal number (base 8)<br>
     * The value can either be an octal literal, such a 0o07, <br>
     * or a string starting with "0o" and containing only the octal digits, a minus sign, or a decimal point<br>
     *
     * @function isOctal
     *
     * @param {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents an octal number
     *
     * @alias module:TypeUtils.isOctal
     */
    function isOctal( pObj )
    {
        const s = _toString( pObj ).replaceAll( /_/g, _mt_str ).trim();
        return (_zero !== s) && /^(-)?(0o)([0-7]+)?(([.,])([0-7]+))?$/i.test( s ) && !/[A-Za-np-z\s]/.test( s );
    }

    /**
     * Returns true if the specified value represents an octal number (base 8)<br>
     * The value can either be an octal literal, such a 0o07, <br>
     * or a string starting with "0o" and containing only the octal digits, a minus sign, or a decimal point<br>
     *
     * @function isBinary
     *
     * @param {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents an octal number
     *
     * @alias module:TypeUtils.isBinary
     */
    function isBinary( pObj )
    {
        const s = _toString( pObj ).replaceAll( /_/g, _mt_str ).trim();
        return (_zero !== s) && /^(-)?(0b)([0-1]+)?(([.,])([0-1]+))?$/i.test( s ) && !/[AC-Z]|[ac-z]|\s/.test( s );
    }

    /**
     * Returns true if the specified value represents a number expressed in scientific notation (i.e., 4e-12)<br>
     *
     * @function isScientificNotation
     *
     * @param {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents a number expressed in scientific notation
     *
     * @alias module:TypeUtils.isScientificNotation
     */
    const isScientificNotation = ( pObj ) => (/^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)$/).test( _toString( pObj ).replaceAll( /_/g, _mt_str ).trim() );

    /**
     * Returns true if the specified value represents a decimal number (base 10)<br>
     *
     * @function isDecimal
     *
     * @param  {string|number} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value represents a decimal number
     *
     * @alias module:TypeUtils.isDecimal
     */
    function isDecimal( pObj )
    {
        const s = _toString( pObj ).replaceAll( /_/g, _mt_str ).trim();
        return (_zero === s || "-0" === s || ( !(isHex( s ) || isOctal( s ) || isBinary( s )) && !/[^\dEe.+-]/.test( s )));
    }

    /**
     * Returns the base for the numeric value specified (i.e., 16 for hexadecimal values, 8 for octal values, or 10 for decimal values)<br>
     * <br>
     * This is used to determine the proper second argument to pass to {@link parseInt}
     *
     * @param pObj {string|number}
     *
     * @returns {number} the base for the numeric value specified (16, 8, or 10)
     */
    const calculateRadix = ( pObj ) => isDecimal( pObj ) ? 10 : isHex( pObj ) ? 16 : isOctal( pObj ) ? 8 : isBinary( pObj ) ? 2 : 0;

    /**
     * Returns true if the specified value is, or can be converted to, a number<br>
     * <br>
     * @param  {string|number} pObj A value to evaluate
     * @param {boolean} [pAllowLeadingZeroForBase10=false] Specify true to allow decimal values with leading zeroes
     *
     * @returns {boolean} true if the specified value is, or can be converted to, a number
     *
     * @alias module:TypeUtils.isNumeric
     */
    const isNumeric = function( pObj, pAllowLeadingZeroForBase10 = false )
    {
        if ( isNumber( pObj ) || _zero === pObj )
        {
            return true;
        }

        if ( (_ud === typeof pObj || null === pObj) || !([_num, _big, _str].includes( typeof pObj ) || (pObj instanceof Number || pObj instanceof String)) )
        {
            return false;
        }

        let value = ((_mt_str + _toString( pObj )).replace( /n+$/, _mt_str )).trim();

        if ( _zero === pObj || isDecimal( value ) || isHex( value ) || isOctal( value ) || isBinary( value ) || isScientificNotation( value ) )
        {
            if ( isDecimal( value ) && !!pAllowLeadingZeroForBase10 )
            {
                while ( /^0/.test( value ) )
                {
                    value = value.slice( 1 );
                }
            }

            if ( _mt_str === value )
            {
                return false;
            }

            let integer = parseInt( value, calculateRadix( pObj ) );

            return !isNanOrInfinite( integer );
        }

        return false;
    };

    /**
     * Returns true if the specified value === 0 <br>
     * <br>
     * This can be useful if you might normally test for truthiness and you want 0 to be considered true.<br>
     * <br>
     *
     * @param  {string|number} pValue A value to evaluate
     * @param {boolean} [pStrict=true] specify false to accept numeric values (i.e., strings that represent numbers)
     *
     * @returns {boolean} true if the specified value === 0
     *
     * @alias module:TypeUtils.isZero
     */
    const isZero = function( pValue, pStrict = true )
    {
        const valid = pStrict ? isNumber( pValue ) : isNumeric( pValue );

        return valid && ((0 === pValue || /^-?0+$|^0+$|^[0.-]{1,3}0+$/.test( _toString( pValue ) )) || (Math.round( parseFloat( pValue ) ) === 0 && Math.abs( parseFloat( pValue ) ) < 0.000000000000001));
    };

    /**
     * Returns a mapping of digit characters to their respective numerical values based on the specified base.<br>
     * <br>
     * @param {number|string} pBase - The numerical base or its string representation (e.g., 2, 8, 10, 16 or "binary", "octal", "decimal", "hex").<br>
     *                                If the value is null, not a number, or an unrecognized string, a default base of 10 is assumed.<br>
     * @return {Map<string, number>} A map where each key is a digit character and its corresponding value is the numerical value of that digit<br>
     *                               <br>
     *                               Predefined maps are returned for bases 2 (binary), 8 (octal), 10 (decimal), and 16 (hexadecimal).<br>
     *                               For other bases, a custom map is dynamically created using the range of available characters.
     *
     * @private
     */
    function getDigitsMap( pBase )
    {
        let base = !isNull( pBase ) && isNumeric( pBase ) ? parseInt( pBase ) : 10;

        base = (isNanOrInfinite( base ) ? (isString( pBase ) ? ({
                                                                    "hex": 16,
                                                                    "octal": 8,
                                                                    "binary": 2,
                                                                    "decimal": 10
                                                                }[(pBase.trim().toLowerCase())] || 10) : 10) : base);

        switch ( base )
        {
            case 0:
            case 10:
                return DIGITS_MAP;

            case 2:
                return BIN_DIGITS_MAP;

            case 8:
                return OCT_DIGITS_MAP;

            case 16:
                return HEX_DIGITS_MAP;

            default:
                const digits = DIGITS.slice( 0, pBase );
                return new Map( digits.map( ( e, i ) => [e, i] ) );
        }
    }

    /**
     * Returns a number or an array of numbers constrained to be within the specified minimum and maximum bounds.<br>
     * <br>
     * This is basically shorthand for Math.max( Math.min( n, max ), min )<br>
     * <br>
     * <br>
     * This function operates recursively if the input is an array, clamping each numerical value
     * within the provided bounds.<br>
     * <br>
     * For non-numeric inputs, the value is returned unchanged.<br>
     * <br>
     * @param {number|Array} pNum - The number or array of numbers to be clamped.
     *                              Nested arrays of any depth are supported.
     *
     * @param {number} pMin - The minimum value to which numbers should be clamped.
     *
     * @param {number} pMax - The maximum value to which numbers should be clamped.
     *
     * @returns {number|Array} - The clamped number or an array of clamped numbers.<br>
     *                           Non-numeric input is returned as is.
     *
     * @alias module:TypeUtils.clamp
     */
    const clamp = ( pNum, pMin, pMax ) => isArray( pNum ) ? [...pNum].map( e => clamp( e, pMin, pMax ) ) : isNumeric( pNum ) ? Math.min( Math.max( toDecimal( pNum ), pMin ), pMax ) : pNum;

    /**
     * Converts a string representation of a number (potentially including a fractional part)
     * into its decimal numerical equivalent.
     * This function accommodates various radix notations and handles optional custom decimal separators.
     *
     * @param {Object|string|number} pObj - The input value to convert to a decimal, which can be a string, number, or other object types.
     * @param {string} [pDecimalSeparator=_dot] - An optional custom character used as the decimal separator.
     * @returns {number} - The decimal numerical value obtained from the string representation.
     *
     * @private
     */
    const _stringToDecimal = function( pObj, pDecimalSeparator = _dot )
    {
        let s = _toString( pObj ).trim();

        let sign = s.startsWith( _minus ) ? -1 : 1;

        let power = calculateRadix( s );

        s = s.replace( _minus, _mt_str );

        s = s.replace( /^0([box])/i, _mt_str );

        const sep = pDecimalSeparator || _dot;

        let parts = s.split( sep );

        let integer = (parts[0] || _zero);
        let fraction = (parts[1] || _zero);

        if ( /^0+$/.test( fraction ) )
        {
            return parseInt( s, power ) * sign;
        }

        let value = 0;

        let digitsMap = getDigitsMap( power );

        let intDigits = [].concat( ...(integer.split( _mt_str ).reverse()) );

        for( let i = 0, n = intDigits.length; i < n; i++ )
        {
            const digit = intDigits[i];
            const multiple = power ** i;

            const base = digitsMap.get( digit ) || parseInt( digit );
            value += isZero( base ) ? 0 : base * multiple;
        }

        let fractionDigits = fraction.split( _mt_str );

        for( let i = 0, n = fractionDigits.length; i < n; i++ )
        {
            const digit = fractionDigits[i];
            const multiple = power ** -(i + 1);
            const base = digitsMap.get( digit ) || parseInt( digit );
            value += isZero( base ) ? 0 : base * multiple;
        }

        return value * sign;
    };

    /**
     * Returns the decimal representation of the specified value<br>
     * <br>
     * If the specified value is not numeric, returns 0<br>
     * <br>
     * If the specified value is an array, a new array is returned with each element in the array mapped to a decimal representation<br>
     *
     * @param {number|string|Array<(number|string)>} pObj A value or an array of values to convert to a decimal representation<br>
     *
     * @param {string} [pDecimalSeparator=.] The symbol used to separate the integer part from the fractional part of a non-integer value
     *
     * @returns {number|Array<number>} a decimal representation of the specified value
     *
     * @alias module:TypeUtils.toDecimal
     */
    const toDecimal = function( pObj, pDecimalSeparator = _dot )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toDecimal );
        }

        if ( !isNumeric( pObj ) )
        {
            return 0;
        }

        if ( isScientificNotation( pObj ) )
        {
            let s = String( pObj ).trim();

            const rx = /[eE]/i;

            if ( rx.test( s ) )
            {
                const parts = s.split( rx );

                let coefficient = parseFloat( parts[0] );

                let exponent = parseInt( (parts.length > 1 ? parts[1] : 0), 10 );

                coefficient = isBigInt( coefficient ) || isBigInt( exponent ) ? BigInt( coefficient ) : coefficient;
                exponent = isBigInt( coefficient ) || isBigInt( exponent ) ? BigInt( exponent ) : exponent;

                return parseFloat( (coefficient * 10 ** exponent).toFixed( clamp( Math.abs( exponent ), 0, 100 ) ) );
            }
        }

        if ( isDecimal( pObj ) )
        {
            return attempt( () => parseFloat( pObj ) ) || 0;
        }

        if ( isNumber( pObj ) )
        {
            let num = Number( pObj );
            return parseFloat( num.toString( 10 ) );
        }

        return _stringToDecimal( pObj, pDecimalSeparator );
    };

    /**
     * Returns a string representation of the specified value as a hexadecimal number<br>
     * <br>
     * If the specified value is an array, a new array is returned with each element in the array mapped to a hexadecimal representation<br>
     *
     * @param {number|string|Array<(number|string)>} pObj A value or an array of values to convert to a base 16 (hexadecimal) representation
     *
     * @returns {string|Array<string>} A string representation of the specified value as a hexadecimal (base 16) number
     *
     * @alias module:TypeUtils.toHex
     */
    const toHex = function( pObj )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toHex );
        }

        let decimalValue = toDecimal( pObj );

        const s = decimalValue.toString( 16 );

        return (s.startsWith( "-" ) ? "-0x" : "0x") + s.replace( /^-/, _mt_str ).trim();
    };

    /**
     * Returns a string representation of the specified value as an octal number<br>
     * <br>
     * If the specified value is an array, a new array is returned with each element in the array mapped to an octal representation
     * <br>
     *
     * @param {number|string|Array<(number|string)>} pObj A value to convert to base 8 (octal)
     *
     * @returns {string|Array<string>} A string representation of the specified value as an octal (base 8) number
     *
     * @alias module:TypeUtils.toOctal
     */
    const toOctal = function( pObj )
    {
        if ( isArray( pObj ) )
        {
            return [...pObj].map( toOctal );
        }

        let decimalValue = toDecimal( pObj );

        const s = decimalValue.toString( 8 );

        return (s.startsWith( "-" ) ? "-0o" : "0o") + s.replace( /^-/, _mt_str ).trim();
    };

    /**
     * Returns a string representation of the specified value as a binary number
     * <br>
     * If the specified value is an array,
     * a new array is returned with each element in the array mapped
     * to a binary representation
     * <br>
     *
     * @param {number|string|Array<(number|string)>} pValue A value or an array of values to convert to base 2 (binary)
     *
     * @param {number} [pPrecision=0] The number of decimal places to include
     *                                if the value is not a whole number (integer)
     *
     * @returns {string|Array<string>} A string representation of the specified value as a binary (base 2) number
     *
     * @alias module:TypeUtils.toBinary
     */
    const toBinary = function( pValue, pPrecision = 0 )
    {
        if ( isArray( pValue ) )
        {
            return [...pValue].map( ( e ) => toBinary( e, pPrecision ) );
        }

        let decimalValue = toDecimal( pValue );

        let s = decimalValue.toString( 2 );

        if ( s.includes( _dot ) )
        {
            let maxPrecision = Math.max( 0, Math.min( 15, parseInt( _toString( pPrecision || _mt_str ), 10 ) ) );

            if ( (isNanOrInfinite( maxPrecision ) || maxPrecision <= 0) && isNull( pPrecision ) )
            {
                const msg = `Non-Integer value passed to ${modName}::toBinary to specify precision; value will be truncated`;

                modulePrototype.reportError( new IllegalArgumentError( msg, { value: pValue } ), msg, S_WARN, modName + "::toBinary", { value: pValue } );

                s = s.replace( /\.\d+$/, _mt_str );
            }
        }

        return (s.startsWith( "-" ) ? "-0b" : "0b") + s.replace( /^-/, _mt_str ).trim();
    };

    /**
     * Converts a given value to an integer.
     *
     * This function takes an input value, converts it to a decimal representation,
     * and then converts the result into an integer using `parseInt`.
     *
     * @param {*} pValue - The value to be converted to an integer. It is expected
     *                     that the input can be handled by the `toDecimal` helper function.
     *
     * @returns {number} The integer representation of the input value.
     *
     * @alias module:TypeUtils.toInteger
     */
    const toInteger = ( pValue ) => attempt( () => parseInt( toDecimal( pValue ) ) );

    /**
     * Converts the provided value to a floating-point number.
     *
     * This function coverts the input into a decimal representation,
     * using the `toDecimal` function,
     * and then converts it to a floating-point number
     * using `parseFloat`.
     *
     * @param {*} pValue - The value to be converted to a floating-point number.
     * @returns {number} The float representation of the input value.
     *
     * @alias module:TypeUtils.toFloat
     */
    const toFloat = ( pValue ) => attempt( () => parseFloat( toDecimal( pValue ) ) );

    /**
     * Returns true if the specified value is a boolean or Boolean object<br>
     *
     * @param {*} pValue A value to evaluate
     *
     * @returns {boolean} true if the specified value is a boolean or Boolean object
     *
     * @alias module:TypeUtils.isBoolean
     */
    const isBoolean = ( pValue ) => ((_bool === typeof pValue) && ((false === pValue) || true === pValue)) || pValue instanceof Boolean;

    /**
     * Returns true if the specified value is an object and is not null.<br>
     * <br>
     * Optionally, you can pass options to consider objects with no properties as 'null objects'<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} pStrict Specify true to treat any value that is not identical to null as not-null
     * @param pOptions {ObjectEvaluationOptions} An object to clarify how to handle objects that are not null, but have no properties, i.e., {}
     *
     * @returns {boolean} true if the specified value is an object and is not null
     *
     * @alias module:TypeUtils.isNonNullObject
     */
    const isNonNullObject = function( pObject, pStrict = false, pOptions = DEFAULT_IS_OBJECT_OPTIONS )
    {
        const options = populateOptions( pOptions, DEFAULT_IS_OBJECT_OPTIONS );

        if ( !isNull( pObject, pStrict ) && isObject( pObject, options ) )
        {
            if ( options.allowEmptyObjects )
            {
                return true;
            }

            const entries = Object.entries( pObject );

            if ( options.rejectNull )
            {
                return (entries?.length > 0 && !isNull( entries[0][1], pStrict ));
            }

            return (entries?.length > 0);
        }
        return false;
    };

    /**
     * Returns true if the specified value,<br>
     * which might otherwise evaluate to 'falsey',<br>
     * is actually a non-null value, such as 0, false, or an empty string<br>
     *
     * @param {*} pObject A value to evaluate
     * @returns {boolean} true if the specified value is actually a non-null value,
     * even when it might otherwise evaluate to 'falsey', (such as 0, false, or an empty string)
     *
     * @alias module:TypeUtils.isNonNullValue
     */
    const isNonNullValue = ( pObject ) => (false === pObject || 0 === pObject || _mt_str === pObject || isNotNull( pObject, false ));

    /**
     * Returns true if the specified value is an array
     * <br>
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is an array
     *
     * @alias module:TypeUtils.isArray
     */
    const isArray = ( pObj ) => isObject( pObj ) && ((isFunction( Array.isArray )) ? Array.isArray( pObj ) : _isArr( pObj ));

    /**
     * Returns true if the specified value is an instance of a {@link TypedArray}.
     *
     * @function isTypedArray
     *
     * @param {Object} pObj - The object to be evaluated.
     * @returns {boolean} Returns true if the object is an instance of any typed array<br>
     *                    (e.g., Int8Array, Uint8Array, Float32Array, etc.),<br>
     *                    otherwise false.
     *
     * @alias module:TypeUtils.isTypedArray
     */
    const isTypedArray = ( pObj ) => (([...TYPED_ARRAYS].filter( e => isObject( pObj ) && pObj instanceof e ))?.length || 0) > 0;

    /**
     * Returns true if the specified value is iterable.<br>
     * That is, the value can be used in a "for...of" loop<br>
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is iterable
     *
     * @alias module:TypeUtils.isIterable
     */
    const isIterable = ( pObj ) => !isNull( pObj ) && (isFunction( pObj[Symbol.iterator] ) || isArray( pObj ) || isTypedArray( pObj ));

    /**
     * Returns true if the specified value is spreadable.<br>
     * That is, the value can be expanded by use of the ... operator<br>
     *
     * @param {*} pObj A value to evaluate
     * @param {boolean} [pMustBeIterable=true] Specify true to require that the value also be iterable.<br>
     *                                         This can distinguish between objects that can be copied via {...object}<br>
     *                                          versus truly spreadable values<br>
     *
     * @returns {boolean} true if the specified value is spreadable
     *
     * @alias module:TypeUtils.isSpreadable
     */
    const isSpreadable = function( pObj, pMustBeIterable = true )
    {
        let is = !isNull( pObj ) && (isArray( pObj ) || isString( pObj ) || isNonNullObject( pObj ) || isDefined( pObj[Symbol.isConcatSpreadable] ));
        return is && (pMustBeIterable ? isIterable( pObj ) : is);
    };

    /**
     * Returns true if the specified value is asynchronously iterable.<br>
     * That is, the value can be used in a "for await ... of" loop<br>
     *
     * @param {*} pObj A value to evaluate
     *
     * @returns {boolean} true if the specified value is asynchronously iterable
     *
     * @alias module:TypeUtils.isAsyncIterable
     */
    const isAsyncIterable = ( pObj ) => !isNull( pObj ) && isFunction( pObj[Symbol.asyncIterator] );

    /**
     * Returns true if the specified value is array-like<br>
     *
     * @see (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects)
     *
     * @param {*} pArg A value to evaluate
     * @param {boolean} [pMustBeIterable=false] Specify true if the value must also define [Symbol.iterator]
     *
     * @returns {boolean} true if the specified value is array-like<br>
     *                    (that is, has a length property and one or more numeric keys)
     *
     * @alias module:TypeUtils.isLikeArray
     */
    const isLikeArray = function( pArg, pMustBeIterable = false )
    {
        if ( isArray( pArg ) || isString( pArg ) || isTypedArray( pArg ) )
        {
            return true;
        }

        if ( !isNull( pArg ) && isNumeric( pArg?.length ) )
        {
            const keys = Object.keys( pArg || {} ).filter( e => "length" !== e );

            if ( keys.every( key => isNumeric( key ) ) )
            {
                return !pMustBeIterable || isIterable( pArg );
            }
        }

        return false;
    };

    /**
     * Returns true of the specified value is a Symbol<br>
     *
     * @param {*} pValue A value to evaluate
     *
     * @returns {boolean} true of the specified value is a Symbol
     *
     * @alias module:TypeUtils.isSymbol
     */
    const isSymbol = ( pValue ) => _symbol === typeof pValue || pValue instanceof Symbol;

    /**
     * @typedef {object} IsPopulatedOptions
     *
     * @property {Array.<string>} [acceptedTypes=['object']]
     * @property {number} [minimumLength=1]
     * @property {boolean} [acceptArrays=true]
     * @property {Array.<string>} [mandatoryKeys=[]]
     *
     */

    /**
     *
     * @type {IsPopulatedOptions}
     */
    const DEFAULT_IS_POPULATED_OPTIONS =
        {
            acceptedTypes: [_obj],
            minimumLength: 1,
            acceptArrays: true,
            mandatoryKeys: []
        };

    /**
     * Returns true if the specified value is
     *
     * an object with at least <i>n</i> non-empty properties
     * (where n is the value specified in the options minimumLength argument or 1)
     * and (optionally) having the specified key(s) specified in the options mandatoryKeys property
     *
     * or
     *
     *  DEPENDING ON VALUES PASSED IN THE OPTIONS ARGUMENT:
     *
     *  an array with at least <i>n</i> non-null, non-empty elements
     *  (where n is the value specified in the options minimumLength argument or 1) or
     *
     *
     *  a valid number or
     *  a boolean or
     *  a function or
     *  a non-empty string
     *
     * @param {*} pObject a value to evaluate
     *
     * @param pOptions an object defining optional characteristics the value must satisfy
     *                 acceptedTypes: an array of types to accept (defaults to ["object"])
     *                 minimumKeys: an integer defining how many properties an object must have
     *                              (or elements a pruned array must have)
     *                              defaults to 1
     *                 acceptArrays: whether to return true if the evaluated value is an array
     *                               defaults to false
     * @returns {*|boolean}
     */
    const isPopulated = function( pObject, pOptions = DEFAULT_IS_POPULATED_OPTIONS )
    {
        let opts = populateOptions( pOptions, DEFAULT_IS_POPULATED_OPTIONS );

        let acceptedTypes = [_obj].concat( ...(opts.acceptedTypes || []) ).flat();
        acceptedTypes = acceptedTypes.map( e => isString( e ) ? e.trim().toLowerCase() : e );
        acceptedTypes = acceptedTypes.filter( e => VALID_TYPES.includes( e ) );

        if ( isNull( pObject ) || !(acceptedTypes.includes( typeof pObject )) )
        {
            return false;
        }

        const minimumLength = Math.max( 1, (opts.minimumLength || 1) );

        let mandatoryKeys = [...(opts.mandatoryKeys || [])];
        mandatoryKeys = mandatoryKeys.map( e => isString( e ) ? e.trim().toLowerCase() : e );
        mandatoryKeys = mandatoryKeys.filter( e => isString( e ) && e.length > 0 );

        let populated = false;

        for( const acceptedType of acceptedTypes )
        {
            if ( acceptedType === typeof pObject )
            {
                switch ( acceptedType )
                {
                    case _str:
                        populated = (isString( pObject ) && pObject.length >= minimumLength);
                        break;

                    case _bool:
                        populated = (isBoolean( pObject ));
                        break;

                    case _num:
                    case _big:
                        populated = (isNumeric( pObject ) && !isNanOrInfinite( toFloat( pObject ) ));
                        break;

                    case _obj:
                        populated = (isNonNullObject( pObject, false,
                                                      {
                                                          rejectNull: true,
                                                          allowEmptyObjects: minimumLength < 1,
                                                          rejectPrimitiveWrappers: false,
                                                          rejectArrays: !opts.acceptArrays
                                                      } ));

                        if ( populated )
                        {
                            if ( isArray( pObject ) )
                            {
                                const arr = [...(pObject || [])].filter( e => isNonNullValue( e ) && ( !isNumeric( e ) || !isNanOrInfinite( toFloat( e ) )) );
                                populated = (arr.length >= minimumLength);
                            }
                            else if ( isPrimitiveWrapper( pObject ) )
                            {
                                return isPopulated( toPrimitive( pObject.valueOf() ), opts );
                            }
                            else
                            {
                                populated = mandatoryKeys.length <= 0 || mandatoryKeys.every( key => isDefined( pObject[key] ) );
                            }
                        }

                        break;
                }
            }
        }

        return populated;
    };

    /**
     * Returns true if the specified value is a non-null object with at least one key
     * @param pObject
     * @returns {*|boolean}
     */
    const isValidObject = function( pObject )
    {
        return isNonNullObject( pObject,
                                {
                                    rejectPrimitiveWrappers: false,
                                    rejectArrays: false,
                                    rejectNull: true,
                                    allowEmptyObjects: false
                                } );
    };

    /**
     * Returns true if the specified value cannot be modified<br>
     *
     * @function isReadOnly
     *
     * @see {@link constants.isReadOnly}
     *
     * @param {*} A value to evaluate
     *
     * @return {boolean} true if the value is immutable
     *
     * @alias module:TypeUtils.isReadOnly
     */
    const isReadOnly = constants?.isReadOnly || function( pObject )
    {
        return isObject( pObject ) && (isNull( pObject ) || Object.isFrozen( pObject ) || Object.isSealed( pObject ));
    };

    /**
     * Returns true if the specified value is of the type specified<br>
     * (or is an instance of the class specified)<br>
     *
     * @param {*} pValue A value to evaluate
     * @param {string|Function} pType The type to which to compare the type of the specified value<br>
     *                                (or a class of which the specified value is an instance)
     *
     * @returns {boolean} true if the specified value is of the type specified
     *                    (or is an instance of the class specified)
     *
     * @alias module:TypeUtils.isType
     */
    const isType = function( pValue, pType )
    {
        const typeName = (isString( pType ) && JS_TYPES.includes( pType )) ?
                         (pType).trim().toLowerCase() :
                         typeof pType;

        if ( JS_TYPES.includes( typeName ) && (typeof pValue) === typeName )
        {
            return true;
        }

        if ( isObject( pValue ) && isFunction( pType ) )
        {
            return pValue instanceof pType;
        }

        return false;
    };

    /**
     * Returns true if the specified values are of the same type<br>
     *
     * @param  {...any} pValues Two or more values to compare by type
     *
     * @returns {boolean} true if the specified values are of the same type
     *
     * @alias module:TypeUtils.areSameType
     */
    const areSameType = function( ...pValues )
    {
        let areSame = true;

        if ( !isNull( pValues ) )
        {
            const values = isLikeArray( pValues, true ) ? [...pValues] : [pValues || _mt_str];

            let first = values[0];

            let types = [typeof first];

            if ( [_num, _big].includes( typeof first ) )
            {
                types.push( _num, _big );
            }

            for( let i = 1, n = values.length; i < n; i++ )
            {
                let value = values[i];

                if ( !types.includes( typeof value ) )
                {
                    areSame = false;
                    break;
                }
            }
        }

        return areSame;
    };

    /**
     * Returns true if the provided values are of compatible types.<br>
     * <br>
     * The function first checks if all the values are of the same type using the `areSameType` function.<br>
     * <br>
     * If the types are the same, it returns true.<br>
     * If the types are not the same,<br>
     * the function further evaluates whether the values are not null,<br>
     * and whether their types can be reasonably coerced to a compatible type, such as number, bigint, or string.
     *
     * @param {...*} pValues - The values to be evaluated
     *
     * @returns {boolean} true if the values are of the same type or are all strings, numbers, or bigint values
     *
     * @alias module:TypeUtils.areCompatibleTypes
     */
    const areCompatibleTypes = function( ...pValues )
    {
        if ( areSameType( ...pValues ) )
        {
            return true;
        }

        if ( !isNull( pValues ) )
        {
            const values = (isLikeArray( pValues, true ) ? [...pValues] : [pValues || _mt_str]);

            const types = values.map( e => typeof e );

            if ( types.every( e => [_num, _big, _str].includes( typeof e ) ) )
            {
                if ( types.some( e => [_num, _big].includes( e ) ) )
                {
                    return values.every( isNumeric );
                }
                return true;
            }
        }

        return false;
    };

    /**
     * Returns true if the specified value is an instance of {@link Map}<br>
     * or, if not <i>strict</i>, returns true if the specified value is an object with only string keys<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider string-keyed objects (a.k.a. 'dictionaries') to be Maps
     *
     * @returns {boolean} true if the specified value is an instance of Map
     *
     * @alias module:TypeUtils.isMap
     */
    const isMap = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) || [_str, _num, _big, _bool, _symbol].includes( typeof pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof Map;
        }

        if ( isObject( pObject ) )
        {
            const entries = Object.entries( pObject );

            const strings = entries.filter( entry => isString( entry[0] ) && !(entry[0].startsWith( "[object" )) );

            return (entries.length === strings.length);
        }
        else if ( isFunction( pObject ) && pObject?.length === 1 )
        {
            // perhaps we have a function that takes a key and returns a value...
            return true;
        }

        return false;
    };

    /**
     * Returns true if the specified value is an instance of {@link Set}<br>
     * or, if not <i>strict</i>, returns true if the specified value is an array-like object with unique values<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider array-like objects that have unique values as if they are Sets
     *
     * @returns {boolean} true if the specified value is an instance of Set
     *
     * @alias module:TypeUtils.isSet
     */
    const isSet = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof Set;
        }

        if ( isLikeArray( pObject, true ) || pObject?.length >= 0 )
        {
            const length = pObject.length;
            let set = new Set( [...pObject] );
            return set?.size === length;
        }

        return false;
    };

    const MIN_DATE_TIME = -30610202964000; // Approx. year -271821
    const MAX_DATE_TIME = 7258140000000;  // Approx. year 2262

    /**
     * Returns true if the specified object is an instance of Date<br>
     * or if not <i>strict</i>, if the specified object can be converted into a Date<br>
     *
     * @param {*} pObj A value to evaluate
     * @param {boolean} [pStrict=true] Specify false if you want to consider values that can be converted into a Date as Dates<br>
     * @param {Object|function} [pDateParser=null] An optional parameter used to specify a parser to convert strings into Dates
     *
     * @returns {boolean} true if the specified object is an instance of Date
     *
     * @alias module:TypeUtils.isDate
     */
    const isDate = function( pObj, pStrict = true, pDateParser = null )
    {
        if ( isUndefined( pObj ) || isNull( pObj ) )
        {
            return false;
        }

        // Check if input is already a valid Date instance
        if ( pObj instanceof Date || {}.toString.call( pObj ) === "[object Date]" )
        {
            return true;
        }

        if ( pStrict )
        {
            return false;
        }

        // Attempt to create a Date if input is a numeric or object containing a number
        let date = isObject( pObj ) && pObj instanceof Number
                   ? new Date( pObj.valueOf() )
                   : isNumber( pObj )
                     ? new Date( pObj )
                     : null;

        if ( date && isValidDateInstance( date ) )
        {
            return true;
        }

        // Try parsing if input is a string
        if ( isString( pObj ) || pObj instanceof String )
        {
            date = parseDate( pObj, pDateParser );
            if ( isNull( date ) )
            {
                try
                {
                    date = new Date( pObj );
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, `evaluating ${pObj} as a Date`, S_ERROR, modName + "::isDate" );
                }
            }
        }

        // Final fallback check for string, number, or big types
        if ( !date || !isDate( date, true ) )
        {
            switch ( typeof pObj )
            {
                case _str:
                case _num:
                case _big:
                    try
                    {
                        date = new Date( pObj );
                    }
                    catch( ex )
                    {
                        modulePrototype.reportError( ex, `evaluating ${pObj} as a Date`, S_ERROR, modName + "::isDate" );
                    }
                    break;
            }
        }

        return isDate( date, true );
    };

    /**
     * Returns true if the specified value is a valid Date instance.<br>
     * <br>
     * This function validates whether the provided `date` parameter is a non-null object,
     * contains a `getTime` method, and has a timestamp that falls within the predefined
     * minimum (`MIN_DATE_TIME`) and maximum (`MAX_DATE_TIME`) date limits.
     *
     * @param {Object} date - The date object to validate.
     * @returns {boolean} Returns true if the date object is considered valid; otherwise, false.
     */
    const isValidDateInstance = ( date ) => !isNull( date ) &&
                                            isFunction( date.getTime ) &&
                                            !isNanOrInfinite( date.getTime() ) &&
                                            date.getTime() >= MIN_DATE_TIME &&
                                            date.getTime() <= MAX_DATE_TIME;


    /**
     * Parses a given input into a date object using a provided parser or parser object.<br>
     * <br>
     * The function supports custom parsing mechanisms by invoking the `parse` or `parseDate`
     * methods of the parser, or the parser itself, if it is a function.<br>
     * <br>
     * If the input cannot be parsed or an error occurs during parsing,
     * the function dispatches an error event and returns null.
     *
     * @param {*} input - The input to be parsed into a date.
     *
     * @param {Function|Object} dateParser - A function or object responsible for parsing the input.
     *                                       If an object, it should have a `parse` or `parseDate` method.
     *
     * @returns {Date|null} The parsed date object, or null if parsing failed or an error occurs.
     *
     * @alias module:TypeUtils.parseDate
     */
    const parseDate = ( input, dateParser ) =>
    {
        if ( isFunction( dateParser ) || isFunction( dateParser?.parse || dateParser?.parseDate ) )
        {
            try
            {
                return (dateParser.parse || dateParser.parseDate || dateParser).call( dateParser, input );
            }
            catch( ex )
            {
                modulePrototype.reportError( ex, `formatting ${input} as a date`, S_WARN, modName + "::isDate" );
            }
        }
        return null;
    };

    /**
     * Returns true if the specified value is a valid date or a numeric value.<br>
     * <br>
     * This function evaluates if the provided parameter is not null and
     * meets one of the following conditions:
     * - It is a valid date.
     * - It is an integer.
     * - It is a value that can be parsed to a number.
     *
     * @param {*} pDate - The input value to validate.
     * @returns {boolean} Returns true if the input is a valid date, an integer, or a numeric value; otherwise, returns false.
     *
     * @alias module:TypeUtils.isValidDateOrNumeric
     */
    const isValidDateOrNumeric = ( pDate ) => !isNull( pDate ) && (isDate( pDate ) || isInteger( pDate ) || isNumeric( pDate ));

    /**
     * Returns true if the specified value is an instance of RegExp<br>
     * or, if not <i>strict</i>, if the specified value is a string representation of a regular expression<br>
     *
     * @param {*} pObject A value to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider a string representation of a regular expression to be a RegExp
     *
     * @returns {boolean} true if the specified value is an instance of RegExp
     *
     * @alias module:TypeUtils.isRegExp
     */
    const isRegExp = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof RegExp;
        }

        const s = _mt_str + (isString( pObject ) ? String( pObject ) : (isFunction( pObject.toString ) ? pObject.toString() : {}.toString.call( pObject, pObject )));

        let pattern = s.replace( /\/[gimsuy]+$/, "/" ).trim();

        if ( /^\/.+\/$/.test( pattern ) )
        {
            pattern = pattern.replace( /\/$/, _mt_str ).replace( /^\//, _mt_str );

            try
            {
                let regExp = new RegExp( pattern );
                return isRegExp( regExp );
            }
            catch( ex )
            {
                // ignored
            }
        }

        return false;
    };

    /**
     * Returns true if the value passed represents a JavaScript Class<br>
     * JavaScript classes return "function" for the typeof operator,<br>
     * so this function is necessary to determine the difference<br>
     * between a function and a class definition<br>
     *
     * @param {function} pFunction A function to evaluate
     * @param {boolean} [pStrict=true] Specify false to consider built-in types as classes
     *
     * @returns {boolean} true if the function specified is a class definition
     *
     * @alias module:TypeUtils.isClass
     */
    const isClass = function( pFunction, pStrict = true )
    {
        if ( isFunction( pFunction ) || ( !pStrict && BUILTIN_TYPE_NAMES.includes( pFunction?.name )) )
        {
            if ( /^class\s/.test( (Function.prototype.toString.call( pFunction, pFunction )).trim() ) )
            {
                return true;
            }

            return !pStrict && BUILTIN_TYPE_NAMES.includes( pFunction?.name );
        }

        return false;
    };

    /**
     * Returns true if the specified object is an instance of one (or more) of the specified classes<br>
     *
     * @param {Object} pObject An object to evaluate
     * @param pClasses {...function} One or more classes to which to compare the specified object's prototype<br>
     *
     * @returns {boolean} true if the specified object is an instance of one (or more) of the specified classes<br>
     *
     * @alias module:TypeUtils.instanceOfAny
     */
    const instanceOfAny = function( pObject, ...pClasses )
    {
        const classes = ([].concat( ...(pClasses || []) ) || []).filter( e => isClass( e, false ) );

        let is = false;

        while ( !is && classes?.length && isObject( pObject ) )
        {
            const cls = classes.shift();

            if ( isClass( cls, !BUILTIN_TYPE_NAMES.includes( cls?.name ) ) )
            {
                try
                {
                    is = (pObject instanceof cls) || pObject.prototype === cls;
                }
                catch( ex )
                {
                    modulePrototype.reportError( ex, "attempting to call instanceof without a class or callable", S_WARN, modName + "::instanceOfAny" );
                }
            }
        }

        return is;
    };

    /**
     * Returns true if the specified function is a class that is not a built-in JavaScript type<br>
     *
     * @param {function} pFunction A function to evaluate
     *
     * @returns {boolean} true if the specified function is a class that is not a built-in JavaScript type<br>
     *
     * @alias module:TypeUtils.isUserDefinedClass
     */
    const isUserDefinedClass = function( pFunction )
    {
        return isClass( pFunction );
    };

    /**
     * Returns true if the specified function is one or the specified classes<br>
     *
     * @param {function} pFunction A function to evaluate
     * @param {...function} pListedClasses One or more classes to which to compare the specified function<br>
     *
     * @returns {boolean} true if the specified function is one or the specified classes
     *
     * @alias module:TypeUtils.isListedClass
     */
    const isListedClass = function( pFunction, ...pListedClasses )
    {
        return isClass( pFunction ) && instanceOfAny( new pFunction(), ...pListedClasses );
    };

    /**
     * Retrieves the prototype of a provided object or class.
     *
     * This function attempts to determine the prototype of the given input using the following order of precedence:
     * - `Object.getPrototypeOf`.
     * - The `__proto__` property, if available.
     * - The constructor's `prototype` property.
     * - The direct `prototype` property of the input.
     *
     * For classes, it prioritizes retrieving the `prototype` property or the class itself.
     *
     * @param {object|Function} pObject - The object or class for which the prototype is to be determined.
     * @returns {object|null|undefined} The prototype of the given input, or `null`/`undefined` if it cannot be determined or if the input is not valid.
     */
    const getProto = function( pObject )
    {
        if ( isObject( pObject ) )
        {
            return Object.getPrototypeOf( pObject ) || pObject?.__proto__ || pObject?.constructor?.prototype || pObject?.prototype;
        }
        if ( isClass( pObject ) )
        {
            return pObject?.prototype || pObject;
        }
    };

    /**
     * Retrieves the constructor of the provided object or function.
     *
     * This function determines the constructor of a given object or function by
     * checking if the input is a function, a class, or an instance of a class.
     * It attempts to fetch the constructor reference through several fallback methods,
     * including checking the Symbol.species property or the prototype of the input.
     * If the input is not a function or class, it examines the prototype chain to
     * deduce the constructor.
     *
     * @param {Object|Function} pObject - The object or function whose constructor is to be retrieved.
     * @returns {Function|null} The constructor function if found, otherwise null.
     */
    const getConstructor = function( pObject )
    {
        if ( isFunction( pObject ) || isClass( pObject ) )
        {
            return pObject?.constructor || pObject[Symbol.species] || pObject?.prototype;
        }

        const proto = getProto( pObject );

        return proto?.constructor || (isFunction( proto ) ? proto : null);
    };

    /**
     * Returns true if the specified object is an instance of a class that is not a built-in JavaScript type<br>
     *
     * @param {Object} pObject An object to evaluate
     * @param {function} [pClass=null] Specify a specific class to restrict the comparison to a specific user-defined class
     *
     * @returns {boolean} true if the specified object is an instance of a class that is not a built-in JavaScript type
     *
     * @alias module:TypeUtils.isInstanceOfUserDefinedClass
     */
    const isInstanceOfUserDefinedClass = function( pObject, pClass = null )
    {
        let clazz = isClass( pClass ) ? (pClass || getConstructor( pObject ) || getProto( pObject )) : getConstructor( pObject ) || getProto( pObject )?.constructor || getProto( pObject );

        return isUserDefinedClass( clazz ) && (null === clazz || instanceOfAny( pObject, clazz ));
    };

    /**
     * Returns true if the specified object is an instance of one or more of the specified classes
     * <br>
     *
     * @param {Object} pObject An object to evaluate
     * @param {...function} pListedClasses One or more classes to which to compare the specified object's prototype
     *
     * @returns {boolean} true if the specified object is an instance of one or more of the specified classes
     *
     * @alias module:TypeUtils.isInstanceOfListedClass
     */
    const isInstanceOfListedClass = function( pObject, ...pListedClasses )
    {
        return instanceOfAny( pObject, ...pListedClasses );
    };

    /**
     * Returns true if the specified value is an instance of, or is assignable to, one of the specified classes.<br>
     * That is, if the specified value is an instance of one of the classes or one of their subclasses,
     * this function returns true.
     *
     * @param {*} pValue - The value to be checked for assignment compatibility.
     * @param {...Function} pClass - One or more class constructors of which the value must be an instance of or a subclass of in order to return true.
     * If no classes are specified, the constructor of the object to which this function is bound is used.
     * @returns {boolean} - Returns true if the value is assignable to one or more of the specified classes
     */
    const isAssignableTo = function( pValue, ...pClass )
    {
        if ( isNull( pValue ) )
        {
            return false;
        }

        const klasses = isNull( pClass ) ? [this.constructor] : (isArray( pClass ) ? pClass : [pClass]);

        for( let klass of klasses )
        {
            const cls = getClass( klass || this.constructor );

            if ( instanceOfAny( pValue, cls, cls[Symbol.species] ) && !(this === pValue) )
            {
                return true;
            }
        }

        return false;
    };

    function resolveCandidates( ...pCandidates )
    {
        let arr = !isNull( pCandidates ) ? (isArray( pCandidates ) || isSpreadable( pCandidates ) ? [...(pCandidates || [])] : []) : [];
        return (arr.length <= 1) ? arr.flat() : arr;
    }

    /**
     * Returns the first of the candidates that is of the specified type<br>
     * (or null if no candidates meet the criterion)<br>
     *
     * @param  {string|function} pType The type an object must match to be returned
     * @param {...*} pCandidates One or more candidates, the first of which that matches the specified type will be returned
     *
     * @returns {*|null} The first of the candidates that is of the specified type (or null if no candidates meet the criterion)
     *
     * @alias module:TypeUtils.firstMatchingType
     */
    const firstMatchingType = function( pType, ...pCandidates )
    {
        let arr = resolveCandidates( ...pCandidates );

        if ( isString( pType ) )
        {
            const type = pType.trim().toLowerCase();
            arr = VALID_TYPES.includes( type ) ? arr.filter( e => type === typeof e && !isNull( e ) ) : [];
        }
        else if ( isClass( pType, false ) )
        {
            arr = arr.filter( e => e instanceof pType );
        }
        else if ( isObject( pType ) )
        {
            arr = arr.filter( e => e instanceof getClass( pType ) );
        }
        else if ( isFunction( pType ) )
        {
            const scope = $scope();

            try
            {
                arr = arr.filter( e => pType.call( scope, e ) );
            }
            catch( ex )
            {
                modulePrototype.reportError( ex, "attempting to call a function to filter an array", S_WARN, modName + "::firstMatchingType", pType?.name );
            }
        }
        else
        {
            arr = [];
        }

        return arr.length > 0 ? arr[0] : null;
    };

    class Finder
    {
        #filterCriteria = ( e ) => isNonNullValue( e );

        constructor( pFilterCriteria )
        {
            this.#filterCriteria = isFunction( pFilterCriteria ) ? pFilterCriteria : ( e ) => isNonNullValue( e );
        }

        findAll( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            return arr.filter( this.#filterCriteria );
        }

        findFirst( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            arr = this.findAll( ...pCandidates );
            return arr.length > 0 ? arr[0] : null;
        }

        findAllNot( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            return arr.filter( e => !this.#filterCriteria( e ) );
        }

        findFirstNot( ...pCandidates )
        {
            let arr = resolveCandidates( ...pCandidates );
            arr = this.findAllNot( ...pCandidates );
            return arr.length > 0 ? arr[0] : null;
        }
    }

    /**
     * Returns the class (function) of which the specified object is an instance
     * <br>
     * or the class itself if the specified value <i>is</i> a class (function)
     * <br>
     * @param {Object|function} pObject An instance of some class or a function that is a class
     * @param {Object} pOptions An object to pass options to the isClass method of TypeUtils
     *
     * @returns {function} The class of which the object is an instance
     *                     or the class itself if the object is a class function
     *
     * @alias module:TypeUtils.getClass
     */
    const getClass = function( pObject, pOptions = { strict: true } )
    {
        const options = Object.assign( { strict: true }, pOptions || {} );

        const obj = isObject( pObject, { rejectPrimitiveWrappers: false } ) || isFunction( pObject ) ? pObject || function() {} : null;

        if ( isNull( obj, true ) )
        {
            return null;
        }

        const strict = options?.strict;

        let clazz = isClass( obj, strict ) ? obj : obj?.constructor || obj?.prototype?.constructor || obj?.prototype || obj?.__proto__;

        if ( isClass( clazz, strict ) )
        {
            return clazz;
        }

        if ( obj )
        {
            if ( isClass( obj, strict ) )
            {
                clazz = obj;
            }

            if ( isClass( clazz, strict ) )
            {
                return clazz;
            }

            let _class = clazz;

            const iterationLimit = 5;
            let iterations = 0;

            // the IterationCap object will return reached when iterations exceed the cap,
            // so ignore the linter warnings
            // noinspection LoopStatementThatDoesntLoopJS
            while ( !isClass( _class, strict ) && (iterations++ <= iterationLimit) )
            {
                switch ( iterations )
                {
                    case 0:
                    case 1:
                        _class = (obj.constructor || obj?.prototype?.constructor) || _class;
                        break;

                    case 2:
                        _class = (obj?.prototype?.constructor || isClass( obj?.prototype, strict ) ? obj?.prototype : _class);
                        break;

                    case 3:
                        _class = isClass( obj?.prototype, strict ) ? obj?.prototype : _class;
                        break;

                    case 4:
                        _class = isClass( obj?.__proto__, strict ) ? obj?.__proto__ : _class;
                        break;

                    default:
                        break;
                }
            }

            clazz = (isClass( _class, strict ) ? _class : (isClass( clazz, strict ) ? clazz : (isClass( clazz ) ? clazz : Object))) || Object;

            if ( clazz && Object === clazz )
            {
                if ( obj instanceof Date )
                {
                    clazz = Date;
                }
                else if ( obj instanceof RegExp )
                {
                    clazz = RegExp;
                }
                else if ( obj instanceof Boolean )
                {
                    clazz = Boolean;
                }
                else if ( obj instanceof String )
                {
                    clazz = String;
                }
                else if ( obj instanceof Number )
                {
                    clazz = Number;
                }
            }
        }

        return clazz;
    };

    /**
     * Returns the name of the class of which the specified object is an instance
     * <br>
     * or the name of the class if the specified value <i>is</i> a class (function)
     * <br>
     * @param {Object|function} pObject An instance of some class or a function that is a class
     *
     * @returns {string} The name of the class of which the object is an instance
     * or the name of the class if the object is a class function
     *
     * @alias module:TypeUtils.getClassName
     */
    const getClassName = function( pObject )
    {
        const obj = isObject( pObject, { rejectPrimitiveWrappers: false } ) || isFunction( pObject ) ? pObject || function() {} : null;

        if ( isNull( obj, true ) )
        {
            return _mt_str;
        }

        let name = _mt_str;

        if ( obj )
        {
            if ( isClass( obj, false ) )
            {
                name = String( obj.name || (obj.constructor?.name) );
            }
            else if ( isObject( obj ) )
            {
                const clazz = getClass( obj, { strict: false } );
                if ( clazz )
                {
                    name = getClassName( clazz );
                }
            }

            if ( (_mt_str === name.trim()) )
            {
                name = String( obj?.constructor?.name || obj?.prototype?.constructor?.name || obj?.prototype?.name );
            }
        }

        return name;
    };

    /**
     * Returns the default value for the type specified
     *
     * @param {string} pType The type for which to return a default value
     * @see {@link TYPE_DEFAULTS}
     * @returns {*}
     *
     * @alias module:TypeUtils.defaultFor
     */
    const defaultFor = function( pType )
    {
        let type = isString( pType ) ? (_mt_str + pType).trim().toLowerCase() : typeof (pType);
        return (isString( type ) && JS_TYPES.includes( type )) ? TYPE_DEFAULTS[type] : defaultFor( typeof type );
    };

    /**
     * @typedef {object} CastOptions
     *
     * @property {string} propertyKey
     * @property {function} nullOrUndefined: defaultFor
     * @property {Array.<string>} reduceArrayFor: [_num, _big, _bool]
     * @property {boolean} preserveArrayForCastToObject: true
     * @property {string} joinOn: _mt_str
     * @property {boolean} executeFunctions: true
     * @property {object} bindFunctionsTo: null
     * @property {Array.<*>} passToFunctions: []
     * @property {object|function} dateFormatter: null
     * @property {object|function} dateParser: null
     *
     */

    /**
     * A constant object defining the default options for casting operations.
     *
     * @constant {Object} DEFAULT_CAST_OPTIONS
     * @type {CastOptions}
     * @property {string} propertyKey - The default key to use when accessing properties for casting.
     * @property {Function} nullOrUndefined - A function to handle default values for null or undefined inputs.
     * @property {Array} reduceArrayFor - An array of types to attempt reduction for when casting arrays.
     * @property {boolean} preserveArrayForCastToObject - Determines whether to preserve arrays when casting to objects.
     * @property {string} joinOn - A delimiter string used when joining array values into a single string during casting.
     * @property {boolean} executeFunctions - Indicates whether to execute functions during the casting process.
     * @property {Object|null} bindFunctionsTo - If specified, binds functions to this object during execution.
     * @property {Array} passToFunctions - Functions to be passed during casting operations.
     * @property {Function|null} dateFormatter - A function to format date objects during casting, or null for default behavior.
     * @property {Function|null} dateParser - A function to parse date strings during casting, or null for default behavior.
     */
    const DEFAULT_CAST_OPTIONS =
        {
            propertyKey: _mt_str,
            nullOrUndefined: defaultFor,
            reduceArrayFor: [_num, _big, _bool],
            preserveArrayForCastToObject: true,
            joinOn: _mt_str,
            executeFunctions: true,
            bindFunctionsTo: null,
            passToFunctions: [],
            dateFormatter: null,
            dateParser: null,
        };

    /**
     * CastUtils is a utility class designed for consistent type casting and transformations between various data types.
     * The class supports a range of type conversions while providing flexibility and customization through options.
     *
     * @class
     * @private
     */
        // noinspection JSPrimitiveTypeWrapperUsage
    class CastUtils
    {
        #toType;
        #originalValue;
        #value;
        #key;
        #options;

        #numericFilter = e => isValidDateOrNumeric( e ) || isBoolean( e );
        #toNumber = e => isDate( e ) ? attempt( () => e.getTime() ) : (isBoolean( e ) ? (e ? 1 : 0) : toDecimal( e ));

        constructor( pValue, pToType, pOptions = DEFAULT_CAST_OPTIONS )
        {
            this.#options = populateOptions( pOptions || {}, DEFAULT_CAST_OPTIONS );

            this.#key = this.#options?.propertyKey || _mt_str;

            this.#toType = isString( pToType ) ? (String( _mt_str + pToType ).trim().toLowerCase()) : typeof (pToType);
            this.#toType = isString( this.#toType ) && VALID_TYPES.includes( this.#toType ) ? this.#toType : _str;

            this.#originalValue = pValue;

            this.#value = this.initializeValue( pValue );
        }

        get toType()
        {
            return String( this.#toType || _str ).trim().toLowerCase();
        }

        get value()
        {
            let val = isPromise( this.#value ) ? Promise.resolve( this.#value ).then( ( pResult ) => this.#value = pResult ) : this.#value;
            return isPromise( val ) ? this.#originalValue : val;
        }

        get key()
        {
            return String( this.#key || _mt_str ).trim();
        }

        get options()
        {
            return populateOptions( this.#options || {}, DEFAULT_CAST_OPTIONS );
        }

        get numericFilter()
        {
            return this.#numericFilter;
        }

        get toNumber()
        {
            return this.#toNumber;
        }

        arrToNumber( pArr )
        {
            return [...(pArr || [])].flat( Infinity ).filter( this.#numericFilter ).map( this.#toNumber ).reduce( ( acc, e ) => acc + toDecimal( e ), 0 );
        }

        initializeValue( pValue )
        {
            const me = this;
            const type = this.#toType || _str;

            let value = pValue;

            if ( _ud === typeof pValue || isNull( pValue, true ) )
            {
                const nullOrUndefined = this.#options?.nullOrUndefined;
                value = isFunction( nullOrUndefined ) ? attempt( () => nullOrUndefined?.call( me, type ) ) : null;
            }

            if ( this.#toType === typeof value )
            {
                this.#value = value;
                return value;
            }

            const reduceArrayForTypes = [...(this.#options?.reduceArrayFor || [])].filter( e => isString( e ) && VALID_TYPES.includes( e.trim().toLowerCase() ) );

            if ( isArray( value ) && reduceArrayForTypes?.includes( this.#toType ) )
            {
                value = this.reduceArray( [...(value)] || [] );
            }

            if ( _fun !== this.#toType && isFunction( value ) )
            {
                value = this.executeFunctions( value );
            }

            this.#value = value;

            return value;
        }

        executeFunctions( pValue )
        {
            const me = this;

            let value = pValue || this.#value || this.#originalValue;

            if ( _fun !== this.#toType && isFunction( value ) && this.#options?.executeFunctions )
            {
                let args = [...(this.#options?.passToFunctions || [])];

                let bindTo = this.#options?.bindFunctionsTo || me || this;

                let result = attempt( () => value.call( bindTo, ...args ) );

                result = (isPromise( result ) ? asyncAttempt( async() => result.then( e => e ).then( value => me.initializeValue( value ) ) ) : result);

                value = isPromise( result ) ? value : result;
            }

            return value;
        }

        reduceArray( pArray )
        {
            if ( !isLikeArray( pArray ) )
            {
                return pArray;
            }

            const me = this;

            let value = [...(pArray || this.#value || [])];

            value = [_num, _big, _bool].includes( this.#toType ) ? attempt( () => (me || this).arrToNumber( value ) ) : value;

            value = this.#toType === _str ? pArray.map( e => String( _mt_str + e ) ).join( this.#options?.joinOn || _mt_str ) : value;

            value = this.#toType === _symbol ? pArray.map( e => (isSymbol( e ) ? e : Symbol.for( e ) || Symbol( e )) ) : value;

            value = this.#toType === _obj ? (!this.#options?.preserveArrayForCastToObject ? { ...(objectValues( value ).flat()) } : value) : value;

            value = this.#toType === _fun ? isArray( value ) ? [...(value || [])].map( e => isFunction( e ) ? e : () => e ) : value : value;

            return value;
        }

        castToBoolean( pValue )
        {
            let value = pValue || this.value || this.#originalValue;

            if ( isBoolean( value ) )
            {
                return value;
            }

            if ( isFunction( Boolean.evaluate ) )
            {
                value = attempt( () => Boolean.evaluate( value ) );
            }

            if ( isFunction( value ) )
            {
                const me = this;
                let args = [...(this.#options?.passToFunctions || [])];
                let bindTo = this.#options?.bindFunctionsTo || me || this;
                value = attempt( () => value.call( bindTo, ...args ) );
            }

            value = isDate( value ) || isFunction( value?.getTime ) ? attempt( () => value.getTime() ) : value;

            value = isArray( value ) ? this.arrToNumber( value ) : value;

            value = isObject( value ) ? attempt( () => Object.keys( value || {} ).length > 0 ) : value;

            value = isString( value ) && [...(_affirmatives || [])].includes( String( value ).trim().toLowerCase() ) ? true : value;

            value = isNumeric( value ) ? (toDecimal( value ) > 0) : value;

            return Boolean( value );
        }

        castToNumber( pValue, pAsBigInt = false )
        {
            let value = pValue || this.value;

            value = isSymbol( value ) ? 0 : value;
            value = isPrimitiveWrapper( value ) ? attempt( () => value.valueOf() ) : value;
            value = isArray( value ) ? this.arrToNumber( value ) : value;
            value = isNumeric( value ) ? toDecimal( value ) : value;
            value = isBoolean( value ) ? (value ? 1 : 0) : value;
            value = isDate( value ) ? attempt( () => value.getTime() ) : value;
            value = (isFunction( value?.asFloat )) ? attempt( () => value.asFloat() ) : toFloat( value );

            return pAsBigInt ? BigInt( parseInt( toDecimal( value ) ) ) : toDecimal( Number( value ) );
        }

        castToString( pValue )
        {
            let value = pValue || this.value;

            value = isPrimitiveWrapper( value ) ? attempt( () => value.valueOf() ) : value;

            value = isDate( value ) ? this.castDateToString( value ) || value : value;

            value = isFunction( value ) ? attempt( () => Function.prototype.toString.call( value, value ) ) : value;

            value = isArray( value ) ? [...(value || [])].map( e => this.castToString( e ) ).join( this.options?.joinOn ) : value;

            value = isNumeric( value ) ? String( toDecimal( value ) ) : value;

            value = isFunction( value?.asString ) ? attempt( () => value.asString() ) : value;

            const prior = value || pValue || this.value;

            value = isFunction( value?.toString ) ? attempt( () => value.toString() ) : value;

            if ( "[object Object]" === String( value ) )
            {
                value = attempt( () => JSON.stringify( prior || {} ) ) || "{}";
            }

            return _mt_str + String( value );
        }

        castDateToString( pDate, pDateFormatter )
        {
            let date = pDate || this.value;

            let str = isDate( date ) ? attempt( () => date.toISOString() ) : _mt_str;

            if ( isValidDateOrNumeric( date ) )
            {
                date = new Date( toDecimal( date?.getTime ? (attempt( () => date.getTime() ) || date) : date ) );

                const dateFormatter = pDateFormatter || this.options?.dateFormatter || (function( pDate ) { return isDate( pDate ) ? pDate?.toISOString() || _mt_str : String( pDate ); });

                const formatter = isFunction( dateFormatter?.format ) ? dateFormatter.format : dateFormatter;

                str = isFunction( formatter ) ? attempt( () => formatter.call( dateFormatter, date ) ) : str;
            }

            return str || attempt( () => (date || pDate).toISOString() );
        }

        castToDate( pValue, pDateParser )
        {
            let value = pValue || this.value;

            if ( isDate( value ) )
            {
                return new Date( value );
            }

            if ( isValidDateOrNumeric( value ) )
            {
                return new Date( parseInt( toDecimal( value ) ) );
            }

            if ( isString( value ) )
            {
                const dateParser = pDateParser || this.options.dateParser || (function( pVal ) { return isString( pVal ) ? attempt( () => new Date( pVal ) ) : null; });

                const parser = isFunction( dateParser?.parse ) ? dateParser?.parse : (isFunction( dateParser?.parseDate ) ? dateParser.parseDate : dateParser);

                const date = isFunction( parser ) ? attempt( () => parser.call( dateParser, value ) ) : null;

                return !isNaN( date ) && isDate( date ) ? date : null;
            }

            modulePrototype.reportError( new Error( "unable to parse date" ), "attempting to parse date", S_WARN, modName + "::castToDate", value );

            return null;

        }

        castToObject( pValue, pPropertyKey )
        {
            const me = this;

            let value = pValue || this.value;
            let key = pPropertyKey || this.key;

            if ( _ud === typeof pValue || isNull( pValue, true ) )
            {
                const nullOrUndefined = this.#options?.nullOrUndefined;
                value = isFunction( nullOrUndefined ) ? attempt( () => nullOrUndefined?.call( me, this.toType ) ) : null;
            }

            value = isArray( value ) ? (this.options?.preserveArrayForCastToObject ? value : { ...(objectValues( value ).flat()) }) : value;

            if ( isFunction( value ) )
            {
                return this.objectFromFunction( value, key );
            }

            if ( isSymbol( value ) )
            {
                return { value };
            }

            if ( isEmptyString( key ) )
            {
                value = this.boxPrimitive( value );
            }
            else
            {
                value = { [key]: value };
            }

            return value;
        }

        boxPrimitive( pValue )
        {
            let value = pValue || this.value;
            // noinspection JSPrimitiveTypeWrapperUsage
            value = isString( pValue ) ? new String( value ) : value;
            // noinspection JSPrimitiveTypeWrapperUsage
            value = isBoolean( pValue ) ? new Boolean( value ) : value;
            return isNumber( value ) ? _big === this.toType ? new Number( BigInt( parseInt( value ) ) ) : new Number( value ) : value;
        }

        objectFromFunction( pValue, pKey = _mt_str )
        {
            let value = pValue || this.value;
            let key = pKey || this.key;

            if ( isFunction( value ) )
            {
                value =
                    {
                        apply: ( pThis, ...pArgs ) => value.apply( pThis || $scope(), [...pArgs] ),
                        call: ( pThis, ...pArgs ) => value.call( pThis || $scope(), ...pArgs ),
                    };
            }

            if ( !isEmptyString( key ) )
            {
                value[key] = value;
            }

            return value;
        }

        castToFunction( pValue, pAsynchronous = false )
        {
            let value = pValue || this.value;

            if ( isFunction( value ) )
            {
                if ( pAsynchronous )
                {
                    return isAsyncFunction( value ) ? value : () => asyncAttempt( () => value() );
                }
                return value;
            }

            return pAsynchronous ? isAsyncFunction( value ) ? value : () => asyncAttempt( () => value ) : () => attempt( () => value );
        }

        castToSymbol( pValue )
        {
            let value = pValue || this.value;
            return isSymbol( value ) ? value : (isString( value ) ? Symbol.for( String( _mt_str + value ) ) || Symbol( String( _mt_str + value ) ) : null);
        }

        cast( pValue )
        {
            let value = isNonNullValue( pValue ) || isNonNullObject( pValue ) ? pValue : (pValue || this.value);

            if ( this.toType === typeof value )
            {
                return value;
            }

            switch ( this.toType )
            {
                case _num:
                case _big:
                    return this.castToNumber( value, _big === this.toType );

                case _bool:
                    return this.castToBoolean( value );

                case _str:
                    return this.castToString( value );

                case _obj:
                    return this.castToObject( value );

                case _fun:
                    return this.castToFunction( value );

                case _symbol:
                    return this.castToSymbol( value );

                default:
                    break;
            }

        }
    }

    /**
     * Returns a new value converted to the specified type, if possible
     * <br>
     * @param {*} pValue A value to convert to the specified type
     * @param {string} pType The type to which to convert the specified value, if possible
     *
     * @param pOptions
     * @returns {*} a new value converted to the specified type, if possible
     *
     * @alias module:TypeUtils.castTo
     */
    const castTo = function( pValue, pType, pOptions = DEFAULT_CAST_OPTIONS )
    {
        const castUtils = new CastUtils( pValue, pType, pOptions );

        return castUtils.cast();
    };

    /**
     * Similar to the SQL function,
     * returns the first defined/non-null value that is also not NaN or Infinity.
     *
     * If all values are null, undefined, or NaN, or =/-Infinity, returns null.
     *
     *
     * @param {...*} pValue - One or more variables of any type, the first of which that is not null or undefined will be returned.
     * @returns {*} - The first value that is not null, undefined, NaN, or Infinity.
     * If all specified values are either null, undefined, NaN, or Infinity, returns null.
     */
    const NVL = function( ...pValue )
    {
        let arr = [...(pValue || [])];
        arr = arr.filter( isNonNullValue );
        arr = arr.filter( e => !isNumber( e ) || !isNanOrInfinite( e ) );
        return arr.length > 0 ? arr[0] : null;
    };

    /**
     * This class can be used to convert any non-null value into an iterable.
     * <br>
     * Unlike JavScript's built-in iterators, this class's iterator can be traversed in reverse and/or reset
     * <br>
     *
     * alias module:TypeUtils._Iterable
     *
     * @class
     *
     * @protected
     */
    class _Iterable
    {
        #iterable;
        #arrayLike;
        #iterator;
        #index = 0;

        #iterated = [];

        /**
         * @constructor
         *
         * @param {*} pIterable Any value to be treated as an iterable
         *
         * @return {_Iterable} A new iterable that can be used to iterate the value(s) with which it was constructed
         */
        constructor( pIterable )
        {
            this.#iterable = isIterable( pIterable ) ? pIterable : [pIterable];
            this.#iterable = isString( this.#iterable ) ? [].concat( this.#iterable.split( _mt_str ) ) : this.#iterable;

            if ( isLikeArray( this.#iterable ) )
            {
                this.#arrayLike = [...this.#iterable];
            }
            else if ( isMap( this.#iterable ) || isSet( this.#iterable ) )
            {
                this.#arrayLike = [...this.#iterable.values()];
            }

            if ( isIterable( this.#iterable ) )
            {
                this.#iterator = this.#iterable[Symbol.iterator]();
            }
        }

        [Symbol.species]()
        {
            return this;
        }

        [Symbol.iterator]()
        {
            return this;
        }

        next()
        {
            if ( this.#arrayLike?.length )
            {
                if ( this.#index >= this.#iterable.length )
                {
                    return { done: true };
                }

                const value = this.#iterable[this.#index++];

                this.#iterated.push( value );

                return { value, done: false };
            }

            return this.#iterator?.next();
        }

        previous()
        {
            if ( this.#index > 0 )
            {
                if ( this.#arrayLike?.length )
                {
                    const value = this.#iterable[--this.#index];
                    return { value, done: false };
                }
                return this.#iterated[--this.#index];
            }
            return { done: true };
        }

        reset()
        {
            this.#index = 0;
        }

        reverseIterator()
        {
            if ( this.#arrayLike?.length )
            {
                let newIterable = [...this.#iterable].reverse();
                return new this.constructor( newIterable );
            }
            modulePrototype.reportError( new Error( "cannot reverse this iterator" ), "attempting to reverse an iterator", S_ERROR, modName + "::_Iterable::reverseIterator" );
            return this.#iterated.reverse();
        }
    }

    /**
     * A wrapper class to adapt a synchronous iterator into an asynchronous iterator wrapper.<br>
     * Provides asynchronous iteration capabilities for iterables or iterators.<br>
     */
    class _AsyncIterator
    {
        #iterator;

        constructor( pIterator )
        {
            this.#iterator = pIterator;
        }

        async next()
        {
            return await this.#iterator.next();
        }

        [Symbol.asyncIterator]()
        {
            return this;
        }

        [Symbol.iterator]()
        {
            return this.#iterator;
        }
    }

    /**
     * This subclass of _Iterable just returns done immediately
     * @class
     * @extends _Iterable
     *
     * alias module:TypeUtils.NullIterator
     *
     * @protected
     *
     */
    class NullIterator extends _Iterable
    {
        constructor()
        {
            super( [] );
        }

        next()
        {
            return { done: true };
        }

        previous()
        {
            return { done: true };
        }
    }

    /**
     * Returns an _Iterable for the specified value
     *
     * @param pArrayLike almost any kind of value,
     *                   but generally expected to be an "indexable" collection of values
     *                   strings are converted into an array of characters,
     *                   scalar values are converted into a 1-element array containing the value
     *
     * @param {boolean} pAsync Pass true to create an AsyncIterable
     *
     * @returns {_AsyncIterator|_Iterable} an instance of _Iterable or _AsyncIterator
     */
    const toIterable = function( pArrayLike, pAsync = false )
    {
        let iterable = null;

        switch ( typeof pArrayLike )
        {
            case _ud:
                iterable = new NullIterator();
                break;

            case _str:
                iterable = new _Iterable( pArrayLike.split( _mt_str ) );
                break;

            case _num:
            case _big:
            case _bool:
                iterable = new _Iterable( [pArrayLike] );
                break;

            case _fun:
                if ( isGeneratorFunction( pArrayLike ) )
                {
                    iterable = pArrayLike();
                }
                else
                {
                    iterable = new _Iterable( [pArrayLike] );
                }
                break;

            case _obj:
                if ( isArray( pArrayLike ) )
                {
                    iterable = new _Iterable( pArrayLike );
                }
                else if ( pArrayLike instanceof Map )
                {
                    iterable = new _Iterable( [...pArrayLike.entries()] );
                }
                else if ( pArrayLike instanceof Set )
                {
                    iterable = new _Iterable( [...pArrayLike] );
                }
                else if ( isDate( pArrayLike ) )
                {
                    iterable = new _Iterable( [pArrayLike] );
                }
                else if ( isIterable( pArrayLike ) )
                {
                    iterable = new _Iterable( pArrayLike );
                }
                else
                {
                    const newObject = {};

                    const entries = Object.entries( pArrayLike );

                    for( let entry of entries )
                    {
                        const key = entry[0];

                        const value = entry[1];

                        newObject[key] = toIterable( value );
                    }

                    iterable = new _Iterable( Object.entries( newObject ) );
                }
                break;

            default:
                iterable = new NullIterator();
        }

        return pAsync ? new _AsyncIterator( iterable ) : iterable;
    };

    /**
     * This class represents the common, functional programming inspired, Option or Maybe type<br>
     * @see https://en.wikipedia.org/wiki/Option_type
     *
     * @class
     *
     * @alias module:TypeUtils#classes#Option
     *
     */
    class Option
    {
        #value;

        constructor( pValue )
        {
            this.#value = (pValue instanceof this.constructor) ? pValue.#value : pValue;
        }

        get value()
        {
            return lock( this.#value );
        }

        static Some( pValue )
        {
            return new Option( pValue );
        }

        static None()
        {
            return new Option( null );
        }

        isSome()
        {
            return (null !== this.#value);
        }

        isNone()
        {
            return isUndefined( this.#value ) || null === this.#value;
        }

        map( pFunction )
        {
            const func = isFunction( pFunction ) ? pFunction : ( e ) => e;
            return this.isSome() ? Option.Some( func( this.#value ) ) : Option.None();
        }

        flatMap( pFunction )
        {
            const func = isFunction( pFunction ) ? pFunction : ( e ) => e;
            return this.map( func ).getOrElse( Option.None() );
        }

        getOrElse( pDefault )
        {
            return this.isSome() ? this.value : pDefault;
        }
    }

    /**
     * This class extends Option and requires that the 'Some' value be of the type specified<br>
     *
     * @class
     * @extends Option
     *
     * @alias module:TypeUtils#classes#TypedOption
     */
    class TypedOption extends Option
    {
        #type;

        constructor( pValue, pType )
        {
            super( pValue );

            this.#type = pType || typeof (pValue);
        }

        get type()
        {
            return this.#type || _obj;
        }

        static Some( pValue, pType )
        {
            return new TypedOption( pValue, pType );
        }

        static None()
        {
            return new Option( null );
        }

        isSome()
        {
            return super.isSome() && isType( this.value, this.type );
        }

        isNone()
        {
            return super.isNone() || !isType( this.value, this.type );
        }

        map( pFunction )
        {
            const type = this.type;

            const func = isFunction( pFunction ) ? pFunction : ( e ) => castTo( e, type );

            return super.map( func );
        }

        flatMap( pFunction )
        {
            const type = this.type;

            const func = isFunction( pFunction ) ? pFunction : ( e ) => castTo( e, type );

            return super.flatMap( func );
        }

        getOrElse( pDefault )
        {
            const value = super.getOrElse( pDefault );

            if ( this.type === typeof (value) )
            {
                return value;
            }

            if ( this.type === typeof (pDefault) )
            {
                return pDefault;
            }
        }
    }

    /**
     * This class extends TypedOption and requires that the 'Some' value be a string<br>
     *
     * @class
     *
     * @extends TypedOption
     *
     * @alias module:TypeUtils#classes#StringOption
     */
    class StringOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _str );
        }
    }

    /**
     * This class extends TypedOption and requires that the 'Some' value be a number
     * <br>
     * @class
     * @extends TypedOption
     * @alias module:TypeUtils#classes#NumericOption
     */
    class NumericOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _num );
        }
    }

    /**
     * This class extends TypedOption and requires that the 'Some' value be a boolean
     * <br>
     * @class
     * @extends TypedOption
     * @alias module:TypeUtils#classes#BooleanOption
     */
    class BooleanOption extends TypedOption
    {
        constructor( pValue )
        {
            super( pValue, _bool );
        }
    }

    /**
     * This class represents the return value of a function<br>
     * that might return null or throw exceptions<br>
     * <br>
     * This class extends Option,<br>
     * so you can use getOrElse or check for isSome or isNone,<br>
     * as well as check for whether the function has thrown an error
     * <br>
     * <br>
     * Functions that return a Result<br>
     * should catch errors and then add them to the Result before returning,<br>
     * rather than throw an Error<br>
     * <br>
     * This style of programming can reduce the effort of checking for null
     * <br>
     * or of wrapping function calls in try/catch blocks
     * <br>
     *
     * @class
     * @extends Option
     * @alias module:TypeUtils#classes#Result
     */
    class Result extends Option
    {
        #exceptions = [];

        constructor( pValue, pErrors = [] )
        {
            super( pValue );

            this.#exceptions = [].concat( pErrors || [] ).flat();
        }

        get returnValue()
        {
            return super.getOrElse( null );
        }

        get exceptions()
        {
            return [].concat( this.#exceptions ).flat();
        }

        get errors()
        {
            return this.exceptions;
        }

        addErrors( ...pError )
        {
            this.#exceptions.push( ...pError );
            this.#exceptions = this.#exceptions.flat();
        }

        hasErrors()
        {
            return (this.#exceptions?.length || 0) > 0;
        }
    }

    /**
     * Returns a valid Date object based on the specified value.<br>
     * If the specified value is a valid Date, returns that value,
     * otherwise, returns the current Date.
     *
     * @param {*} pNow - The input value to be resolved. It can be a date, numeric timestamp,
     *                   or any other data type.
     *
     * @returns {Date}   A Date object derived from the input.
     *                   If the input is:
     *                 - A valid Date object, it is returned as-is.
     *                 - A numeric timestamp, it is converted to a Date object.
     *                   If the timestamp does not result in a valid date, the current date is returned.
     *                 - Any other data type, the current date is returned.
     */
    const resolveMoment = ( pNow ) => isDate( pNow ) ? pNow : (isNumeric( pNow ) ? (isDate( new Date( pNow ) ) ? new Date( pNow ) : new Date()) : new Date());

    /**
     * Returns true if the specified value is a directory entry object.<br>
     * <br>
     * A directory entry is an object matching the structure of the objects returned by Node.js or Deno
     * when reading a directory with file types=true.<br>
     * <br>
     * This function checks if the provided object represents a directory entry,
     * considering both Deno's `DirEntry` structure and Node.js's `Dirent`.
     * For Deno `DirEntry`, the object must have a `name` property and include
     * the boolean properties `isFile`, `isDirectory`, and `isSymLink`.
     * For Node.js `Dirent`, the object must have the `name` property and
     * include the methods `isFile`, `isDirectory`, and `isSymbolicLink`.
     *
     * @param {Object} pEntry - The input to be evaluated as a possible directory entry.
     *
     * @returns {boolean} - Returns true if the input is a valid directory entry object, otherwise false.
     *
     * @alias module:TypeUtils.isDirectoryEntry
     */
    const isDirectoryEntry = function( pEntry )
    {
        if ( isNull( pEntry ) || !isNonNullObject( pEntry ) )
        {
            return false;
        }

        const keys = objectKeys( pEntry );

        if ( keys.includes( "name" ) )
        {
            // check for Deno.DirEntry
            if ( keys.includes( "isFile" ) && keys.includes( "isDirectory" ) && keys.includes( "isSymLink" ) )
            {
                return true;
            }

            // check for Node.js Dirent
            return !!(isFunction( pEntry?.isFile ) &&
                      isFunction( pEntry?.isDirectory ) &&
                      isFunction( pEntry?.isSymbolicLink ));
        }

        return false;
    };

    /**
     * Returns true if the specified value is an instance of ArrayBuffer.<br>
     * <br>
     * This function evaluates whether the given parameter is an object
     * of type ArrayBuffer. It ensures that ArrayBuffer is defined and
     * accessible before performing the instance check. If the environment
     * does not support ArrayBuffer, the function returns false.
     *
     * @param {*} pValue - The value to be checked against ArrayBuffer.
     * @returns {boolean} True if the value is an instance of ArrayBuffer, otherwise false.
     *
     * @alias module:TypeUtils.isArrayBuffer
     */
    const isArrayBuffer = ( pValue ) => (_ud !== typeof ArrayBuffer && pValue instanceof ArrayBuffer);

    /**
     * Returns true if the specified value is an instance of SharedArrayBuffer.<br>
     * <br>
     * This function evaluates whether the given parameter is an object
     * of type SharedArrayBuffer. It ensures that SharedArrayBuffer is defined and
     * accessible before performing the instance check. If the environment
     * does not support SharedArrayBuffer, the function returns false.
     *
     * @param {*} pValue - The value to be checked against SharedArrayBuffer.
     * @returns {boolean} True if the value is an instance of SharedArrayBuffer, otherwise false.
     *
     * @alias module:TypeUtils.isSharedArrayBuffer
     */
    const isSharedArrayBuffer = ( pValue ) => (_ud !== typeof SharedArrayBuffer && pValue instanceof SharedArrayBuffer);

    /**
     * Returns true if the specified value is an instance of DataView.<br>
     * <br>
     * This function evaluates whether the given parameter is an object
     * of type DataView. It ensures that DataView is defined and
     * accessible before performing the instance check. If the environment
     * does not support DataView, the function returns false.
     *
     * @param {*} pValue - The value to be checked against DataView.
     * @returns {boolean} True if the value is an instance of DataView, otherwise false.
     *
     * @alias module:TypeUtils.isArrayBuffer
     */
    const isDataView = ( pValue ) => (_ud !== typeof DataView && pValue instanceof DataView);

    /**
     * Applies Array.flat to the variable number of values
     * @param {...*} pArgs One or more values, treated as an array
     * @returns {FlatArray<*[], 1>[]} An array of the values passed, flattening one level of nested arrays
     */
    function flattened( ...pArgs )
    {
        if ( isArray( pArgs ) || isLikeArray( pArgs ) )
        {
            return [...(pArgs || [])].flat();
        }

        if ( isNonNullObject( pArgs ) )
        {

        }
    }

    /**
     * Applies Array.flat(Infinity) to the variable number of values
     * @param {...*} pArgs One or more values, treated as an array
     * @returns {FlatArray<*[], 1>[]} An array of the values passed, flattening all nested arrays
     */
    function explode( ...pArgs )
    {
        return [...(pArgs || [])].flat( Infinity );
    }

    /**
     * Aligns a given number of bits to the nearest valid byte boundary.
     * Valid byte boundaries are 8, 16, 32, and 64 for all supported environments
     *
     * @param {number} pNumBits - The number of bits to align.
     * @return {number} The aligned byte size, clamped between 8 and 64.
     */
    function alignToBytes( pNumBits )
    {
        let numBits = clamp( isNumeric( pNumBits ) ? toDecimal( pNumBits || 8 ) : 8, 8, 64 );

        let necessary = (numBits > 8 ? (numBits > 16 ? (numBits > 32 ? 64 : 32) : 16) : 8);

        return clamp( necessary, 8, 64 );
    }

    /**
     * Calculates the minimum number of bits required to represent a range of values
     * between the specified minimum and maximum values.
     *
     * @param {number|string} pMinValue The minimum value of the range, can be either a number or a numeric string.
     * @param {number|string} pMaxValue The maximum value of the range, can be either a number or a numeric string.
     * @return {number} The minimum number of bits required to represent the values in the specified range,
     * including a sign bit if necessary.
     *
     * @alias module:TypeUtils.calculateBitsNeeded
     */
    function calculateBitsNeeded( pMinValue, pMaxValue )
    {
        // protect against non-numeric input
        let minValue = isNumeric( pMinValue ) ? toDecimal( pMinValue ) : isNumeric( pMaxValue ) ? toDecimal( pMaxValue ) : 0;
        let maxValue = isNumeric( pMaxValue ) ? toDecimal( pMaxValue ) : isNumeric( pMinValue ) ? toDecimal( pMinValue ) : 0;

        minValue = Math.min( minValue, maxValue );
        maxValue = Math.max( minValue, maxValue );

        //use the largest absolute value to calculate the minimum required bits
        const num = Math.max( Math.abs( minValue ), Math.abs( maxValue ) );

        // take the ceiling of the base-2 logarithm of the absolute value
        let bitsNeeded = num === 0 ? 1 : Math.ceil( Math.log2( Math.abs( num ) ) );

        // add 1 for a sign bit if either value is negative
        bitsNeeded += (minValue < 0 || maxValue < 0 ? 1 : 0);

        return bitsNeeded;
    }

    /**
     * Returns true if any of the specified values is a floating-point number.
     *
     * @param {...*} pArgs - One or more values to be evaluated
     * @return {boolean} Returns true if any of the arguments are floating-point numbers, otherwise false.
     *
     * @alias module:TypeUtils.containsFloat
     */
    function containsFloat( ...pArgs )
    {
        const arr = explode( ...pArgs ).filter( isNumeric ).map( toDecimal );
        return arr.some( isFloat );
    }

    /**
     * Determines the appropriate typed array class (Float32Array or Float64Array)
     * to represent floating-point numbers based on the range of values.
     *
     * @param {number} pMinValue - The minimum value in the range.
     * @param {number} pMaxValue - The maximum value in the range.
     * @return {Function} The constructor function for the chosen typed array class (Float32Array or Float64Array).
     *
     * @private
     */
    function _calculateFloatTypedArrayClass( pMinValue, pMaxValue )
    {
        return Math.max( Math.abs( pMinValue ), Math.abs( pMaxValue ) ) <= 2 ** 31 ? Float32Array : Float64Array;
    }

    /**
     * Returns the appropriate TypedArray <b>class</b>
     * based on the provided array-like input.
     *
     * @param {...*} pArray A variable-length list of elements.
     *                      Elements can be primitives or arrays.
     *                      They are flattened, converted to numeric values,
     *                      and evaluated to determine the correct TypedArray class.
     *
     * @return {Function} The constructor of the appropriate TypedArray class.
     *                    The returned class will be one of the following:
     *                    Int8Array, Uint8Array, Int16Array, Uint16Array,
     *                    Int32Array, Uint32Array, Float32Array, Float64Array,
     *                    or BigUint64Array.
     *
     * @alias module:TypeUtils.calculateTypedArrayClass
     */
    function calculateTypedArrayClass( ...pArray )
    {
        const arr = [...(explode( ...(pArray || []) ).filter( isNumeric ).map( toDecimal ))];

        const minValue = Math.min( ...(arr.map( toDecimal )) );
        const maxValue = Math.max( ...(arr.map( toDecimal )) );

        if ( containsFloat( ...(arr || []) ) )
        {
            return _calculateFloatTypedArrayClass( minValue, maxValue );
        }

        const signed = arr.some( e => e < 0 );

        let bitsNeeded = calculateBitsNeeded( minValue, maxValue );

        // Align to the appropriate type boundary (8, 16, 32, or 64)
        bitsNeeded = clamp( alignToBytes( bitsNeeded ), 8, 64 );

        switch ( bitsNeeded )
        {
            case 0:
            case 8:
                return signed ? Int8Array : Uint8Array;

            case 16:
                return signed ? Int16Array : Uint16Array;

            case 32:
                return signed ? Int32Array : Uint32Array;

            case 64:
                return signed ? BigInt64Array : BigUint64Array;

            default:
                return Int8Array;
        }
    }

    /**
     * Converts the provided array to a typed array.
     *
     * If the input is already a typed array, it is returned as-is.
     * Otherwise, it determines the appropriate typed array class based on the elements of the array,
     * and converts the input array to that typed array. If the calculated class is BigUint64Array or
     * BigInt64Array, the elements of the array are converted to BigInt using a helper function
     * `toDecimal` before creating the typed array.
     *
     * @function toTypedArray
     * @param {Array|TypedArray} pArray The input array or typed array to convert.
     * @returns {TypedArray|Uint8Array|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|BigInt64Array|BigUint64Array|Float32Array|Float64Array}
     *          A new typed array or the original typed array if already in typed array format.
     *
     * @alias module:TypeUtils.toTypedArray
     */
    const toTypedArray = function( pArray )
    {
        if ( isTypedArray( pArray ) )
        {
            return pArray;
        }

        try
        {
            let arr = [...(pArray || [])];

            const typedArrayClass = calculateTypedArrayClass( ...arr );

            if ( typedArrayClass === BigUint64Array || typedArrayClass === BigInt64Array )
            {
                arr = arr.map( e => BigInt( toDecimal( e ) ) );
            }

            return new typedArrayClass( arr );
        }
        catch( ex )
        {
            modulePrototype.handleError( ex, toTypedArray, pArray );
        }

        return pArray;
    };

    const COMPARE_OPTIONS = { nullFirst: false, prioritizeNumeric: false };

    function compareForNullOrIdentity( pA, pB, pOptions = COMPARE_OPTIONS )
    {
        if ( pA === pB )
        {
            return 0;
        }

        const options = populateOptions( pOptions, COMPARE_OPTIONS );
        const nullsFirst = !!options.nullFirst;

        return (isNull( pA )) ? isNull( pB ) ? 0 : (nullsFirst ? -1 : 1) : (isNull( pB )) ? nullsFirst ? 1 : -1 : null;
    }

    function compareNumericValues( pA, pB )
    {
        const a = toDecimal( pA );
        const b = toDecimal( pB );

        return a < b ? -1 : a > b ? 1 : 0;
    }

    function compareArrays( pA, pB, pOptions = COMPARE_OPTIONS, pVisited = new VisitedSet(), pStack = [] )
    {
        let arrA = [...(pA || [pA] || [])];
        let arrB = [...(pB || [pB] || [])];

        let comp = compare( arrA.length, arrB.length, pOptions, pVisited, pStack );

        if ( 0 === comp )
        {
            const options = populateOptions( pOptions, COMPARE_OPTIONS );

            const visited = pVisited || new VisitedSet();
            const stack = pStack || [];

            arrA = arrA.sort( ( a, b ) => compare( a, b, options, visited, stack ) );
            arrB = arrB.sort( ( a, b ) => compare( a, b, options, visited, stack ) );

            for( let i = 0; i < arrA.length; i++ )
            {
                comp = compare( arrA[i], arrB[i], options, visited, stack.concat( String( i ) ) );

                if ( 0 !== comp )
                {
                    break;
                }
            }
        }

        return comp;
    }

    function compareObjects( pA, pB, pOptions = COMPARE_OPTIONS, pVisited = new VisitedSet(), pStack = [] )
    {
        if ( !isNonNullObject( pA ) )
        {
            return isNonNullObject( pB ) ? -1 : 0;
        }
        else if ( !isNonNullObject( pB ) )
        {
            return 1;
        }

        const options = populateOptions( pOptions, COMPARE_OPTIONS );

        let entriesA = objectEntries( pA );
        let entriesB = objectEntries( pB );

        let comp = compareForNullOrIdentity( entriesA, entriesB, options );

        if ( isNull( comp ) || ![-1, 0, 1].includes( comp ) )
        {
            // compare by number of entries first
            comp = entriesA.length - entriesB.length;
            comp = comp > 0 ? 1 : (comp < 0 ? -1 : 0);

            if ( 0 === comp )
            {
                // compare keys
                comp = compareArrays( (entriesA.map( e => String( e[0] ) ).sort()), (entriesB.map( e => String( e[0] ) ).sort()), options, pVisited, pStack );

                let visited = pVisited || new VisitedSet();
                let stack = pStack || [];

                // sort entries by key before comparing values
                entriesA = entriesA.sort( ( a, b ) => compare( a[0], b[0], options, visited, stack ) );
                entriesB = entriesB.sort( ( a, b ) => compare( a[0], b[0], options, visited, stack ) );

                // compare values
                if ( 0 === comp )
                {
                    if ( visited.has( pA ) && visited.has( pB ) )
                    {
                        return 0;
                    }

                    visited.add( pA );

                    comp = compareArrays( entriesA.map( e => e[1] ), entriesB.map( e => e[1] ), options, visited, stack );
                }
            }
        }

        return comp;
    }

    function canCompareAsPrimitive( pValue )
    {
        return isPrimitive( pValue ) || isPrimitiveWrapper( pValue ) || isDate( pValue ) || isFunction( pValue ) || isRegExp( pValue ) || isNumeric( pValue );
    }

    function comparePrimitiveValues( pA, pB, pOptions = COMPARE_OPTIONS )
    {
        const options = populateOptions( pOptions, COMPARE_OPTIONS );

        let comp = 0;

        if ( options.prioritizeNumeric && isNumeric( pA ) && isNumeric( pB ) )
        {
            comp = compareNumericValues( pA, pB );
        }
        else if ( canCompareAsPrimitive( pA ) && canCompareAsPrimitive( pB ) )
        {
            comp = (toPrimitive( pA ) || pA) - (toPrimitive( pB ) || pB);
        }

        comp = comp > 0 ? 1 : (comp < 0 ? -1 : 0);

        return comp;
    }

    const compare = function( pA, pB, pOptions = COMPARE_OPTIONS, pVisited = new VisitedSet(), pStack = [] )
    {
        const options = populateOptions( pOptions, COMPARE_OPTIONS );

        let comp = compareForNullOrIdentity( pA, pB, options );

        if ( !isNull( comp ) && [-1, 0, 1].includes( comp ) )
        {
            return comp;
        }

        comp = comparePrimitiveValues( pA, pB, options );

        if ( 0 === comp )
        {
            let visited = pVisited || new VisitedSet();
            let stack = pStack || [];

            if ( detectCycles( stack, 5, 5 ) )
            {
                return 0;
            }

            if ( isArray( pA ) || isArray( pB ) )
            {
                comp = compareArrays( (isArray( pA ) ? pA : [pA]), (isArray( pB ) ? pB : [pB]), options, visited, stack );
            }
            else
            {
                comp = compareObjects( pA, pB, options, visited, stack );
            }
        }

        return comp;
    };

    class ComparatorFactory
    {
        #options;

        constructor( pCompareOptions = COMPARE_OPTIONS )
        {
            this.#options = lock( populateOptions( pCompareOptions, pCompareOptions ) );
        }

        comparator()
        {
            return ( a, b ) => compare( a, b, this.#options );
        }

        nullsFirstComparator()
        {
            return ( a, b ) => compare( a, b, { ...this.#options, nullFirst: true } );
        }

        numericComparator()
        {
            return ( a, b ) => compare( a, b, { ...this.#options, prioritizeNumeric: true } );
        }

        reverseComparator()
        {
            return ( a, b ) => -(compare( a, b, this.#options ));
        }

        areEqual( pA, pB )
        {
            return pA === pB || (0 === compare( pA, pB, this.#options ));
        }
    }

    function invertBits( pBitString )
    {
        let bitString = resolveBitString( pBitString );

        const arr = new Array( bitString.length );

        for( let i = 0, n = bitString.length; i < n; i++ )
        {
            arr[i] = _zero === bitString[i] ? "1" : _zero;
        }

        return arr.join( _mt_str );
    }

    function resolveBitString( pBitString )
    {
        switch ( typeof pBitString )
        {
            case _str:
                // the expected case, a string of zeroes and ones
                let bitString = pBitString.trim();
                if ( /^[01]+$/.test( bitString ) )
                {
                    return bitString.trim().replaceAll( /[^01]/g, _mt_str );
                }

                // TODO: other cases...

                break;

            case _num:
            case _big:
                return toBits( pBitString );

            case _obj:
                if ( isArray( pBitString ) || isTypedArray( pBitString ) )
                {
                    const arr = [...pBitString];

                    if ( arr.every( e => [0, 1].includes( toDecimal( e ) ) ) )
                    {
                        return arr.join( _mt_str );
                    }

                    // TODO: other cases, byte arrays, string arrays to be encoded...
                }

                if ( isArrayBuffer( pBitString ) || isSharedArrayBuffer( pBitString ) || isDataView( pBitString ) )
                {
                    // TODO: is 8 the correct size?
                    return resolveBitString( new Uint8Array( pBitString ) );
                }

                break;
        }

        modulePrototype.handleError( new Error( `Unable to resolve bit string: ${pBitString}` ), resolveBitString, pBitString );

        return _mt_str;
    }

    function addOneToBitString( pBitString )
    {
        let bitString = resolveBitString( pBitString );

        const bits = bitString.split( _mt_str );

        // add one
        let carry = 1;

        // Iterate from LSB to MSB
        for( let i = bits.length; ((i--) > 0) && (carry > 0); )
        {
            const bit = bits[i];

            if ( _zero === bit )
            {
                bits[i] = "1";
                carry = 0;
            }
            else
            {
                bits[i] = _zero;
            }
        }

        return bits.join( _mt_str );
    }

    /**
     * Computes the two's complement of a given binary string.<br>
     * <br>
     *
     * The input should be a binary string composed of '0's and '1's only.<br>
     * The function assumes that the input binary string is valid
     * and does not perform any additional validation.<br>
     *
     * The two's complement of a binary number
     * is calculated by inverting all the bits (0s become 1s, and 1s become 0s)
     * and then adding 1 to the result.
     *
     * @param {string} pBitString - A binary string for which the two's complement is to be calculated.
     * @returns {string} The two's complement of the input binary string as another binary string.
     */
    const twosComplement = function( pBitString )
    {
        let bitString = resolveBitString( pBitString );

        bitString = invertBits( bitString );

        return addOneToBitString( bitString );
    };

    const intToBits = function( pValue, pLength = 8 )
    {
        const num = isNumeric( pValue ) ? toDecimal( pValue ) : 0;

        const length = alignToBytes( Math.max( pLength, calculateBitsNeeded( num, num ) ) );

        if ( length > 64 )
        {
            throw new Error( `Cannot convert ${num} to bits. The value requires more than 64 bits.` );
        }

        const negative = num < 0;

        let abs = Math.abs( num );

        // initialize the bit string with the sign-bit
        let bitString = _mt_str;

        // we iterate from length-1 in order to reserve the sign-bit for a possible negative value
        for( let i = (length - 1); abs >= 0 && i >= 0; i-- )
        {
            const place = 2 ** i;

            if ( abs >= place )
            {
                bitString += "1";
                abs -= place;
            }
            else
            {
                bitString += "0";
            }
        }

        // bitString = bitString.padStart( length, "0" );

        if ( negative )
        {
            bitString = twosComplement( bitString );
        }

        return bitString;
    };

    const floatToBits = function( pValue )
    {
        throw new Error( "Not implemented" );
    };

    const toBits = function( pValue, pLength )
    {
        const num = isNumeric( pValue ) ? toDecimal( pValue ) : 0;

        if ( 0 === num || isInteger( num ) )
        {
            return intToBits( num, pLength );
        }

        if ( isFloat( num ) )
        {
            return floatToBits( num, pLength );
        }

        if ( isString( num ) )
        {
            if ( isNumeric( num ) )
            {
                return toBits( toDecimal( pValue ), pLength );
            }

            throw new IllegalArgumentError( `Cannot convert ${num} to bits. The value is not a number.` );
        }

        return String( parseInt( toDecimal( num ), 2 ) ).replace( /^0b/, _mt_str );
    };

    /**
     * This is the module itself, exported from this function
     */
    let mod =
        {
            dependencies,

            JS_TYPES,
            VALID_TYPES,
            TYPE_DEFAULTS,
            TYPE_SORT_ORDER,
            BYTES_PER_TYPE,

            flattened,
            explode,

            isUndefined,
            isDefined,
            isNull,
            isNotNull,
            isNonNullValue,
            isPrimitive,
            isPrimitiveWrapper,
            isObject,
            isCustomObject,
            isNonNullObject,
            isValidObject,
            isPopulated,
            isError,
            isEvent,
            firstError,
            isFunction,
            isAsyncFunction,
            isGeneratorFunction,
            isPromise,
            isThenable,
            isString,
            isEmptyString,
            isNumber,
            isInteger,
            toInteger,
            isFloat,
            containsFloat,
            toFloat,
            isBigInt,
            isNumeric,
            isZero,
            isBinary,
            isOctal,
            isHex,
            isDecimal,
            isScientificNotation,
            isNanOrInfinite,
            isBoolean,
            isArray,
            isTypedArray,
            isIterable,
            isAsyncIterable,
            isLikeArray,
            isSpreadable,
            isMap,
            isSet,
            isDate,
            isRegExp,
            isClass,
            isUserDefinedClass,
            isListedClass,
            isInstanceOfUserDefinedClass,
            isInstanceOfListedClass,
            isAssignableTo,
            isSymbol,
            isType,
            isValidDateOrNumeric,
            isValidDateInstance,
            isDirectoryEntry,
            isArrayBuffer,
            isSharedArrayBuffer,
            isDataView,
            toDecimal,
            toHex,
            toOctal,
            toBinary,
            toBits,
            intToBits,
            floatToBits,
            invertBits,
            resolveBitString,
            twosComplement,
            clamp,
            resolveMoment,
            areSameType,
            areCompatibleTypes,
            instanceOfAny,
            getClass,
            getClassName,
            defaultFor,
            castTo,
            toIterable,
            firstMatchingType,
            estimateBytesForType,
            NVL,
            isReadOnly,
            calculateBitsNeeded,
            alignToBytes,
            calculateTypedArrayClass,
            toTypedArray,

            /**
             * The classes exported with this module.<br>
             * <br>
             * Classes:<br>
             * <ul>
             * <li><i></i>: </li>
             * </ul>
             * @alias module:TypeUtils#classes
             */
            classes:
                {
                    ComparatorFactory,
                    Finder,
                    VisitedSet,
                    Option,
                    TypedOption,
                    StringOption,
                    NumericOption,
                    BooleanOption,
                    Result
                },

            ComparatorFactory,
            Finder,
            VisitedSet,
            Option,
            TypedOption,
            StringOption,
            NumericOption,
            BooleanOption,
            Result
        };

    mod = modulePrototype.extend( mod );

    return mod.expose( mod, INTERNAL_NAME, (_ud !== typeof module ? module : mod) ) || mod;

}());
