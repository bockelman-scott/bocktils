/**
 * Defines several useful functions for detecting the type of a variable or object.
 * DEPENDS ON Constants.js
 */

/** import the Constants.js we depend upon using require for maximum compatibility with Node versions */
const constants = require( "./Constants.js" );

/** create an alias for the console to avoid Lint warnings */
const konsole = console || {};

/**
 * Defines a string to represent the type, undefined
 */
const _ud = constants?._ud || "undefined";

/**
 * This function returns the host environment scope (Browser window, Node.js global, or Worker self)
 */
const $scope = constants?.$scope || function()
{
    return (_ud === typeof self ? ((_ud === typeof global) ? {} : (global || {})) : (self || {}));
};

(function exposeTypeUtils()
{
    /**
     * Define a string key which is unlikely to collide with other libraries or properties.
     * We use this to store the module generated by this function in global scope.
     * We can avoid re-executing the rest of this function if the module is already defined.
     */
    const INTERNAL_NAME = "__BOCK__TYPE_UTILS__";

    /**
     * Checks to see if this module is already defines and available in the global scope
     * Returns the existing module instead of recreating it, if it is already present.
     */
    if ( $scope() && (null != $scope()[INTERNAL_NAME]) )
    {
        return $scope()[INTERNAL_NAME];
    }

    /**
     * An array of this module's dependencies
     */
    const dependencies = ["Constants.js"];

    let _mt_str = constants._mt_str || "";

    let _str = constants._str || "string";
    let _fun = constants._fun || "function";
    let _num = constants._num || "number";
    let _big = constants._big || "bigint";
    let _bool = constants._bool || "boolean";
    let _obj = constants._obj || "object";
    let _symbol = constants._symbol || "symbol";

    const VALID_TYPES = [_str, _num, _big, _symbol, _bool, _obj, _fun];
    const JS_TYPES = [_ud].concat( VALID_TYPES );

    const isObject = function( pObj )
    {
        return (_obj === typeof pObj) || pObj instanceof Object;
    };

    const isCustomObject = function( pObj )
    {
        return isObject( pObj ) && pObj.prototype !== null;
    };

    const isFunction = function( pObj )
    {
        return null !== pObj && _fun === typeof pObj;
    };

    const isAsyncFunction = function( pObject )
    {
        return isFunction( pObject ) && (pObject.constructor === constants.AsyncFunction || pObject === constants.AsyncFunction);
    };

    const isString = function( pObj )
    {
        return (_str === typeof pObj) || pObj instanceof String;
    };

    const isNumber = function( pObj )
    {
        return [_num, _big].includes( typeof pObj ) || pObj instanceof Number;
    };

    const isNumeric = function( pObj )
    {
        return isNumber( pObj ) || !(isNaN( parseFloat( pObj ) ) && Number.isFinite( Number( pObj ) ));
    };

    const isZero = function( pValue )
    {
        return isNumber( pValue ) && 0 === pValue;
    };

    const isBoolean = function( pValue )
    {
        return ((_bool === typeof pValue) && ((false === pValue) || true === pValue)) || pValue instanceof Boolean;
    };

    const isUndefined = function( pObject )
    {
        return (_ud === typeof pObject || undefined === pObject);
    };

    const isDefined = function( pObject )
    {
        return !isUndefined( pObject );
    };

    const isNull = function( pObject, pStrict = false )
    {
        if ( pStrict )
        {
            return null === pObject;
        }
        return (isUndefined( pObject ) || null == pObject || _mt_str === String( pObject ));
    };

    const isNotNull = function( pObject, pStrict = false )
    {
        return !isNull( pObject, pStrict );
    };

    const isNonNullObject = function( pObject, pStrict = false, pOptions = { allow_empty_object: true } )
    {
        if ( !isNull( pObject ) && isObject( pObject ) )
        {
            const options = Object.assign( { allow_empty_object: true }, pOptions );

            return options.allow_empty_object || (Object.entries( pObject )?.length > 0 && !isNull( Object.entries( pObject )[0][1], pStrict ));
        }
    };

    const isArray = function( pObj )
    {
        return isObject( pObj ) && ((isFunction( Array.isArray )) ? Array.isArray( pObj ) : Object.prototype.toString.call( pObj ).toString() === "[object Array]");
    };

    const isSymbol = function( pValue )
    {
        return _str === typeof pValue || pValue instanceof Symbol;
    };

    const isType = function( pValue, pType )
    {
        if ( isString( pType ) && JS_TYPES.includes( (pType).trim().toLowerCase() ) )
        {
            return ((pType).trim().toLowerCase()) === (typeof pValue);
        }

        if ( isObject( pValue ) && isObject( pType ) )
        {
            return pValue instanceof pType;
        }

        return false;
    };

    const isMap = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) )
        {
            return false;
        }

        const isMapInstance = pObject instanceof Map;

        if ( isMapInstance )
        {
            return true;
        }

        if ( pStrict )
        {
            return false;
        }

        if ( isObject( pObject ) )
        {
            const keys = Object.keys( pObject );

            const strings = keys.filter( key => isString( key ) );

            return keys.length === strings.length;
        }

        return false;
    };

    const isSet = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) )
        {
            return false;
        }

        let isInstanceOfSet = pObject instanceof Set;

        if ( isInstanceOfSet )
        {
            return true;
        }

        if ( pStrict )
        {
            return false;
        }

        if ( isArray( pObject ) )
        {
            const length = pObject.length;
            let set = new Set( [...pObject] );
            return set?.size === length;
        }

        return false;
    };

    const isDate = function( pObj )
    {
        if ( isUndefined( pObj ) || isNull( pObj ) || isString( pObj ) )
        {
            return false;
        }

        return (pObj instanceof Date) || ("[object Date]" === Object.prototype.toString.call( pObj ) || (pObj.constructor === Date) || (pObj.prototype === Date));
    };

    const isRegExp = function( pObject, pStrict = true )
    {
        if ( isUndefined( pObject ) || isNull( pObject ) )
        {
            return false;
        }

        if ( pStrict )
        {
            return pObject instanceof RegExp;
        }

        const s = pObject.toString();

        if ( ("/" + pObject.source + "/") === s )
        {
            return isObject( pObject ) || _mt_str !== s;
        }

        return false;
    };

    /**
     * Returns true if the value passed represents a JavaScript Class
     * JavaScript classes return "function" for the typeof operator,
     * so this function is necessary to determine the difference between a function and a class definition
     * @param {function} pFunction
     * @returns true if the function specified is a class definition
     */
    const isClass = function( pFunction )
    {
        if ( _fun === typeof pFunction )
        {
            return /^class\s/.test( String( Function.prototype.toString.call( pFunction ) ).trim() );
        }

        return false;
    };


    const mod =
        {
            dependencies,
            getScope: $scope,
            JS_TYPES,
            VALID_TYPES,
            isUndefined,
            isDefined,
            isNull,
            isNotNull,
            isObject,
            isCustomObject,
            isNonNullObject,
            isFunction,
            isAsyncFunction,
            isString,
            isNumber,
            isNumeric,
            isZero,
            isBoolean,
            isArray,
            isMap,
            isSet,
            isDate,
            isRegExp,
            isClass,
            isSymbol,
            isType
        };

    if ( _ud !== typeof module )
    {
        module.exports = Object.freeze( mod );
    }

    if ( $scope() )
    {
        $scope()[INTERNAL_NAME] = Object.freeze( mod );
    }

    return Object.freeze( mod );

}());
