/**
 * Defines several useful functions for manipulating Strings.
 * DEPENDS ON Constants.js
 */

/** import the Constants.js we depend upon using require for maximum compatibility with Node versions */
const constants = require( "./Constants.js" );

/** import the Constants.js we depend upon using require for maximum compatibility with Node versions */
const typeUtils = require( "./TypeUtils.js" );

/** create an alias for the console to avoid Lint warnings */
const konsole = console || {};

/**
 * Defines a string to represent the type, undefined
 */
const _ud = constants?._ud || "undefined";

/**
 * This function returns the host environment scope (Browser window, Node.js global, or Worker self)
 */
const $scope = constants?.$scope || function()
{
    return (_ud === typeof self ? ((_ud === typeof global) ? {} : (global || {})) : (self || {}));
};

/**
 * This immediately invoked function expression (IIFE)
 * defines and returns the StringUtils module
 */
(function exposeStringUtils()
{
    /**
     * Define a string key which is unlikely to collide with other libraries or properties.
     * We use this to store the module generated by this function in global scope.
     * We can avoid re-executing the rest of this function if the module is already defined.
     */
    const INTERNAL_NAME = "__BOCK__STRING_UTILS__";

    /**
     * Checks to see if this module is already defines and available in the global scope
     * Returns the existing module instead of recreating it, if it is already present.
     */
    if ( $scope() && (null != $scope()[INTERNAL_NAME]) )
    {
        return $scope()[INTERNAL_NAME];
    }

    /**
     * An array of this module's dependencies
     * which are re-exported with this module,
     * so if you want to, you can just import the leaf module
     * and then use the other utilities as properties of that module
     */
    const dependencies =
        {
            constants,
            typeUtils
        };

    /**
     * The following variable declarations are used
     * to help your IDE recognize shorthand usages of values imported into this scope
     */
    let _mt_str = constants._mt_str || "";
    let _mt_chr = constants._mt_chr || "";

    let _dblqt = constants._dblqt || "\"";
    let _sglqt = constants._sglqt || "'";

    let _spc = constants._spc || " ";
    let _dot = constants._dot || ".";
    let _underscore = constants._underscore || "_";
    let _ellipsis = constants._ellipsis || "...";
    let _z = constants._z || "\u0000";

    let _unixPathSep = constants._unixPathSep || "/";
    let _unixPrevDir = constants._unixPrevDir || (_dot + _dot + _unixPathSep);
    let _unixThisDir = constants._unixThisDir || (_dot + _unixPathSep);

    let _lf = constants._lf || "\n";
    let _crlf = constants._crlf || "\r\n";

    let S_TRUE = constants.S_TRUE || "true";
    let S_FALSE = constants.S_FALSE || "false";
    let S_NULL = constants.S_NULL || "null";

    let _affirmatives = constants._affirmatives || ([].concat( ...(["true", "1", "on", "enabled", "t", "yes"]) ));

    let _str = constants._str || "string";
    let _fun = constants._fun || "function";
    let _num = constants._num || "number";
    let _big = constants._big || "bigint";
    let _bool = constants._bool || "boolean";
    let _obj = constants._obj || "object";
    let _symbol = constants._symbol || "symbol";

    let ComparatorFactory = constants.ComparatorFactory || constants.classes?.ComparatorFactory;

    /**
     * This statement makes the functions in the constants module available as local functions.
     */
    Object.assign( this, constants );

    let isUndefined = typeUtils.isUndefined;
    let isDefined = typeUtils.isDefined;
    let isNull = typeUtils.isNull;
    let isNotNull = typeUtils.isNotNull;

    let isString = typeUtils.isString;
    let isNumber = typeUtils.isNumber;
    let isBoolean = typeUtils.isBoolean;
    let isFunction = typeUtils.isFunction;

    /**
     * The preceding variable declarations are used
     * to help your IDE recognize shorthand usages of values imported into this scope
     */

    /**
     * This regular expression is used to determine if a string
     * is a valid JSON object or array
     */
    const _rxValidJson = /^([{\[])(.*)*([}\]])$/s;

    /**
     * When a function is added to a built-in object prototype,
     * the value does not need to be passed in, so we need to find it
     * @param pValue either a value or undefined when the value should be the value of 'this'
     * @returns {number | string} the value to use in the function
     * @private
     */
    function _resolveInput( pValue )
    {
        let input = pValue;

        if ( isUndefined( pValue ) )
        {
            if ( this instanceof Number || Number === this.constructor || isNumber( this.prototype ) )
            {
                input = (Number( this ).valueOf() || parseFloat( _mt_str + this )) || pValue;
            }
            if ( this instanceof String || String === String.constructor || isString( this.prototype ) )
            {
                input = (String( this ).valueOf() || asString( _mt_str + this )) || pValue;
            }
            if ( this instanceof Boolean || Boolean === Boolean.constructor || isBoolean( this.prototype ) )
            {
                input = this.valueOf() || Boolean( this ) || pValue;
            }
        }

        return input || pValue;
    }

    const DEFAULT_AS_STRING_OPTIONS =
        {
            omitFunctions: true,
            executeFunctions: false,
            joinOn: _mt_chr,
            jsonify: JSON.stringify,
            removeLeadingZeroes: true,
            assumeNumeric: false,
            assumeAlphabetic: true,
            dateFormatter: null

        };
    /**
     * Returns a string representation of the argument passed, optionally removing leading and trailing whitespace.
     *
     * @param {any} pStr any valid type for which a string representation is desired
     *
     * @param {boolean} pTrim pass true to return a string with leading and trailing whitespace removed.<br />
     *                        defaults to false
     *
     * @param pOptions object specifying how to handle special circumstances, such as functions, arrays, and objects.
     * <br /> Defaults to:<br/>
     * {
     *             omitFunctions: true,
     *             executeFunctions: false,
     *             joinOn: _mt_chr,
     *             jsonify: JSON.stringify
     * }
     *
     * @returns {string} a string representation of the argument
     *                   if the argument is already a string, returns a new copy of the string
     *                   if the argument is a number or big integer,
     *                                      attempts to parse the number as a float
     *                                      and then return a string representation of the resulting value
     *                   if the argument is an object,
     *                                   if the object is an Array, joins the asString value of each element
     *                                   if the object is one of the built-in JavaScript types,
     *                                      returns a asString of its canonical string representation
     *                                   if the object defines a toJson method, returns the result of calling that method on the object
     *                                   otherwise, attempts to call JSON.stringify passing the object as the argument
     *                  if the argument is a function, attempts to execute that function and return its result(s) as a asString
     *                  in all other cases, returns an empty string
     *
     *                  if this function is called with 2 arguments and the second argument is truthy,
     *                  the returned value will be trimmed (leading and trailing whitespace is removed)
     */
    const asString = function( pStr, pTrim = false, pOptions = DEFAULT_AS_STRING_OPTIONS )
    {
        // ingest any options passed; specific options override the default options ingested
        const options = Object.assign( Object.assign( {}, DEFAULT_AS_STRING_OPTIONS ), pOptions || {} );

        // capture 'this' in a closure-scoped variable for use in the 'stringify' function below
        const me = asString || this;

        me.stringify = me.stringify || options.jsonify || function( pObj )
        {
            let string = pObj;

            try
            {
                string = JSON.stringify( pObj );
            }
            catch( ex )
            {
                konsole.error( constants.S_ERR_PREFIX, "converting value to JSON", ex );
            }

            return string || "|_|";
        };

        let s = _mt_str;

        // allow this function to be added as a method to String.prototype if desired
        if ( isUndefined( pStr ) || isNull( pStr ) || arguments.length <= 0 )
        {
            // note that we code this in such a way that it can be bound to the String.prototype as a member function (a.k.a. method)
            if ( (this instanceof String || String === this?.constructor) && isFunction( this.asString ) )
            {
                return me( String( this ).valueOf() || me( this, pTrim ), pTrim );
            }
        }

        let input = _resolveInput.call( this, pStr );

        // handle the easiest case immediately
        if ( isString( input ) )
        {
            s = pTrim ? input.trim() : input;

            if ( options.assumeNumeric )
            {
                s = input.trim();

                let chars = s.split( _mt_chr );

                if ( options.removeLeadingZeroes )
                {
                    let iterations = 0;

                    while ( chars?.length > 0 && /[\s0]/.test( chars[0] ) && iterations++ < (s?.length || 0) )
                    {
                        chars.shift();
                    }
                }

                s = chars.join( _mt_chr );

                s = s.replace( /\D+$/g, _mt_str );

                try
                {
                    let n = parseFloat( s );
                    s = String( n );
                }
                catch( ex )
                {
                    konsole.warn( constants.S_ERR_PREFIX, "removing non-numeric characters", ex );
                }
            }

            if ( pTrim )
            {
                return (_mt_str + (s || _mt_str).trim());
            }

            return s;
        }

        // return a value based on the type pf the argument
        switch ( typeof input )
        {
            // double-check the easy case
            case _str:
                s = (_mt_str + (input || _mt_str));
                break;

            // numeric values are converted to the string representation of their float value
            case _num:
            case _big:
                try
                {
                    let n = parseFloat( input );
                    s = isNaN( n ) || !isFinite( n ) ? 0 : (_mt_str + n);
                }
                catch( ex )
                {
                    konsole.warn( ex.message );
                }
                break;

            // booleans are converted to either the string "true" or the string "false
            case _bool:
                s = input ? S_TRUE : S_FALSE;
                break;

            // objects are special case...
            case _obj:
                // if the argument is an array, recursively call this function on each element and join the results on the joinOn option or the empty character
                if ( Array.isArray( input ) )
                {
                    s = [].concat( ...(input || []) ).map( e => asString( e, pTrim ) ).join( (asString( options.joinOn ) || _mt_chr) );
                    break;
                }

                // handle ObjectWrapper types
                if ( input instanceof Boolean )
                {
                    s = input.valueOf() ? S_TRUE : S_FALSE;
                    break;
                }

                // handle ObjectWrapper types
                if ( input instanceof Number )
                {
                    s = asString( _mt_str + input.valueOf(), pTrim );
                    break;
                }

                // handle Dates by converting to the normal local string representation
                // unless a date formatter has been supplied
                if ( input instanceof Date )
                {
                    if ( _fun === typeof options.dateFormatter )
                    {
                        try
                        {
                            s = options.dateFormatter.call( $scope(), input );
                        }
                        catch( ex )
                        {
                            konsole.warn( constants.S_ERR_PREFIX, "formatting a Date", input, ex );
                            s = input.toLocaleString();
                        }
                    }
                    else
                    {
                        s = input.toLocaleString();
                    }
                    break;
                }

                // convert RegExp to their normal string representation
                if ( input instanceof RegExp )
                {
                    s = input.toString();
                    break;
                }

                // if the object defines a toString method, we try that
                if ( isFunction( input?.toString ) )
                {
                    s = input.toString();

                    //if the string representation is the generic string,
                    if ( "[object object]" === lcase( s ) || "Object" === s )
                    {
                        // try to get the value of a name property or the constructor's name
                        // note that this could return undesirable results for objects with a coincidental name property
                        s = input?.name || input?.constructor?.name || _mt_str;

                        if ( "[object object]" === lcase( s ) || "Object" === s )
                        {
                            try
                            {
                                s = JSON.stringify( input );
                            }
                            catch( ex )
                            {
                                konsole.warn( constants?.S_ERR_PREFIX, "while converting an object to JSON", ex );
                            }
                        }
                    }
                }

                // if no toString method is available or {} === s or s is the empty string,
                // try to render it as JSON

                if ( isBlank( s ) || "{}" === s )
                {
                    // if the object defines its own toJson (NOT toJSON in this case), try that first
                    if ( _fun === typeof input?.toJson )
                    {
                        try
                        {
                            s = input.toJson();
                        }
                        catch( ex )
                        {
                            console.error( constants.S_ERR_PREFIX, "convert an object to JSON", pStr, ex );
                        }
                        break;
                    }
                }

                if ( isBlank( s ) || "{}" === s )
                {
                    // try the stringify method, which is either JSON.stringify or an overridden jsonification function
                    try
                    {
                        s = me.stringify( input );
                    }
                    catch( ex )
                    {
                        konsole.warn( ex.message );
                    }
                }

                break;

            case _fun:

                if ( !options.omitFunctions )
                {
                    try
                    {
                        s = input.name || input?.constructor?.name || (options.executeFunctions ? input.call( $scope() ) : Function.prototype.toString.call( input, input ));
                    }
                    catch( ex )
                    {
                        s = Function.prototype.toString.call( input, input );
                    }

                    s = asString( s, pTrim );
                }
                else
                {
                    s = _mt_str;
                }

                if ( isBlank( s ) )
                {
                    let regExp = /^class/.test( s ) ? /^class/ : /^(async )*function/;

                    if ( regExp.test( s ) )
                    {
                        s = asString( s.replace( regExp, _mt_str ), true );

                        let idx = s.indexOf( _spc );

                        if ( idx > 1 )
                        {
                            s = s.slice( 0, idx );
                        }
                        else
                        {
                            idx = s.indexOf( "{" );
                            if ( idx > 1 )
                            {
                                s = s.slice( 0, idx );
                            }
                        }
                    }
                }

                break;

            default:
                s = _mt_str;
                break;
        }

        // if the string is the null-terminator (perhaps the string came from a C-API)
        if ( _z === s )
        {
            return _mt_str;
        }

        return (_mt_str + ((true === pTrim) ? s.trim() : s));
    };

    String.prototype.asString = asString;
    Number.prototype.asString = asString;
    Boolean.prototype.asString = asString;

    /**
     * Returns a C-language compatible string
     * by converting the JavaScript String to a C-style String (8 byte chunks, null-terminated)
     * This is necessary when interacting with some C/C++ addons.
     */
    const toCString = function( pString )
    {
        return Buffer.from( `${pString}\0`, "ucs2" );
    };

    /**
     *  Returns a Javascript-compatible string by converting a C-style string into a JavaScript String,
     *  removing null-terminators, for example
     *
     * @param pCString a string (or buffer) believed to be a string in a C-language compatible format
     * @param pLen the length of the string
     * @returns {string} a JavaScript string
     */
    const fromCString = function( pCString, pLen = -1 )
    {
        let buffer = Buffer.from( pCString, "ucs2" );

        let s = buffer.toString();

        // remove the null terminators;
        // Unicode characters may occupy either one or 2 bytes,
        // ordinary ascii string will have _z between each character
        if ( s )
        {
            let chars = s.split( _mt_chr );
            chars = chars.filter( ( c, i ) => (s.charCodeAt( i ) > 0 ? c : _mt_chr) );
            s = chars.join( _mt_chr );
        }

        // if the desired length is known ahead of time, we can also slice the returned (and scrubbed) value
        if ( pLen > 0 )
        {
            s = s.slice( 0, pLen );
        }

        // double-check we have no dangling null-terminators
        while ( s.endsWith( _z ) )
        {
            s = s.replace( /\u0000+$/g, _mt_str );
        }

        // return our glorious JavaScript-compatible character sequence
        return s;
    };

    /**
     * Returns true if the string contains interpolatable variables
     *
     * @param pMsg
     * @returns {*|boolean}
     * @private
     */
    const _containsPlaceholders = function( pMsg )
    {
        return pMsg.includes( "{" ) &&
               pMsg.includes( "}" ) &&
               (/\{\d+}/.test( pMsg ));
    };

    /**
     * Returns a string that contains typical java-like message format placeholders, such as {0}. {1}, etc.
     * with those placeholders replaced by the corresponding elements of the provided array of values
     * @param pMsg a string potentially containing indexed placeholders, such as {0}
     * @param pData an array of values to use when replacing the indexed placeholders
     * @returns {string} a string with placeholders replaced with corresponding elements of the pData array
     * @private
     */
    const _replaceIndexPlaceholders = function( pMsg, ...pData )
    {
        let msg = asString( pMsg, false );

        if ( _containsPlaceholders( msg ) )
        {
            const substitutions = Array.isArray( pData ) ? pData : [pData];

            msg = msg.replace( /{\d+}/g, match => substitutions[parseInt( match.slice( 1, -1 ) )] );
        }

        return msg;
    };

    /**
     * Returns a string with placeholders populated from the second, third, fourth, ... nth arguments
     * @param pMsg a string potentially containing indexed placeholders, such as {0} or {1}
     * @param pData one or more values to use to replace placeholders, the first of these will replace {0}, the second of these will replace {1}, and so on
     * @returns {string} a string with placeholders replaced with the corresponding value specified
     */
    const formatMessage = function( pMsg, ...pData )
    {
        let msg = asString( pMsg, false );

        return _replaceIndexPlaceholders( msg, ...pData );
    };

    function hasUnresolvedVariables( pString )
    {
        return pString.includes( "${" ) && pString.includes( "}" ) && (/\$\{\w+}/.test( pString ));
    }

    /**
     * Returns a string with variables replaced with values found in the specified scope
     * @param pStr a string potentially containing variable tokens, such as ${myVariableName}
     * @param pVariablesMap an object (or scope) defining the variables contained in the string
     *
     * NOTE:  This is equivalent to using template strings `such as ${this}`, but allows the scope to be specified
     *
     * @returns {string} a string with variable tokens replaced by values in the specified map or scope
     */
    const interpolate = function( pStr, pVariablesMap = { ...$scope() } )
    {
        let str = asString( pStr, false );

        if ( hasUnresolvedVariables( str ) )
        {
            let variables = {};

            Object.assign( variables, constants.copyScope( $scope() ) );

            let entries = (pVariablesMap instanceof Map) ? pVariablesMap.entries() : (_obj === typeof pVariablesMap) ? Object.entries( pVariablesMap ) : [["", ""]];

            for( let [key, value] of entries )
            {
                const k = asString( key, true );

                if ( !isBlank( k ) && !(_ud === typeof value || null === value || _fun === typeof value || _symbol === typeof value || ["global", "this", "self", "window"].includes( k )) )
                {
                    variables[key] = value;
                }
            }

            for( let entry of Object.entries( variables ) )
            {
                str = str.replaceAll( new RegExp( "\\$\\{" + entry[0] + "\\}", "g" ), asString( entry[1], false ) );

                if ( !hasUnresolvedVariables( str ) )
                {
                    break;
                }
            }
        }

        return asString( str, false );
    };

    const DEFAULT_VALID_IDENTIFIER_OPTIONS =
        {
            defaultIdentifier: _underscore
        };

    /**
     * Returns a string that is a valid JavaScript identifier.
     * @see https://developer.mozilla.org/en-US/docs/Glossary/Identifier
     *
     * @param {*} pStr a value to be used as a variable or property name
     * @param pOptions an object to specify how to handle unusual cases
     */
    const validIdentifier = function( pStr, pOptions = DEFAULT_VALID_IDENTIFIER_OPTIONS )
    {
        const options = Object.assign( Object.assign( {}, DEFAULT_VALID_IDENTIFIER_OPTIONS ), pOptions || {} );

        let s = asString( pStr, true ).trim();

        if ( isBlank( s ) )
        {
            return options?.defaultIdentifier || _underscore;
        }

        let chars = s.split( _mt_chr );

        while ( chars.length && !(/[A-Za-z$_]/.test( chars[0] )) )
        {
            chars.shift();
        }

        s = chars.join( _mt_chr );

        s = s.replaceAll( /[^A-Za-z$_]/g, _mt_str );

        if ( isBlank( s ) || constants.RESERVED_WORDS.includes( s ) )
        {
            return options?.defaultIdentifier || _underscore;
        }

        return asString( s, true );
    };

    /**
     * Returns a string that can be used as a key in a map or map-like structure, such as an object literal
     * Note that just about any string can be a key and that integers can be used as keys (that is in fact, part of how Array is implemented)
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_Types#object_literals
     *
     * @param {*} pStr
     * @param {boolean} pOptions
     */
    const asKey = function( pStr, pOptions = { supportDotNotation: false, defaultIdentifier: _underscore } )
    {
        const options = Object.assign( {}, pOptions || {} );

        let s = asString( pStr, true ).trim();

        if ( isBlank( s ) || constants.RESERVED_WORDS.includes( s ) )
        {
            return options?.defaultIdentifier || _underscore;
        }

        const validName = validIdentifier( s, options );

        if ( s === validName )
        {
            return s;
        }

        if ( s.includes( _dot ) && options.supportDotNotation )
        {
            let keys = s.split( _dot );

            keys = keys.map( e => (asKey( e )) );

            s = keys.join( _dot );

            return _dblqt + s + _dblqt;
        }

        const validIndex = asInt( s, 0 );

        if ( asString( validIndex, true ) === s )
        {
            return parseInt( s );
        }

        return _dblqt + s.replaceAll( /[\W$_]/g, _mt_str ) + _dblqt;
    };


    /**
     * Returns true if the string representation of the argument is specifically the empty string
     * @param {any} pStr - a string or object to check for emptiness
     * @returns {boolean} true if the string representation of the argument is the empty string
     */
    const isEmpty = function( pStr )
    {
        return (_mt_str === asString( pStr, false )) || (_z === pStr) || (asString( pStr, false )?.length || 0) <= 0;
    };

    /**
     * Returns true if the string representation of the argument is the empty string or only whitespace characters
     * @param {any} pStr - a string or object to check for emptiness
     * @returns {boolean} true if the string representation of the argument is the empty string or only whitespace characters
     */
    const isBlank = function( pStr )
    {
        return (_mt_str === asString( pStr, true ).trim()) || (_z === pStr);
    };

    const DEFAULT_IS_CAPS_OPTIONS =
        {
            allowWhitespace: true,
            allowDigits: false
        };

    /**
     * Returns true if every character in the specified string is an UPPERCASE letter
     * @param pStr a string to test for all capital letters
     * @param pOptions an object defining how to treat whitespace and digits
     * @returns {boolean} true if the string specified consists solely of UPPERCASE letters
     */
    const isAllCaps = function( pStr, pOptions )
    {
        const options = Object.assign( Object.assign( {}, DEFAULT_IS_CAPS_OPTIONS ), pOptions || {} );

        const str = asString( pStr, options.allowWhitespace );

        const hasLowerCase = options.allowDigits ? /[a-z]/.test( str ) : /[a-z0-9]/.test( str );

        return !hasLowerCase;
    };

    /**
     * Returns true if **NO** character in the specified string is an UPPERCASE letter
     * @param pStr a string to test for the presence of capital letters
     * @returns {boolean} true if the string specified consists solely of lowercase letters or numbers
     */
    const isNoCaps = function( pStr )
    {
        const str = asString( pStr, true );
        return !(/[A-Z]/.test( str ));
    };

    /**
     * Returns a substring not longer than pMaxLength
     * @param pStr the string to (potentially) truncate to the specified length
     * @param pMaxLength the length to which to truncate the string
     * @returns {string}
     */
    function truncate( pStr, pMaxLength = -1 )
    {
        let s = asString( pStr );

        const maxLength = asInt( pMaxLength, -1 );

        if ( maxLength >= 0 )
        {
            return s.slice( 0, Math.min( maxLength, s.length ) );
        }

        return s;
    }

    /**
     * Returns true if the specified string contains both UPPERCASE and lowercase letters
     * @param pStr a string to test for mixed case characters
     * @returns {boolean} true if the string specified contains both UPPERCASE and lowercase letters
     */
    const isMixedCase = function( pStr )
    {
        const str = asString( pStr, true );
        return /[A-Z]/.test( str ) && /[a-z/]/.test( str );
    };

    function appendEllipsis( pStr, pMaxLength = -1, pEllipsis = _ellipsis )
    {
        let s = asString( pStr );

        const ellipsis = asString( pEllipsis ) || _ellipsis;

        const ellipsisLength = (ellipsis?.length || 3);

        const defaultMaxLength = (s?.length || 0) + ellipsisLength;

        let maxLength = asInt( pMaxLength, defaultMaxLength );
        maxLength = Math.max( (maxLength > 0 ? maxLength : defaultMaxLength), ellipsisLength );

        if ( ((s + ellipsis)?.length || 0) <= maxLength )
        {
            s += (ellipsis || _mt_str);
        }
        else
        {
            s = s.slice( 0, Math.min( s.length, Math.max( 1, (maxLength - ellipsisLength) ) ) );
            s += ellipsis;
        }

        return truncate( s, pMaxLength );
    }

    function prependEllipsis( pStr, pMaxLength = -1, pEllipsis = _ellipsis )
    {
        let s = asString( pStr );

        const ellipsis = asString( pEllipsis ) || _ellipsis;

        const ellipsisLength = (ellipsis?.length || 3);

        const defaultMaxLength = ellipsisLength + (s?.length || 0);

        let maxLength = asInt( pMaxLength, defaultMaxLength );
        maxLength = Math.max( (maxLength > 0 ? maxLength : defaultMaxLength), ellipsisLength );

        if ( ((ellipsis + s)?.length || 0) <= maxLength )
        {
            s = (ellipsis || _mt_str) + s;
        }
        else
        {
            s = ellipsis + s.slice( 0, Math.min( s.length, Math.max( 1, (maxLength - ellipsisLength) ) ) );
        }

        return truncate( s, pMaxLength );
    }

    /**
     * Returns the text to the left of the FIRST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the left
     * @param pOf a string or number specifying the position after which to discard the rest of the string
     * @param pIncludeEllipsis boolean indicating whether to concatenate an ellipsis to the returned string
     * if the string was longer than the returned string
     * @param pMaxLength if this is > 0, then any returned value will be <= pMaxLength
     * @returns the text to the left of the FIRST occurrence of pOf
     * (or if pOf is a number, the index specified by pOf)
     * If pOf is not included in the specified string, returns the original string
     */
    const leftOf = function( pString, pOf, pIncludeEllipsis = false, pMaxLength = -1 )
    {
        const theString = asString( asString( pString, false ) || this.valueOf() || _mt_str );

        let s = (_mt_str + theString);

        const typeOf = typeof pOf;

        const pos = (_str === typeOf) ? theString.indexOf( pOf ) : asInt( pOf, theString?.length );

        if ( 0 <= pos )
        {
            s = theString.substring( 0, pos );

            if ( pIncludeEllipsis )
            {
                s = appendEllipsis( s, pMaxLength, _ellipsis );
            }
        }

        return truncate( s, pMaxLength );
    };


    /**
     * Returns the text to the right of the FIRST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the right
     * @param pOf a string or number specifying the position prior to which to discard a portion of the string
     * @param pIncludeEllipsis boolean indicating whether to prepend ellipsis if the returned string is shorter than the original string
     * @param pMaxLength
     * @returns the text to the right of the FIRST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     */
    const rightOf = function( pString, pOf, pIncludeEllipsis = false, pMaxLength = -1 )
    {
        const theString = asString( asString( pString, false ) || this.valueOf() || _mt_str );

        let s = asString( _mt_str + theString );

        const typeOf = typeof pOf;

        const pos = (_str === typeOf) ? theString.indexOf( pOf ) : asInt( pOf, theString?.length );

        if ( 0 <= pos )
        {
            s = theString.slice( pos + ((_str === typeOf) ? pOf.length : 1), theString.length );
        }

        if ( pIncludeEllipsis && ((theString?.length || 0) > (s?.length || 0)) )
        {
            s = prependEllipsis( s, pMaxLength, _ellipsis );
        }

        return truncate( s, pMaxLength );
    };

    /**
     * Returns the text to the left of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the left
     * @param pOf a string or number specifying the position after which to discard the rest of the string
     * @param pIncludeEllipsis boolean indicating whether to concatenate an ellipsis to the returned string if the string was longer than the returned string
     * @param pMaxLength
     * @returns the text to the left of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     */
    const leftOfLast = function( pString, pOf, pIncludeEllipsis = false, pMaxLength = -1 )
    {
        const theString = asString( asString( pString, false ) || this.valueOf() || _mt_str );

        let s = asString( _mt_str + theString );

        const typeOf = typeof pOf;

        const pos = (_str === typeOf) ? theString.lastIndexOf( pOf ) : asInt( pOf, theString?.length );

        if ( 0 <= pos )
        {
            s = theString.substring( 0, pos );

            if ( pIncludeEllipsis )
            {
                s = appendEllipsis( s, pMaxLength, _ellipsis );
            }
        }

        return truncate( s, pMaxLength );
    };

    /**
     * Returns the text to the right of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     * @param pString a string from which to extract text from the right
     * @param pOf a string or number specifying the position prior to the string to return
     * @param pIncludeEllipsis boolean indicating whether to concatenate an ellipsis to the returned string if the string was longer than the returned string
     * @param pMaxLength
     * @returns the text to the right of the LAST occurrence of pOf (or if pOf is a number, the index specified by pOf)
     */
    const rightOfLast = function( pString, pOf, pIncludeEllipsis = false, pMaxLength = -1 )
    {
        const theString = asString( asString( pString, false ) || this.valueOf() || _mt_str );

        let s = asString( _mt_str + theString );

        const typeOf = typeof pOf;

        const pos = (_str === typeOf) ? theString.lastIndexOf( pOf ) : asInt( pOf, theString?.length );

        if ( 0 <= pos )
        {
            s = theString.slice( pos + ((_str === typeOf) ? pOf.length : 1), theString.length );
        }

        if ( pIncludeEllipsis && ((theString?.length || 0) > (s?.length || 0)) )
        {
            s = prependEllipsis( s, pMaxLength, _ellipsis );
        }

        return truncate( s, pMaxLength );
    };


    const isJson = function( pStr )
    {
        if ( _str !== typeof pStr || isBlank( pStr ) )
        {
            return false;
        }

        const str = tidy( pStr ).trim().replace( /^[ \n\r]+/, _mt_str ).replace( /[ \n\r]+$/, _mt_str );

        const chars = (str.split( constants._mt_chr ));

        if ( chars.length > 1 )
        {
            if ( ("[" === chars[0]) && ("]" === chars[chars.length - 1]) )
            {
                return true;
            }

            if ( ("{" === chars[0]) && ("}" === chars[chars.length - 1]) )
            {
                return true;
            }

            if ( _dblqt === chars[0] && _dblqt === chars[chars.length - 1] )
            {
                return true;
            }

            if ( _sglqt === chars[0] && _sglqt === chars[chars.length - 1] )
            {
                return true;
            }

            if ( "null" === str || "void" === str || "undefined" === str || !(/[^0-9-.]+/.test( str )) )
            {
                return true;
            }
        }

        return false;
    };

    /**
     * Returns a string with all leading instances of the specified character removed
     * @param pStr a string from which to remove one or more leading instances of the specified character
     * @param pChar a single character to remove (recursively) from the start of the string,
     *              defaults to "0" to remove leading zeroes from would-be decimal numbers
     * @returns {string} a string with all leading instances of the specified character removed
     */
    const trimLeadingCharacters = function( pStr, pChar = "0" )
    {
        let char = asString( pChar ) || "0";

        let str = asString( pStr, true );

        while ( str.startsWith( char ) && str.length > 1 )
        {
            str = str.slice( 1 );
        }

        return str;
    };

    let DEFAULT_TRIM_MATCHING_OPTIONS = { leading: true, trailing: true, anywhere: false, case_sensitive: true };

    const trimMatchingChars = function( pStr, pRegExpOrChar = _spc, pOptions = DEFAULT_TRIM_MATCHING_OPTIONS )
    {
        const options = Object.assign( Object.assign( {}, DEFAULT_TRIM_MATCHING_OPTIONS ), pOptions || DEFAULT_TRIM_MATCHING_OPTIONS );

        let s = asString( pStr );

        let flags = (options.anywhere ? "g" : _mt_str) + (options.case_sensitive ? _mt_chr : "i");

        let regExp = pRegExpOrChar instanceof RegExp ? new RegExp( pRegExpOrChar, flags ) : new RegExp( asString( pRegExpOrChar ), flags );

        if ( isString( pRegExpOrChar ) && /^\//.test( pRegExpOrChar ) && /\/$/.test( pRegExpOrChar ) )
        {
            regExp = new RegExp( pRegExpOrChar.replace( /\/$/, _mt_str ).replace( /^\//, _mt_str ).replace( /\/$/, _mt_str ), flags );
        }

        if ( regExp && regExp instanceof RegExp )
        {
            if ( options.anywhere )
            {
                s = s.replaceAll( regExp, _mt_str );
            }

            if ( options.leading )
            {
                s = s.replace( new RegExp( "^" + regExp.source, flags ), _mt_str );
            }

            if ( options.trailing )
            {
                s = s.replace( new RegExp( regExp.source + "$", flags ), _mt_str );
            }
        }

        return s;
    };

    /**
     * Returns an integer value represented or implied by the value provided
     * @param {any} pValue a number or string representing a number
     * @param {number} pDefault a number to return if the value cannot be interpreted as a number
     *
     * NOTE: when converting floating point number to an integer, we round using half_even rounding
     *
     * @returns {number} an integer value represented by or implied by the value provided
     */
    const asInt = function( pValue, pDefault = 0 )
    {
        const zero = 0;

        let input = _resolveInput.call( this, pValue );

        const type = typeof input;

        if ( _ud === type || null === input )
        {
            return asInt( pDefault, zero );
        }

        if ( [_num, _big].includes( type ) )
        {
            const val = parseInt( (input).toFixed( zero ) );

            if ( isNaN( val ) || !isFinite( val ) )
            {
                return asInt( pDefault, zero );
            }

            return val;
        }

        if ( _bool === type )
        {
            return input ? 1 : zero;
        }

        let val = zero;

        input = asString( input, true );

        let radix = 10;

        if ( input.startsWith( "0" ) )
        {
            if ( /^0x/i.test( input ) )
            {
                radix = 16;
            }
            else if ( !(/[^0-7.-]/.test( input )) )
            {
                radix = 8;
            }
            else
            {
                input = trimLeadingCharacters( input, "0" );
            }
        }

        try
        {
            val = parseInt( asString( input, true ), radix );

            if ( isNaN( val ) || !isFinite( val ) )
            {
                val = asInt( pDefault, zero );
            }
        }
        catch( ex )
        {
            konsole.warn( pValue + " cannot be interpreted as a number", ex.message );
        }

        return val || zero;
    };

    String.prototype.asInt = asInt;
    Number.prototype.asInt = asInt;
    Boolean.prototype.asInt = asInt;

    /**
     * Returns a floating-point value represented or implied by the value provided
     * @param {any} pValue a value we expect to convertible to a float
     * @param {number} pDefault a value to return if pValue cannot be converted to a valid float
     * @param pOptions
     * @returns {number} an floating-point value represented or implied by the value provided
     */
    const asFloat = function( pValue, pDefault = 0, pOptions =
        {
            decimal_point: ".",
            grouping_separator: ",",
            currency_symbol: /\$|USD/
        } )
    {
        const zero = 0.0;
        const one = 1.0;

        let input = _resolveInput.call( this, pValue );

        const type = typeof input;

        let radix = 10;

        if ( _ud === type || null === input )
        {
            return asFloat( pDefault, zero );
        }

        if ( [_num, _big].includes( type ) )
        {
            if ( asString( input ).startsWith( "0" ) )
            {
                input = asString( input );
                return asFloat( input, pDefault, pOptions );
            }
            else
            {
                const val = parseFloat( input );

                if ( isNaN( val ) || !isFinite( val ) )
                {
                    return asFloat( pDefault, zero );
                }

                return val;
            }
        }

        if ( _bool === type )
        {
            return input ? one : zero;
        }

        let val = zero;

        input = asString( input, true );

        input = isBlank( pOptions.currency_symbol ) ? input : input.replaceAll( new RegExp( pOptions.currency_symbol, "g" ), _mt_str );

        if ( input.startsWith( "0" ) )
        {
            if ( /^0x/i.test( input ) )
            {
                radix = 16;
            }
            else if ( !(/[^0-7.-]/.test( input )) )
            {
                radix = 8;
            }
            else
            {
                input = trimLeadingCharacters( input, "0" );
            }
        }

        try
        {
            if ( 10 === radix )
            {
                val = parseFloat( asString( input, true ) );
            }
            else
            {
                let parts = input.split( pOptions.decimal_point || "." );

                let intPart = (parts?.length || 0) > 0 ? parts[0] : input;

                let decPart = (parts?.length || 0) > 1 ? parts[1] : _mt_str;

                val = asInt( intPart );

                if ( !isBlank( decPart ) )
                {
                    let digits = decPart.split( _mt_chr );
                    val = digits.reduce( ( sum, digit, index ) => sum + parseInt( digit, radix ) * Math.pow( radix, -(index + 1) ), val );
                }
            }

            if ( isNaN( val ) || !isFinite( val ) )
            {
                val = asFloat( pDefault, zero );
            }
        }
        catch( ex )
        {
            konsole.warn( pValue + " cannot be interpreted as a number", ex.message );
        }

        return val || zero;
    };

    String.prototype.asFloat = asFloat;
    Number.prototype.asFloat = asFloat;
    Boolean.prototype.asFloat = asFloat;

    /**
     * Returns the specified value if it is >= 0 and < the length of the specified indexed object
     *                                                               (such as an Array or String)
     * @param {number} pIndex - candidate value to return
     * @param {*} pIndexed - an object with a length property that represents an ability to address its properties via a numeric value for which pIndex will be used
     * @param {object} pOptions - a set of options to control subtle behaviors of the function, such as whether 0 or the last valid index is returned when the provided index is invalid
     * @returns {number} a number between 0 and one less than the length of the indexed object (i.e., Array or String)
     */
    const safeIndex = function( pIndex, pIndexed, pOptions = { defaultToEnd: false } )
    {
        const zero = 0;
        const one = 1;

        const arr = pIndexed || [];

        const maxIdx = Math.max( zero, (Math.min( (pOptions?.max || (arr?.length || zero)), ((arr?.length || zero) - one) )) );

        const minIdx = Math.max( zero, (pOptions?.min || -(one)) );

        const idx = asInt( (isNumber( pIndex ) ? pIndex : asFloat( pIndex )), (pOptions?.defaultToEnd ? maxIdx : minIdx) );

        if ( (arr?.length || zero) > idx )
        {
            return Math.max( minIdx, Math.min( idx, maxIdx ) );
        }

        if ( pOptions?.defaultToEnd )
        {
            return Math.min( arr?.length || 0, maxIdx );
        }

        return Math.max( minIdx, Math.min( (pOptions?.defaultToEnd ? maxIdx : zero) ) );
    };

    /**
     * Returns true if the string ends with any of the character sequences in the array
     * @param {string} pStr - a string to check for endings (the caller is responsible for removing whitespace if desired)
     * @param {[string]} pArr - one or more strings with which the string might end
     * @returns true if the string ends with any of the character sequences in the array
     */
    const endsWithAny = function( pStr, ...pArr )
    {
        const s = asString( pStr, false );

        const arr = [].concat( ...(pArr || []) );

        return arr?.length > 0 ? arr.some( e => s.endsWith( e ) ) : isEmpty( s );
    };

    /**
     * Returns true if the string starts with any of the character sequences in the array
     * @param {string} pStr - a string to evaluate (the caller is responsible for removing whitespace if desired)
     * @param {[string]} pArr - one or more strings with which the string might begin or regular expressions against which to test the string
     * @returns true if the string begins with any of the character sequences in the array
     */
    const startsWithAny = function( pStr, ...pArr )
    {
        const s = asString( pStr, true );

        const arr = [].concat( ...(pArr || []) );

        return arr?.length > 0 ? arr.some( e => (e instanceof RegExp) ? e.test( s ) : s.startsWith( e ) ) : isEmpty( s );
    };

    /**
     * Returns true if the string contains any of the character sequences in the array
     * @param {string} pStr - a string to check for substrings (the caller is responsible for removing whitespace if desired)
     * @param {[string]} pArr - one or more strings that the string might include
     * @returns true if the string includes any of the character sequences in the array
     */
    const includesAny = function( pStr, ...pArr )
    {
        const s = asString( pStr, false );

        const arr = [].concat( ...(pArr || []) );

        return arr?.length > 0 ? arr.some( e => s.includes( e ) ) : isEmpty( s );
    };

    /**
     * Returns true if the string includes ALL the character sequences in the array
     * @param {string} pStr - a string to check for substrings (the caller is responsible for removing whitespace if desired)
     * @param {[string]} pArr - one or more strings that the string must include
     * @returns true if the string includes ALL the character sequences in the array
     */
    const includesAll = function( pStr, ...pArr )
    {
        const s = asString( pStr, false );

        const arr = [].concat( ...(pArr || []) );

        return arr?.length > 0 ? arr.every( e => s.includes( e ) ) : isEmpty( s );
    };


    /**
     * Returns true if the value specified can be interpreted as an affirmative.
     * Used to allow configuration properties to be specified or obtained as strings, numbers, or even functions that return a truthy value
     * If the value specified is a function, the second parameter allows the caller to pass arguments to that function.
     *
     * @param {any} pValue the value or object to evaluate as a boolean (often a string)
     * @param  {...any} pFunctionArgs arguments to pass to the value being evaluated, if that value is a "function"
     * @returns {boolean} true if the value specified can be interpreted as an affirmative (or is a function that when called returns a "truthy" value)
     */
    const evaluateBoolean = function( pValue, ...pFunctionArgs )
    {
        let val = pValue;

        if ( _ud === typeof pValue )
        {
            if ( ((this instanceof Boolean || Boolean === this?.constructor || this === Boolean.prototype)) )
            {
                val = this.valueOf();
            }
        }

        // missing values are always interpreted as negatives (false)
        if ( (_ud === typeof val) || (undefined === val) || (null == val) || (_z === val) || false === val )
        {
            return false;
        }

        // boolean values are already true or false, so just return the value
        if ( _bool === typeof val || true === val )
        {
            return val;
        }

        // if the value is a string, we check to see if it is one of the strings defined to represent an affirmative (truthy) value
        if ( isString( val ) )
        {
            const value = lcase( tidy( val, {} ) );

            return !isBlank( value ) && _affirmatives.includes( value );
        }

        // if the value is a number, we consider any value > 0 to be a truthy value; note that NaN is considered false
        if ( _num === typeof val )
        {
            const value = parseFloat( val );

            if ( !isNaN( value ) )
            {
                return value > 0;
            }

            return false;
        }

        // if the value is a function, we try to invoke it with any arguments passed and return the result of evaluating its return value
        if ( _fun === (typeof val) )
        {
            try
            {
                return evaluateBoolean( val( ...(pFunctionArgs || []) ), ...(pFunctionArgs || []) );
            }
            catch( ex )
            {
                konsole.error( "An error occurred while trying to determine the verity of " + (val?.name || val.toString()) + " with arguments ", ...pFunctionArgs );

                return false;
            }
        }

        // if the value is an object, we return true if any of its properties evaluate to true;
        // note that this is an unexpected case at present, but exists to catch all argument types the function may encounter
        if ( _obj === typeof val )
        {
            if ( Array.isArray( val ) )
            {
                for( let i = val.length; i--; )
                {
                    if ( evaluateBoolean( val[i] ) )
                    {
                        return true;
                    }
                }
            }
            else
            {
                for( const prop in val )
                {
                    if ( Object.hasOwn( val, prop ) )
                    {
                        if ( evaluateBoolean( val[prop] ) )
                        {
                            return true;
                        }
                    }
                }
            }
        }

        return false;
    };

    const isTrue = evaluateBoolean;

    Boolean.prototype.evaluate = evaluateBoolean;

    /**
     * This function converts all (carriage return + line feed) sequences to line feed only sequences
     * @returns {string} a string where new lines are delimited by line feed characters only (without an extraneous carriage return character)
     * @param {String} s a string representing a path or path-like value whose line feeds will be converted
     */
    const toUnixLinebreaks = function( s )
    {
        let val = asString( s );

        let out = (asString( val )).replace( /(\r\n)/g, _lf );

        out = out.replaceAll( /(\n\r)/g, _lf );

        out = out.replaceAll( /[\n\r]/g, _lf );

        return out;
    };

    /**
     * This function converts all line-feed only sequences to (carriage return + line feed) sequences
     * @returns {string} a string where new lines are delimited by (carriage return + line feed) characters
     * @param {string} s - a string representing a path or path-like value whose line feeds will be converted
     */
    const toWindowsLinebreaks = function( s )
    {
        let val = asString( s );

        val = toUnixLinebreaks( val );

        return (asString( val )).replace( /\n/g, _crlf );
    };

    /**
     * Returns a filepath formatted for Linux or Unix
     * @param pPath a filepath, possibly in Windows format, to be transformed to a Unix-compatible filepath
     * @returns {string} a filepath formatted for Linux or Unix
     */
    const toUnixPath = function( pPath )
    {
        // trim any leading or trailing whitespace
        let path = asString( pPath, true );

        // replace any newline characters with a space character
        path = path.replace( /(\r\n)|(\n)/g, _spc );

        // escape any spaces in the path name
        path = path.replace( / /g, "\ " );

        // replace backslash with forward slash
        // and replace any duplicated path separators with a single separator
        path = path.replace( /[\\\/]/g, "/" ).replace( /\/\//g, "/" );

        return path.trim();
    };

    /**
     * Returns true if the specified path is expressed as relative to another path.
     * That is, this returns true if the path includes ./ or ../
     * @param {string} pPath a string representing a filepath that may or may not be relative to another path
     * @returns {boolean} true if the path includes ./ or ../
     */
    const isRelativePath = function( pPath )
    {
        let filepath = toUnixPath( pPath );

        return filepath.includes( _unixThisDir ) || filepath.includes( _unixPrevDir ) || filepath.startsWith( _dot );
    };

    /**
     * Returns an absolute filepath to the file or directory specified by pPath.
     * NOTE: This is equivalent to the node::path join or normalize functions,
     * but takes only 2 arguments and the second is assumed to represent an absolute path to the root directory
     *
     * @param {string} pPath a filepath relative to the root path
     * @param {string} pRootPath an absolute filepath to the root directory of the device on which this code is running
     * @returns {string|*} an absolute path to the file or directory specified by pPath
     */
    const toAbsolutePath = function( pPath, pRootPath )
    {
        let rootPath = toUnixPath( asString( pRootPath, true ) ) || __dirname;

        let filepath = toUnixPath( asString( pPath, true ) ) || __dirname;

        if ( !isRelativePath( filepath ) )
        {
            if ( filepath.startsWith( _unixPathSep ) )
            {
                return toUnixPath( rootPath + "/" + filepath );
            }
            return filepath;
        }

        const thisDir = _unixThisDir;

        // replace relative reference to the current directory
        while ( filepath.startsWith( thisDir ) && filepath.length >= thisDir.length )
        {
            // just remove the current directory reference, because we are going to prepend the base directory it represents
            filepath = filepath.length > thisDir.length ? filepath.slice( thisDir.length ) : _mt_str;
        }

        if ( filepath.startsWith( rootPath ) )
        {
            filepath = toUnixPath( filepath.replace( rootPath, _mt_str ) );
        }

        let dirs = [].concat( (filepath.split( _unixPathSep ) || []) ).filter( e => !isBlank( e ) );

        // the ".." sequence means the directory one level prior, so...
        // every time we find this, we will remove that array element and the previous array element
        // unless there is no previous array element, which means we have reached the root
        let idx = dirs.indexOf( _dot + _dot );

        function moreDirectoriesToProcess( idx, dirs )
        {
            return idx >= 0 && (idx < dirs.length) && (dirs.length > 1);
        }

        while ( moreDirectoriesToProcess( idx, dirs ) )
        {
            dirs.shift();

            // look for the next previous directory token
            idx = dirs.indexOf( _dot + _dot );
        }

        // rebuild the path for the array of directories
        filepath = dirs.join( _unixPathSep );

        return toUnixPath( rootPath + "/" + filepath );
    };

    /**
     * Returns true if the specified value is a string and is not the empty string (unless the third argument is true)
     * or a string containing the text "undefined", "null", or "void" (as can be the result of type coercion),
     * (unless the second argument is false or missing)
     *
     * @param {any} pString - a value that may or may not be a valid string as per our criteria
     *
     * @param {boolean} pRemoveCoercionArtifacts when true, the function will replace the literal text,
     * "void", "null", or "undefined" with the empty string.
     * This is sometimes necessary to compensate for APIs that return that text when coercing values to a string.
     *
     * @param {boolean} pAcceptEmptyString when true, this function returns true even if the string is the empty string
     *
     * @returns {boolean} true if the value specified is a string
     * and is not the empty string (unless the third argument is true)
     * or a string containing the text "undefined", "null", or "void" (as can be the result of type coercion),
     * (unless the second argument is false or missing)
     */
    const isValidString = function( pString, pRemoveCoercionArtifacts, pAcceptEmptyString )
    {
        if ( pString && (isString( pString )) )
        {
            let s = (_mt_str + (pRemoveCoercionArtifacts ? (_mt_str + pString).replace( /null|undefined|void/gi, _mt_str ) : pString));

            return pAcceptEmptyString || !isEmpty( s );
        }

        return false;
    };

    /**
     * Returns true if the specified string appears to be a JSON expression representing an Object.
     * This function does not attempt to parse the JSON.  Rather this just checks to see if the string begins with { and ends with }
     * @param pString a string that might be a JSON expression representing an Object
     * @param pTest
     * @returns {boolean} true if the string appears to be a JSON expression representing an Object
     * @throws Error if the argument passed is already an Object,
     * if we encounter an Error when trying to stringify that Object,
     * that Error will be thrown from this function
     */
    const isValidJsonObject = function( pString, pTest = false )
    {
        const s = isString( pString ) ? tidy( pString ) : _obj === typeof pString ? JSON.stringify( pString ) : _mt_str;

        let rx = new RegExp( _rxValidJson, "s" ); // the 's' flag means to enable dot (.) to match newline characters (\n)

        let matches = rx.exec( s );

        if ( !isNull( matches ) && matches.length > 3 && ("{" === matches[1] && "}" === matches[3]) )
        {
            try
            {
                return !pTest || typeUtils.isObject( JSON.parse( s ) );
            }
            catch( ex )
            {
                // ignore
            }
        }
        return false;
    };

    /**
     * Returns true if the specified string appears to be a JSON expression representing an Array.
     * This function does not attempt to parse the JSON.  Rather this just checks to see if the string begins with [ and ends with ]
     * @param pString a string that might be a JSON expression representing an Array
     * @param pTest
     * @returns {boolean} true if the string appears to be a JSON expression representing an Array
     * @throws Error if the argument passed is already an Array or Object,
     * if we encounter an Error when trying to stringify that Array or Object,
     * that Error will be thrown from this function
     */
    const isValidJsonArray = function( pString, pTest = false )
    {
        const s = isString( pString ) ? tidy( pString ) : _obj === typeof pString ? JSON.stringify( pString ) : _mt_str;

        let rx = new RegExp( _rxValidJson, "s" ); // the 's' flag means to enable dot (.) to match newline characters (\n)

        let matches = rx.exec( s );

        if ( matches && matches.length > 3 && ("[" === matches[1] && "]" === matches[3]) )
        {
            try
            {
                return !pTest || typeUtils.isArray( JSON.parse( s ) );
            }
            catch( ex )
            {
                // ignore
            }
        }
        return false;
    };

    const JSON_VALIDATION_OPTIONS =
        {
            jsonObjectsOnly: false,
            jsonArraysOnly: false,
            acceptPrimitives: false,
            jsonOptions: { objectsOnly: false, arraysOnly: false, test: false },
            testJson: false
        };

    /**
     * Returns true if the specified string appears to be a JSON expression representing an Object or Array.
     * This function does not attempt to parse the JSON.  Rather this just checks to see if the string begins with { and ends with } or begins with [ and ends with ]
     * @param pString a string that might be a JSON expression representing an Object
     * @param pOptions an object defining whether to return true only for Arrays or Objects
     * @returns {boolean} true if the string appears to be a JSON expression representing an Object or Array
     * @throws Error if the argument passed is already an Object or Array,
     * if we encounter an Error when trying to stringify that Object or Array,
     * that Error will be thrown from this function
     */
    const isValidJson = function( pString, pOptions = JSON_VALIDATION_OPTIONS )
    {
        const s = isString( pString ) ? tidy( pString ) : _obj === typeof pString ? JSON.stringify( pString ) : _mt_str;

        let testJson = pOptions?.testJson || pOptions?.jsonOptions?.test;

        if ( pOptions?.jsonObjectsOnly || pOptions?.jsonOptions?.objectsOnly )
        {
            return isValidJsonObject( s, testJson );
        }

        if ( pOptions?.jsonArraysOnly || pOptions?.jsonOptions?.arraysOnly )
        {
            return isValidJsonArray( s, testJson );
        }

        if ( pOptions?.acceptPrimitives )
        {
            if ( (s.startsWith( "\"" ) && s.endsWith( "\"" )) || (/\d+/g).test( s ) || "null" === s || "void" === s || S_TRUE === s || S_FALSE === s )
            {
                try
                {
                    return !testJson || !isNull( JSON.parse( s ) );
                }
                catch( ex )
                {
                    //ignore
                }
            }
        }

        let rx = new RegExp( _rxValidJson, "s" ); // the 's' flag means to enable dot (.) to match newline characters (\n)

        let matches = rx.exec( s );

        if ( matches && matches.length > 3 &&
             (("[" === matches[1] && "]" === matches[3]) || ("{" === matches[1] && "}" === matches[3])) )
        {
            try
            {
                return !testJson || !isNull( JSON.parse( s ) );
            }
            catch( ex )
            {
                // ignore
            }
        }

        return false;
    };

    const DEFAULT_VALID_NUMBER_OPTIONS =
        {
            minimumValue: Number.MIN_VALUE,
            maximumValue: Number.MAX_VALUE
        };

    /**
     * Returns true if the argument is a number
     * (and optionally, if it is in the valid range defined in the pOptions argument)
     *
     * @param {number} pNum a value to check for numeric validity
     *
     * @param {object} pOptions (optional) an object defining the minimum and maximum valid values accepted
     *
     * @returns true if the argument is a number (and optionally, if it is in the valid range defined in the pOptions argument)
     */
    const isValidNumber = function( pNum, pOptions = DEFAULT_VALID_NUMBER_OPTIONS )
    {
        const options = Object.assign( Object.assign( {}, DEFAULT_VALID_NUMBER_OPTIONS ), pOptions || {} );

        const minValue = Math.max( Number.MIN_VALUE, (0 === pOptions?.minimumValue ? 0 : options.minimumValue) );

        const maxValue = Math.min( Number.MAX_VALUE, (0 === pOptions?.maximumValue ? 0 : options.maximumValue) );

        // if the argument isn't defined, is null, or is not a numeric type or instance of Number, it is not valid, return false
        if ( _ud === typeof pNum || null == pNum || !([_num, _big].includes( typeof pNum ) || (_obj === typeof pNum && pNum instanceof Number)) )
        {
            return false;
        }

        let num = pNum;

        // we attempt to parse the value as a float and reject NaN or Infinity
        try
        {
            num = parseFloat( asString( pNum, true ) );

            if ( isNaN( num ) || !isFinite( num ) )
            {
                return false;
            }
        }
        catch( ex )
        {
            konsole.warn( ex.message );
        }

        // create a local variable to control the rest of the logic
        // initialize it according to what we know so far
        let valid = !((isNaN( pNum ) || !isFinite( pNum ) || isNaN( num ) || !isFinite( num )));

        // if the argument is a number, is it in the valid range specified
        if ( valid )
        {
            valid = num >= minValue && num <= maxValue;
        }

        // return the results
        return valid;
    };

    const isValidNumeric = function( pStr, pOptions = DEFAULT_VALID_NUMBER_OPTIONS )
    {
        if ( isValidNumber( pStr, pOptions ) )
        {
            return true;
        }

        switch ( typeof pStr )
        {
            case _str:
                let num = parseFloat( pStr ) || Number( pStr );

                if ( !(isNaN( num ) && Number.isFinite( Number( pStr ) )) )
                {
                    return isValidNumber( num, pOptions );
                }

                break;

            case _obj:
                if ( pStr instanceof Number || pStr instanceof BigInt )
                {
                    return isValidNumber( parseInt( pStr ) );
                }
                break;

            case _fun:

                try
                {
                    let n = pStr.call( $scope(), pStr );
                    return isValidNumber( n, pOptions );
                }
                catch( ex )
                {
                    // ignore
                }
                break;

            default:
                break;
        }
        return false;
    };

    /**
     * Returns the string representation of the specified argument in all lowercase characters.
     * Shorthand for asString( pStr, false ).toLowerCase();
     * @param pStr a string or value that can be converted to a string using asString
     * @returns {string} the string representation of the specified argument in all lowercase characters
     */
    const lcase = function( pStr )
    {
        return asString( pStr, false ).toLowerCase();
    };

    /**
     * Returns the string representation of the specified argument in all uppercase characters.
     * Shorthand for asString( pStr, false ).toUpperCase();
     * @param pStr a string or value that can be converted to a string using asString
     * @returns {string} the string representation of the specified argument in all uppercase characters
     */
    const ucase = function( pStr )
    {
        return asString( pStr, false ).toUpperCase();
    };

    const MC_OPTIONS =
        {
            prefixes: ["Mc", "Mac", "O'"],
        };

    /**
     * Used by other methods to handle surnames with mix capitalization
     * @param pString a string that might represent a mixed cased surname
     * @param pOptions an object specifying additional surname prefixes to handle
     * @returns {string} a string with proper capitalization of the name
     */
    const handleMc = function handleMc( pString, pOptions = MC_OPTIONS )
    {
        const options = Object.assign( Object.assign( {}, MC_OPTIONS ), pOptions || {} );

        let s = asString( pString, false ) || _mt_str;

        if ( !includesAny( s, options?.prefixes ) )
        {
            return s;
        }

        let out = _mt_str;

        let tokens = s.split( " " );

        for( let i = 0, n = tokens.length; i < n; i++ )
        {
            let t = tokens[i];

            let prefixes = ["Mc", "Mac", "O'"].concat( options?.prefixes || [] );

            let Mc = -1;
            let len = 0;

            while ( Mc !== 0 && prefixes.length > 0 )
            {
                let prefix = prefixes.shift();

                Mc = t.indexOf( prefix );

                len = prefix.length;

                if ( Mc === 0 && len > 0 )
                {
                    break;
                }
            }

            if ( Mc === 0 && t.length > len )
            {
                t = t.substring( 0, len ) + t.substring( len, len + 1 ).toUpperCase() + t.substring( len + 1, t.length );
            }

            out += (t + _spc);
        }

        return out.trim();
    };

    const DEFAULT_PROPERCASE_OPTIONS =
        {
            separator: _spc,
            surnamePrefixes: ["Mc", "Mac"]
        };

    /**
     * Returns a string with the first letter capitalized,
     * also handling common surnames that include an apostrophe, Mc, or Mac
     * @param pStr the string to convert to ProperCase
     * @param pOptions an object defining the separator to use to split the string into 'words' as well as other behaviors
     * @returns {string}
     */
    const toProperCase = function( pStr, pOptions = DEFAULT_PROPERCASE_OPTIONS )
    {
        const options = Object.assign( Object.assign( {}, DEFAULT_PROPERCASE_OPTIONS ), pOptions || {} );

        let s = asString( pStr, false ) || _mt_str;

        let out = _mt_str;

        let sep = (options?.separator || _spc);

        let words = s.split( sep ).filter( e => !isEmpty( e ) );

        let word = _mt_str;

        let temp = _mt_str;

        for( let i = 0; i < words.length; i++ )
        {
            temp = _mt_str;

            // reset
            word = words[i];

            out += word.substring( 0, 1 ).toUpperCase();

            temp = word.substring( 1, word.length ).toLowerCase();

            if ( temp.indexOf( "'" ) >= 0 )
            {
                //handle O'Leary
                temp = "'" + toProperCase( temp, { separator: "'" } );
            }

            let pos = temp.indexOf( "-" );

            if ( pos >= 0 )
            {
                //handle Thorne-Smith (temp = horne-smith )
                temp = temp.substring( 0, pos ) + "-" + handleMc( temp.substring( pos + 1, pos + 2 ).toUpperCase() + temp.substring( pos + 2, temp.length ) );
            }

            out += temp;

            if ( i < (words.length - 1) )
            {
                out += sep;
            }
            else
            {
                if ( s.substring( s.length - 1 ) === _spc )
                {
                    out += _spc;
                }
            }
        }

        out = handleMc( out ) || out;

        return out;
    };

    /**
     * Converts a string in "snake case" ( some_variable_name ) into "camel case" ( someVariableName )
     * @param pStr a string to convert to camel case
     * @returns {string} the specified string formatted in "camel case"
     */
    const toCamelCase = function( pStr )
    {
        let s = asString( pStr, false ) || _mt_str;

        s = lcase( s.slice( 0, 1 ) ) + s.slice( 1 );

        let re = /_+(\w)/gi;

        function lambda( pMatch )
        {
            let match = pMatch.replace( /^_+/, _mt_str );

            return match.substring( 0 ).toUpperCase() + match.substring( 1 ).toLowerCase();
        }

        return s.replace( re, lambda );
    };

    /**
     * Converts a string in camelCase (or other format) ( someVariableName ) into "snake case" ( some_variable_name )
     * @param pStr a string to convert to camel case
     * @returns {string} the specified string formatted in "snake case"
     */
    const toSnakeCase = function( pStr )
    {
        let s = (asString( pStr, false ) || _mt_str);

        s = lcase( s.slice( 0, 1 ) ) + s.slice( 1 );

        let re = /[A-Z]/g;

        function lambda( pMatch )
        {
            return (_underscore + lcase( (pMatch.substring( 0 )) ));
        }

        return lcase( s.replace( re, lambda ) ).replaceAll( /_{2,}/g, _underscore );
    };

    /**
     * This is an extremely 'paranoid' function for producing a copy of a string that cannot possibly be pointing to the original string in memory
     * @param pStr  a string to copy
     * @returns {string} a string with the same characters as the string specified, but not identical to that string
     */
    const copyString = function( pStr )
    {
        const s = asString( pStr, false );

        return (_mt_str + ([].concat( ...(asString( s, false ).split( _mt_chr )) ) || []).join( _mt_chr ));
    };

    /**
     * Returns true if the argument is not a string or if the string contains only whitespace
     * @param pStr a value to test
     * @returns {boolean} true if the argument is not a string or if the string contains only whitespace
     */
    const isUnpopulated = function( pStr )
    {
        return (_ud === typeof pStr || null == pStr || ( !typeUtils.isString( pStr ) || isBlank( pStr )));
    };

    const reverseString = function( pStr )
    {
        let arr = [].concat( pStr );

        if ( null == pStr || _ud === typeof pStr )
        {
            return _mt_str;
        }

        switch ( typeof pStr )
        {
            case _ud:
                arr = [];
                break;

            case _str:
                arr = pStr.split( _mt_chr );
                break;

            case _num:
            case _big:
                let s = asString( pStr );
                arr = s.split( _mt_chr );
                break;

            case _fun:
                arr = [];
                break;

            case _obj:

                if ( typeUtils.isArray( pStr ) )
                {
                    arr = [].concat( pStr );
                }

                break;

            default:
                break;
        }

        arr = arr.reverse();

        return asString( arr.join( _mt_chr ) );
    };

    const DEFAULT_TIDY_OPTIONS =
        {
            trim: true,
            removeRedundantSpaces: true,
            replaceTabsWithSpaces: false,
            replaceSpacesWithTabs: false,
            spacesPerTab: 4,
            functions: [],
            lowercase: false,
            uppercase: false,
            camelCase: false,
            snakeCase: false,
            properCase: false
        };

    /**
     * A null-safe, type-safe, alternative to the String method, trim
     * Trims and returns a string or a char[] or a string representation
     * of the value passed
     *
     * Tidy performs optional transformations specified in the optional second argument, pOptions.
     * This function can be used as a sort of 'swiss army knife' for strings, based on the options passed,
     * especially the ability to pass one or more functions to transform the result
     *
     * @param {string} s - the value to trim and return as a String
     * @param {object} pOptions - optional operations or transformations to perform on the string,
     *                            such as toLowerCase, toUpperCase, removeRedundantSpaces, replaceSpacesWithTabs, replaceTabsWithSpaces, etc.
     *                            It is also possible to pass one or more functions to apply to the string before it is returned.
     *
     * @returns {string} a string or char[] or a string representation
     * of the value passed with whitespace removed
     * and any optional transformations applied
     */
    const tidy = function( s, pOptions = DEFAULT_TIDY_OPTIONS )
    {
        if ( _ud === typeof s || null == s )
        {
            // note that we code this in such a way that it can be bound to the String.prototype as a member function (a.k.a. method)
            if ( (this instanceof String || String === this?.constructor) && _fun === typeof this.tidy )
            {
                return tidy( String( this ).valueOf() || asString( this, pOptions?.trim ), pOptions );
            }

            return _mt_str;
        }

        const options = Object.assign( Object.assign( {}, DEFAULT_TIDY_OPTIONS ), pOptions || {} );

        let str = asString( s, options?.trim );

        if ( options?.trim )
        {
            str = str.replace( /[\r\n]/g, _mt_str ).trim();
        }

        if ( options.replaceTabsWithSpaces )
        {
            str = str.replace( /\t/g, _spc.repeat( Math.max( 1, asInt( options?.spacesPerTab || 1 ) ) ) );
        }

        if ( options.replaceSpacesWithTabs )
        {
            str = str.replace( new RegExp( _spc.repeat( Math.max( 1, asInt( options?.spacesPerTab || 1 ) ) ), "g" ), "\t" );
        }

        if ( options.removeRedundantSpaces )
        {
            str = str.replace( / {2,}/g, _spc );
        }

        let operations = [];

        if ( options?.functions )
        {
            operations = operations.concat( ...(options?.functions || []) ).filter( e => isFunction( e ) && e.length > 0 );
        }

        if ( options?.toLowerCase || options?.lowercase )
        {
            str = lcase( str );
        }
        else if ( options?.toUpperCase || options?.uppercase )
        {
            str = ucase( str );
        }
        else if ( options?.capitalize )
        {
            str = str.length > 1 ? ucase( str.slice( 0, 1 ) ) + lcase( str.slice( 1 ) ) : ucase( str );
        }
        else if ( options?.camelCase || options?.toCamelCase )
        {
            str = toCamelCase( str );
        }
        else if ( options?.snakeCase || options?.toSnakeCase )
        {
            str = toSnakeCase( str );
        }
        else if ( options?.properCase || options?.toProperCase )
        {
            str = toProperCase( str, Object.assign( {}, options || {} ) );
        }

        let temp = (_mt_str + asString( str ));

        if ( operations.length )
        {
            for( let i = 0, n = operations.length; i < n; i++ )
            {
                const func = operations[i];

                if ( isFunction( func ) )
                {
                    try
                    {
                        str = func.apply( $scope, [str, options] );
                    }
                    catch( ex )
                    {
                        konsole.error( ex.message );
                    }
                }

                str = str || temp;
            }
        }

        str = (asString( str, options?.trim ));

        return str;
    };

    String.prototype.tidy = tidy;

    class StringComparatorFactory extends ComparatorFactory
    {
        constructor( pOptions )
        {
            super( _str, pOptions );
        }

        _compare( pA, pB, pOptions )
        {
            let comp = super._compare( pA, pB, pOptions );

            if ( 0 === comp )
            {
                let a = asString( pA, this.trimStrings );
                let b = asString( pB, this.trimStrings );

                if ( !this.caseSensitive )
                {
                    a = ucase( a );
                    b = ucase( b );
                }

                comp = a > b ? 1 : a < b ? -1 : 0;

                if ( 0 === comp )
                {
                    a = asString( pA, this.trimStrings );
                    b = asString( pB, this.trimStrings );

                    comp = a > b ? 1 : a < b ? -1 : 0;
                }

                if ( this.reverse )
                {
                    comp = -comp;
                }
            }

            return comp;
        }
    }

    const mod =
        {
            dependencies,
            asString,
            isEmpty,
            isBlank,
            isUnpopulated,
            isAllCaps,
            isNoCaps,
            isMixedCase,
            tidy,
            leftOf,
            leftOfLast,
            rightOf,
            rightOfLast,
            trimLeadingCharacters,
            trimMatchingChars,
            asInt,
            asFloat,
            safeIndex,
            validIdentifier,
            asKey,
            endsWithAny,
            startsWithAny,
            includesAny,
            includesAll,
            evaluateBoolean,
            isTrue,
            toUnixLinebreaks,
            toWindowsLinebreaks,
            isValidString,
            isValidNumber,
            isValidNumeric,
            isValidJsonObject,
            isValidJsonArray,
            isValidJson,
            isJson,
            lcase,
            ucase,
            toCamelCase,
            toSnakeCase,
            toProperCase,
            copyString,
            reverseString,
            capitalize: (( str ) => (((str?.length || 0) > 1) ? (str.slice( 0, 1 ).toUpperCase()) + (str.slice( 1 ).toLowerCase()) : asString( str, false ).toUpperCase())),
            toUnixPath,
            isRelativePath,
            toAbsolutePath,
            toCString,
            fromCString,
            formatMessage,
            interpolate,
            classes: { StringComparatorFactory },
            StringComparatorFactory
        };

    if ( _ud !== typeof module )
    {
        module.exports = Object.freeze( mod );
    }

    if ( $scope() )
    {
        $scope()[INTERNAL_NAME] = Object.freeze( mod );
    }

    return Object.freeze( mod );

}());
