const utils = require( "./CommonUtils.cjs" );

/**
 * Establish separate constants for each of the common utilities imported
 * @see ../utils/CommonUtils.cjs
 */
const constants = utils?.constants || require( "./Constants.cjs" );
const typeUtils = utils?.typeUtils || require( "./TypeUtils.cjs" );
const stringUtils = utils?.stringUtils || require( "./StringUtils.cjs" );
const arrayUtils = utils?.arrayUtils || require( "./ArrayUtils.cjs" );
const objectUtils = utils?.objectUtils || require( "./ObjectUtils.cjs" );

const konsole = console || {};

const _ud = constants?._ud || "undefined";

const $scope = utils?.$scope || function()
{
    return (_ud === typeof self ? ((_ud === typeof global) ? ((_ud === typeof globalThis ? {} : globalThis)) : (global || {})) : (self || {}));
};

const logUtils = require( "./LogUtils.cjs" );

(function exposeGenerator()
{
    utils.importUtilities( this, constants, stringUtils, arrayUtils, objectUtils );

    const INTERNAL_NAME = "__BOCK_UTILS_ID_GENERATOR__";

    if ( $scope() && (null != $scope()[INTERNAL_NAME]) )
    {
        return $scope()[INTERNAL_NAME];
    }

    const defaultPrefix = "";

    // noinspection SpellCheckingInspection
    /**
     * These are the 'digits' of what is essentially a base-36 number.
     * A value of 1000000 = 0
     * A value of 100000Z precedes 1000010
     * A value of 10000ZZ precedes 1000100
     * ... and so on...
     */
    const defaultDigits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    const defaultLast = "ZZZZZZ";


    const readLastValue = async function( pDatastore, pTableOrCollection, pKeyColumnOrProperty, pKeyValue, pValueColumnOrProperty )
    {
        let last = defaultLast;

        const db = (pDatastore || pStorageHandler);

        const dbCollection = pTableOrCollection || "value_store";
        const dbKey = pKeyColumnOrProperty || "key";
        const dbKeyValue = pKeyValue;
        const dbValueKey = pValueColumnOrProperty;

        try
        {
            const queryOptions =
                {
                    fields: "value",
                    conditions: { "key": dbLastValueLookupKey }
                };

            let results = await db.select( dbCollection, queryOptions );

            results = asArray( results || [] ) || [];

            if ( results?.length )
            {
                last = asString( asString( (results[0]?.value || results), true ) || last, true );
            }
        }
        catch( ex )
        {
            console.error( "An error occurred while reading the last generated claim ID", logUtils.err( ex ) );
        }

        last = ucase( asString( last, true ) );

        return last;
    };

    const makeGenerator = async function( pPrefix, pStorageHandler, pOptions )
    {
        /**
         * This is an optional argument to define the 'seed' values,
         * such as the prefix, the digits (which defines the numeric base),
         * and the last value generated (defaults to 9_999_999)
         */
        const options = Object.assign( {}, pOptions || {} );

        /**
         * This is the instance specific prefix, a.k.a. LocationID
         */
        const prefix = asString( pPrefix ) || asString( asString( options?.prefix, true ) || defaultPrefix, true );

        /**
         * This is an optional separator that, if specified is inserted
         * between the prefix and the incrementing base-n numeric portion of the ID
         * The default is no separator (that is, the empty string)
         */
        const separator = asString( (options?.separator || _mt_str), true ) || _mt_str;

        /**
         * These are the digits for the incrementing values, also defining the numeric base
         * The default is the set of numerals 0-9 and the letters A-Z
         * This allows for a base-36 numeric portion
         */
        const digits = asString( (asString( options?.digits, true ) || defaultDigits), true );

        const arrDigits = digits.split( _mt_chr );

        /**
         * This is the numeric base of the incrementing portion of the ID
         * The default is base-36, using the numerals 0-9 and the letters A-Z
         */
        const base = asString( digits, true )?.length;

        const incAmount = Math.min( Math.max( stringUtils.asInt( options?.step ) || 1, 1 ), Math.max( (base - 1), 1 ) );

        /**
         * Optional value limiting the length of the numeric portion of the ID
         * The default is 7.
         * A 7-digit base-36 number has a maximum value somewhere between 21.76 billion and 783.6 billion.
         *
         * @type {number}
         */
        const maxLength = Math.min( Math.max( 1, asInt( options?.maxLength ) || 7 ), 12 );

        /**
         * This is the last numeric value generated by this function.
         * This value must be written and read to persistent storage.
         * In the event of a server restart, the numbering must not repeat or restart.
         */
        let lastValue = await readLastValue( pStorageHandler );

        lastValue = ucase( asString( asString( lastValue, true ) || options.lastValue ) || defaultLast );

        lastValue = lastValue.padStart( maxLength, "0" );


        const writeLastValue = async function( pLastValue, pDatastore, pOptions )
        {
            let last = pLastValue || lastValue || defaultLast;

            const db = (pDatastore || pStorageHandler);

            try
            {
                let deleteResults = await db.delete( dbCollection,
                                                     {
                                                         propertyName: dbKey,
                                                         propertyValues: [dbLastValueLookupKey]
                                                     } );

            }
            catch( ex )
            {
                console.error( "An error occurred while deleting the last generated claim ID", logUtils.err( ex ) );
            }

            let simpleValue = new SimpleValue( dbLastValueLookupKey, last );

            try
            {
                simpleValue = await db.insert( dbCollection, simpleValue, pOptions );
            }
            catch( ex )
            {
                console.error( "An error occurred while saving the last generated claim ID, " + last, logUtils.err( ex ) );
            }

            return simpleValue?.value || last;
        };

        const generator = function* ()
        {
            let exhausted = (lastValue?.length > maxLength);

            while ( !exhausted )
            {
                let lastDigits = lastValue.split( _mt_str ).map( char =>
                                                                 {
                                                                     const code = char.charCodeAt( 0 );
                                                                     return (48 <= code && 57 >= code) ? (code - 48) : (code - 55);
                                                                 } );

                let nextValue = arrayUtils.copyArray( lastDigits );

                let carryOver = false;

                let increment = true;

                for( let i = Math.max( lastDigits?.length, maxLength ); i--; )
                {
                    let value = lastDigits[i] + (increment ? incAmount : 0);

                    carryOver = (value >= base);

                    if ( carryOver )
                    {
                        nextValue[i] = 0;

                        if ( 0 >= i )
                        {
                            nextValue.shift( 1 );
                        }
                    }
                    else
                    {
                        nextValue[i] = value;
                        increment = false;
                    }
                }

                nextValue = nextValue.map( ( idx ) => { return arrDigits[idx]; } );

                let nextId = nextValue.join( _mt_chr );

                lastValue = nextId;

                // noinspection JSIgnoredPromiseFromCall
                writeLastValue( lastValue, pStorageHandler, options ); // but do not await

                exhausted = (lastValue?.length > maxLength);

                yield prefix + separator + nextId;
            }
        };

        generator.options = Object.freeze( options );
        generator.prefix = prefix;
        generator.separator = separator;
        generator.digits = arrDigits;
        generator.base = base;
        generator.incrementBy = incAmount;
        generator.maxLength = maxLength;
        generator.startValue = lastValue;
        generator.readLastValue = readLastValue;

        return generator();
    };

    class ClaimIdGenerator
    {
        constructor( pGenerator, pLocationId, pStorageHandler, pOptions )
        {
            this._options = Object.assign( {}, pOptions ||
                {
                    database: pStorageHandler || pOptions?.database,
                    locationId: pLocationId || pOptions?.locationId,
                    generator: (pGenerator || makeGenerator( (pLocationId || pOptions?.locationId),
                                                             (pStorageHandler || pOptions?.storageHandler || pOptions?.database),
                                                             pOptions ))
                } );

            this._generator = pGenerator || this._options?.generator || makeGenerator( (pLocationId || pOptions?.locationId),
                                                                                       (pOptions?.storageHandler || pOptions?.database),
                                                                                       this._options );
            this._locationId = pLocationId || this._options?.locationId;

            this._database = pStorageHandler || this._options?.database;
        }

        getNdsClaimId( pClaim )
        {
            // TODO: query the database for an existing claim,
            // if found, return its ndsClaimId,
            // otherwise, use the generator to create and return a new one
        }
    }

    // noinspection SpellCheckingInspection
    const mod =
        {
            classes: { ClaimIdGenerator },
            makeGenerator,
            ClaimIdGenerator
        };

    if ( _ud !== typeof module )
    {
        module.exports = Object.freeze( mod );
    }

    if ( $scope() )
    {
        $scope()[INTERNAL_NAME] = Object.freeze( mod );
    }

    return Object.freeze( mod );

}());
